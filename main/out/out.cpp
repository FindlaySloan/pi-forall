#include <vector>
#include <functional>
#include <thread>
#include <optional>
#include <iostream>
#include <memory>
#include <system_error>
#include <map>
#include <string>
#include <cstdint>
#include "LockingCQueue.hpp"
#include "Semaphore.hpp"

// Forward declares
template <typename A>
class _Maybe;
std::thread* getThread(uint64_t pid);
void addThread(uint64_t pid, std::thread* t);
void* getChannel(uint64_t chid);
template <typename A>
void addChannel(uint64_t chid, LockingCQueue<_Maybe<A>>* queue);

// map of threads
std::map<uint64_t, std::thread*> pidsMap;
std::mutex pidMutex;

// map of channels
std::map<uint64_t, void*> channelsMap;
std::mutex channelMutex;

// enum _enum_Nat_type { Zero, Succ };
// class _Nat_Zero;
// class _Nat_Succ;
// class _Nat {
//  public:
//   enum _enum_Nat_type type;
//   std::shared_ptr<void> data;
//   static _Nat _Zero();
//   static _Nat _Succ(_Nat _1);
//   _Nat(_enum_Nat_type t, std::shared_ptr<void> d) {
//     type = t;
//     data = d;
//   }
//   _Nat(const _Nat& other);
//   _Nat() = default;
// };
// class _Nat_Zero {
//  public:
//   _Nat_Zero(){};
//   _Nat_Zero(const _Nat_Zero* other) {}
// };
// class _Nat_Succ {
//  public:
//   _Nat _1;
//   _Nat_Succ(_Nat _1) { this->_1 = _1; };
//   _Nat_Succ(const _Nat_Succ* other) { this->_1 = other->_1; }
// };
// inline _Nat _Nat::_Zero() {
//   return _Nat(Zero, std::static_pointer_cast<void>(std::make_shared<_Nat_Zero>()));
// };
// inline _Nat _Nat::_Succ(_Nat _1) {
//   return _Nat(Succ, std::static_pointer_cast<void>(std::make_shared<_Nat_Succ>(_1)));
// };
// _Nat::_Nat(const _Nat& other) {
//   type = other.type;
//   data = other.data;
// }
// std::function<uint64_t(_Nat)> intFromNat = [](_Nat n) {
//     if (n.type == Zero) {
//         return 0;
//     } else {
//         return (uint64_t)1 + intFromNat((*(std::static_pointer_cast<_Nat_Succ>(n.data)))._1);
//     }
// };

// List



// Void 
enum _enum_Void_type {};
class _Void {
 public:
  enum _enum_Void_type type;
  std::shared_ptr<void> data;
};


// TyEq

class _TyEq { 
    public: 
        static _TyEq _Refl();
};

inline _TyEq _TyEq::_Refl() {
    return _TyEq{};
}enum _enum_Sigma_type {Prod};template <class a, class b> class _Sigma_Prod;
template <class a, class b> class _Sigma { public: enum _enum_Sigma_type type; std::shared_ptr<void> data;static _Sigma<a,b> _Prod(a _1, b _2);_Sigma<a,b>(_enum_Sigma_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Sigma<a,b>(const _Sigma<a,b>& other);
_Sigma<a,b>() = default;};template <class a, class b> class _Sigma_Prod { public: a _1;b _2;_Sigma_Prod (a _1, b _2) {this->_1= _1;this->_2= _2;};_Sigma_Prod (const _Sigma_Prod* other) { this->_1= other->_1;this->_2= other->_2;} };template <class a, class b>  inline _Sigma<a,b> _Sigma<a,b>::_Prod(a _1, b _2){ return  _Sigma<a,b> ( Prod, std::make_shared<_Sigma_Prod<a,b>>(_1, _2)); };template <class a, class b> _Sigma<a,b>::_Sigma(const _Sigma<a,b>& other) { type = other.type; data = other.data; } 
enum _enum_Unit_type {unit};class _Unit_unit;
class _Unit { public: enum _enum_Unit_type type; std::shared_ptr<void> data;static _Unit _unit();_Unit(_enum_Unit_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Unit(const _Unit& other);
_Unit() = default;};class _Unit_unit { public: _Unit_unit () {};_Unit_unit (const _Unit_unit* other) { } }; inline _Unit _Unit::_unit(){ return  _Unit ( unit, std::make_shared<_Unit_unit>()); };_Unit::_Unit(const _Unit& other) { type = other.type; data = other.data; } 
enum _enum_Bool_type {False,True};class _Bool_False;
class _Bool_True;
class _Bool { public: enum _enum_Bool_type type; std::shared_ptr<void> data;static _Bool _False();static _Bool _True();_Bool(_enum_Bool_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Bool(const _Bool& other);
_Bool() = default;};class _Bool_False { public: _Bool_False () {};_Bool_False (const _Bool_False* other) { } };class _Bool_True { public: _Bool_True () {};_Bool_True (const _Bool_True* other) { } }; inline _Bool _Bool::_False(){ return  _Bool ( False, std::make_shared<_Bool_False>()); }; inline _Bool _Bool::_True(){ return  _Bool ( True, std::make_shared<_Bool_True>()); };_Bool::_Bool(const _Bool& other) { type = other.type; data = other.data; } 
enum _enum_List_type {Nil,Cons};template <class c> class _List_Nil;
template <class c> class _List_Cons;
template <class c> class _List { public: enum _enum_List_type type; std::shared_ptr<void> data;static _List<c> _Nil();static _List<c> _Cons(c _1, _List<c> _2);_List<c>(_enum_List_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_List<c>(const _List<c>& other);
_List<c>() = default;};template <class c> class _List_Nil { public: _List_Nil () {};_List_Nil (const _List_Nil* other) { } };template <class c> class _List_Cons { public: c _1;_List<c> _2;_List_Cons (c _1, _List<c> _2) {this->_1= _1;this->_2= _2;};_List_Cons (const _List_Cons* other) { this->_1= other->_1;this->_2= other->_2;} };template <class c>  inline _List<c> _List<c>::_Nil(){ return  _List<c> ( Nil, std::make_shared<_List_Nil<c>>()); };template <class c>  inline _List<c> _List<c>::_Cons(c _1, _List<c> _2){ return  _List<c> ( Cons, std::make_shared<_List_Cons<c>>(_1, _2)); };template <class c> _List<c>::_List(const _List<c>& other) { type = other.type; data = other.data; } 
enum _enum_Maybe_type {Nothing,Just};template <class A> class _Maybe_Nothing;
template <class A> class _Maybe_Just;
template <class A> class _Maybe { public: enum _enum_Maybe_type type; std::shared_ptr<void> data;static _Maybe<A> _Nothing();static _Maybe<A> _Just(A _1);_Maybe<A>(_enum_Maybe_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Maybe<A>(const _Maybe<A>& other);
_Maybe<A>() = default;};template <class A> class _Maybe_Nothing { public: _Maybe_Nothing () {};_Maybe_Nothing (const _Maybe_Nothing* other) { } };template <class A> class _Maybe_Just { public: A _1;_Maybe_Just (A _1) {this->_1= _1;};_Maybe_Just (const _Maybe_Just* other) { this->_1= other->_1;} };template <class A>  inline _Maybe<A> _Maybe<A>::_Nothing(){ return  _Maybe<A> ( Nothing, std::make_shared<_Maybe_Nothing<A>>()); };template <class A>  inline _Maybe<A> _Maybe<A>::_Just(A _1){ return  _Maybe<A> ( Just, std::make_shared<_Maybe_Just<A>>(_1)); };template <class A> _Maybe<A>::_Maybe(const _Maybe<A>& other) { type = other.type; data = other.data; } 
enum _enum_Vec_type {NilV,ConsV};template <class A> class _Vec_NilV;
template <class A> class _Vec_ConsV;
template <class A> class _Vec { public: enum _enum_Vec_type type; std::shared_ptr<void> data;static _Vec<A> _NilV();static _Vec<A> _ConsV(A _1, _Vec<A> _2);_Vec<A>(_enum_Vec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Vec<A>(const _Vec<A>& other);
_Vec<A>() = default;};template <class A> class _Vec_NilV { public: _Vec_NilV () {};_Vec_NilV (const _Vec_NilV* other) { } };template <class A> class _Vec_ConsV { public: A _1;_Vec<A> _2;_Vec_ConsV (A _1, _Vec<A> _2) {this->_1= _1;this->_2= _2;};_Vec_ConsV (const _Vec_ConsV* other) { this->_1= other->_1;this->_2= other->_2;} };template <class A>  inline _Vec<A> _Vec<A>::_NilV(){ return  _Vec<A> ( NilV, std::make_shared<_Vec_NilV<A>>()); };template <class A>  inline _Vec<A> _Vec<A>::_ConsV(A _1, _Vec<A> _2){ return  _Vec<A> ( ConsV, std::make_shared<_Vec_ConsV<A>>(_1, _2)); };template <class A> _Vec<A>::_Vec(const _Vec<A>& other) { type = other.type; data = other.data; } 
enum _enum_Tuple_type {MkTuple};template <class a, class b> class _Tuple_MkTuple;
template <class a, class b> class _Tuple { public: enum _enum_Tuple_type type; std::shared_ptr<void> data;static _Tuple<a,b> _MkTuple(a _1, b _2);_Tuple<a,b>(_enum_Tuple_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Tuple<a,b>(const _Tuple<a,b>& other);
_Tuple<a,b>() = default;};template <class a, class b> class _Tuple_MkTuple { public: a _1;b _2;_Tuple_MkTuple (a _1, b _2) {this->_1= _1;this->_2= _2;};_Tuple_MkTuple (const _Tuple_MkTuple* other) { this->_1= other->_1;this->_2= other->_2;} };template <class a, class b>  inline _Tuple<a,b> _Tuple<a,b>::_MkTuple(a _1, b _2){ return  _Tuple<a,b> ( MkTuple, std::make_shared<_Tuple_MkTuple<a,b>>(_1, _2)); };template <class a, class b> _Tuple<a,b>::_Tuple(const _Tuple<a,b>& other) { type = other.type; data = other.data; } 

template <class A> std::function<A(_Vec<A>)> head = [](auto x) { auto _1 = [x]() { auto _2 = x; switch (   _2.type) {  case ConsV: {auto _4 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_2.data));auto y = _4._1;auto ys = _4._2;auto _3 = y; return _3;}} }(); return _1;};

template <class A> std::function<_Vec<A>(_Vec<A>)> tail = [](auto x) { auto _5 = [x]() { auto _6 = x; switch (   _6.type) {  case ConsV: {auto _8 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_6.data));auto y = _8._1;auto ys = _8._2;auto _7 = ys; return _7;}} }(); return _5;};

std::function<_List<char>(uint64_t)> natToString = [](auto n) {std::string stringVersion = std::to_string(n);std::function<_List<char>(std::string)> toList = [&toList](std::string s) {if (s.empty()) {return _List<char>::_Nil();}return _List<char>::_Cons(s.at(0), toList(std::string(s).erase(0, 1)));};return toList(stringVersion);};

template <class a,class b> std::function<std::function<_List<b>(_List<a>)>(std::function<b(a)>)> map = [](auto f) { auto _9 = [f](auto xs) { auto _10 = [xs,f]() { auto _11 = xs; switch (   _11.type) {  case Nil: {auto _13 = *(std::static_pointer_cast<_List_Nil<a>>(_11.data));auto _12 = _List<b>::_Nil(); return _12;} case Cons: {auto _15 = *(std::static_pointer_cast<_List_Cons<a>>(_11.data));auto y = _15._1;auto ys = _15._2;auto _18 = y;auto _16 = f(_18);auto _19 = f;auto _20 = ys;auto _17 = map<a,b>(_19)(_20);auto _14 = _List<b>::_Cons(_16,_17); return _14;}} }(); return _10;}; return _9;};

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> plus = [](auto n) {auto _133 = [n](auto m) {return n+m;};return _133;};;
enum _enum_Dec_type {Yes,No};template <class prop> class _Dec_Yes;
template <class prop> class _Dec_No;
template <class prop> class _Dec { public: enum _enum_Dec_type type; std::shared_ptr<void> data;static _Dec<prop> _Yes(prop _1);static _Dec<prop> _No(std::function<_Void(prop)> _1);_Dec<prop>(_enum_Dec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Dec<prop>(const _Dec<prop>& other);
_Dec<prop>() = default;};template <class prop> class _Dec_Yes { public: prop _1;_Dec_Yes (prop _1) {this->_1= _1;};_Dec_Yes (const _Dec_Yes* other) { this->_1= other->_1;} };template <class prop> class _Dec_No { public: std::function<_Void(prop)> _1;_Dec_No (std::function<_Void(prop)> _1) {this->_1= _1;};_Dec_No (const _Dec_No* other) { this->_1= other->_1;} };template <class prop>  inline _Dec<prop> _Dec<prop>::_Yes(prop _1){ return  _Dec<prop> ( Yes, std::make_shared<_Dec_Yes<prop>>(_1)); };template <class prop>  inline _Dec<prop> _Dec<prop>::_No(std::function<_Void(prop)> _1){ return  _Dec<prop> ( No, std::make_shared<_Dec_No<prop>>(_1)); };template <class prop> _Dec<prop>::_Dec(const _Dec<prop>& other) { type = other.type; data = other.data; } 

template <class A,class B> std::function<_TyEq(_TyEq)> f_equal = [](auto pf) { auto _24 = _TyEq::_Refl()
;auto _23 = _24; return _23;};

std::function<std::function<_Void(_TyEq)>(uint64_t)> ZnotS = [](auto n) { auto _25 = [](auto r) { auto _26 = _Void(); return _26;}; return _25;};

template <class A> std::function<_TyEq(_TyEq)> sym = [](auto pf) { auto _28 = _TyEq::_Refl()
;auto _27 = _28; return _27;};

template <class t> std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)> negEqSym = [](auto p) { auto _29 = [p](auto h) { auto _32 = h;auto _31 = sym<t>(_32);auto _30 = p(_31); return _30;}; return _29;};

std::function<uint64_t(uint64_t)> pred = [](auto n) { auto _36 = [n]() {auto _37 = n; if ( !_37 ) {auto _38 = (uint64_t)0;return _38; } else {auto m = _37 - 1;auto _38 = m;return _38;} }(); return _36;};

std::function<_TyEq(_TyEq)> succInjective = [](auto p) { auto _40 = p;auto _39 = f_equal<uint64_t,uint64_t>(_40); return _39;};

std::function<std::function<_Dec<_TyEq>(uint64_t)>(uint64_t)> decEqNat = [](auto a) { auto _46 = [a](auto b) { auto _47 = [a,b]() {auto _48 = a; if ( !_48 ) {auto _49 = [a,b]() {auto _50 = b; if ( !_50 ) {auto _52 = _TyEq::_Refl()
;auto _51 = _Dec<_TyEq>::_Yes(_52);return _51; } else {auto n = _50 - 1;auto _54 = n;auto _53 = ZnotS(_54);auto _51 = _Dec<_TyEq>::_No(_53);return _51;} }();return _49; } else {auto n = _48 - 1;auto _49 = [a,b,n]() {auto _55 = b; if ( !_55 ) {auto _62 = n;auto _58 = ZnotS(_62);auto _57 = negEqSym<uint64_t>(_58);auto _56 = _Dec<_TyEq>::_No(_57);return _56; } else {auto m = _55 - 1;auto _56 = [a,b,n,m]() { auto _64 = n;auto _65 = m;auto _63 = decEqNat(_64)(_65); switch (   _63.type) {  case Yes: {auto _67 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_63.data));auto p = _67._1;auto _69 = p;auto _68 = f_equal<uint64_t,uint64_t>(_69);auto _66 = _Dec<_TyEq>::_Yes(_68); return _66;} case No: {auto _76 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_63.data));auto p = _76._1;auto _77 = [a,b,n,m,p](auto h) { auto _80 = h;auto _79 = succInjective(_80);auto _78 = p(_79); return _78;};auto _75 = _Dec<_TyEq>::_No(_77); return _75;}} }();return _56;} }();return _49;} }(); return _47;}; return _46;};
enum _enum_Elem_type {Here,There};template <class a> class _Elem_Here;
template <class a> class _Elem_There;
template <class a> class _Elem { public: enum _enum_Elem_type type; std::shared_ptr<void> data;static _Elem<a> _Here(a _1, _List<a> _2);static _Elem<a> _There(a _1, a _2, _List<a> _3, _Elem<a> _4);_Elem<a>(_enum_Elem_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Elem<a>(const _Elem<a>& other);
_Elem<a>() = default;};template <class a> class _Elem_Here { public: a _1;_List<a> _2;_Elem_Here (a _1, _List<a> _2) {this->_1= _1;this->_2= _2;};_Elem_Here (const _Elem_Here* other) { this->_1= other->_1;this->_2= other->_2;} };template <class a> class _Elem_There { public: a _1;a _2;_List<a> _3;_Elem<a> _4;_Elem_There (a _1, a _2, _List<a> _3, _Elem<a> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_Elem_There (const _Elem_There* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class a>  inline _Elem<a> _Elem<a>::_Here(a _1, _List<a> _2){ return  _Elem<a> ( Here, std::make_shared<_Elem_Here<a>>(_1, _2)); };template <class a>  inline _Elem<a> _Elem<a>::_There(a _1, a _2, _List<a> _3, _Elem<a> _4){ return  _Elem<a> ( There, std::make_shared<_Elem_There<a>>(_1, _2, _3, _4)); };template <class a> _Elem<a>::_Elem(const _Elem<a>& other) { type = other.type; data = other.data; } 

std::function<std::function<std::function<_Void(_Elem<uint64_t>)>(std::function<_Void(_Elem<uint64_t>)>)>(std::function<_Void(_TyEq)>)> neitherHereNorThere = [](auto xneqy) { auto _83 = [xneqy](auto xninxs) { auto _84 = [xneqy,xninxs](auto p) { auto _85 = [p,xneqy,xninxs]() { auto _86 = p; switch (   _86.type) {  case Here: {auto _88 = *(std::static_pointer_cast<_Elem_Here<uint64_t>>(_86.data));auto a = _88._1;auto as = _88._2;auto _89 = _TyEq::_Refl()
;auto _87 = xneqy(_89); return _87;} case There: {auto _91 = *(std::static_pointer_cast<_Elem_There<uint64_t>>(_86.data));auto b = _91._1;auto a = _91._2;auto as = _91._3;auto prf = _91._4;auto _92 = prf;auto _90 = xninxs(_92); return _90;}} }(); return _85;}; return _84;}; return _83;};

std::function<_Void(_Elem<uint64_t>)> xNotElemOfNil = [](auto p) { auto _93 = [p]() { auto _94 = p; return _Void(); }(); return _93;};

std::function<std::function<_Dec<_Elem<uint64_t>>(_List<uint64_t>)>(uint64_t)> isElem = [](auto x) { auto _95 = [x](auto xs) { auto _96 = [xs,x]() { auto _97 = xs; switch (   _97.type) {  case Nil: {auto _99 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_97.data));auto _100 = xNotElemOfNil;auto _98 = _Dec<_Elem<uint64_t>>::_No(_100); return _98;} case Cons: {auto _103 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_97.data));auto y = _103._1;auto ys = _103._2;auto _102 = [xs,x,y,ys]() { auto _105 = x;auto _106 = y;auto _104 = decEqNat(_105)(_106); switch (   _104.type) {  case Yes: {auto _108 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_104.data));auto p = _108._1;auto _110 = y;auto _111 = ys;auto _109 = _Elem<uint64_t>::_Here(_110,_111);auto _107 = _Dec<_Elem<uint64_t>>::_Yes(_109); return _107;} case No: {auto _113 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_104.data));auto xneqy = _113._1;auto _112 = [xs,x,y,ys,xneqy]() { auto _115 = x;auto _116 = ys;auto _114 = isElem(_115)(_116); switch (   _114.type) {  case Yes: {auto _118 = *(std::static_pointer_cast<_Dec_Yes<_Elem<uint64_t>>>(_114.data));auto xinys = _118._1;auto _120 = y;auto _121 = x;auto _122 = ys;auto _123 = xinys;auto _119 = _Elem<uint64_t>::_There(_120,_121,_122,_123);auto _117 = _Dec<_Elem<uint64_t>>::_Yes(_119); return _117;} case No: {auto _125 = *(std::static_pointer_cast<_Dec_No<_Elem<uint64_t>>>(_114.data));auto xninys = _125._1;auto _127 = xneqy;auto _128 = xninys;auto _126 = neitherHereNorThere(_127)(_128);auto _124 = _Dec<_Elem<uint64_t>>::_No(_126); return _124;}} }(); return _112;}} }(); return _102;}} }(); return _96;}; return _95;};

template <class a,class b> std::function<a(_Tuple<a,b>)> fst = [](auto t) { auto _132 = [t]() { auto _133 = t; switch (   _133.type) {  case MkTuple: {auto _135 = *(std::static_pointer_cast<_Tuple_MkTuple<a,b>>(_133.data));auto t1 = _135._1;auto t2 = _135._2;auto _134 = t1; return _134;}} }(); return _132;};

template <class a,class b> std::function<b(_Tuple<a,b>)> snd = [](auto t) { auto _136 = [t]() { auto _137 = t; switch (   _137.type) {  case MkTuple: {auto _139 = *(std::static_pointer_cast<_Tuple_MkTuple<a,b>>(_137.data));auto t1 = _139._1;auto t2 = _139._2;auto _138 = t2; return _138;}} }(); return _136;};

template <class a> std::function<std::function<_List<a>(_List<a>)>(_List<a>)> append = [](auto xs) { auto _140 = [xs](auto ys) { auto _141 = [xs,ys]() { auto _142 = xs; switch (   _142.type) {  case Nil: {auto _144 = *(std::static_pointer_cast<_List_Nil<a>>(_142.data));auto _143 = ys; return _143;} case Cons: {auto _146 = *(std::static_pointer_cast<_List_Cons<a>>(_142.data));auto x = _146._1;auto xs2 = _146._2;auto _147 = x;auto _149 = xs2;auto _150 = ys;auto _148 = append<a>(_149)(_150);auto _145 = _List<a>::_Cons(_147,_148); return _145;}} }(); return _141;}; return _140;};

template <class A> std::function<std::function<_Vec<A>(_Vec<A>)>(_Vec<A>)> appendVec = [](auto v1) { auto _152 = [v1](auto ys) { auto _153 = [v1,ys]() { auto _154 = v1; switch (   _154.type) {  case ConsV: {auto _156 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_154.data));auto x = _156._1;auto xs = _156._2;auto _157 = x;auto _160 = xs;auto _161 = ys;auto _158 = appendVec<A>(_160)(_161);auto _155 = _Vec<A>::_ConsV(_157,_158); return _155;} case NilV: {auto _166 = *(std::static_pointer_cast<_Vec_NilV<A>>(_154.data));auto _165 = ys; return _165;}} }(); return _153;}; return _152;};

template <class A,class B,class C> std::function<std::function<std::function<_List<C>(_List<B>)>(_List<A>)>(std::function<std::function<C(B)>(A)>)> zipWith = [](auto f) { auto _167 = [f](auto l1) { auto _168 = [l1,f](auto l2) { auto _169 = [l1,l2,f]() { auto _170 = l1; switch (   _170.type) {  case Nil: {auto _172 = *(std::static_pointer_cast<_List_Nil<A>>(_170.data));auto _171 = _List<C>::_Nil(); return _171;} case Cons: {auto _174 = *(std::static_pointer_cast<_List_Cons<A>>(_170.data));auto x = _174._1;auto xs = _174._2;auto _173 = [l1,l2,f,x,xs]() { auto _175 = l2; switch (   _175.type) {  case Nil: {auto _177 = *(std::static_pointer_cast<_List_Nil<B>>(_175.data));auto _176 = _List<C>::_Nil(); return _176;} case Cons: {auto _179 = *(std::static_pointer_cast<_List_Cons<B>>(_175.data));auto y = _179._1;auto ys = _179._2;auto _182 = x;auto _183 = y;auto _180 = f(_182)(_183);auto _184 = f;auto _185 = xs;auto _186 = ys;auto _181 = zipWith<A,B,C>(_184)(_185)(_186);auto _178 = _List<C>::_Cons(_180,_181); return _178;}} }(); return _173;}} }(); return _169;}; return _168;}; return _167;};

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> times = [](auto n) { auto _190 = [n](auto m) { auto _191 = [n,m]() {auto _192 = n; if ( !_192 ) {auto _193 = (uint64_t)0;return _193; } else {auto pred = _192 - 1;auto _194 = m;auto _196 = pred;auto _197 = m;auto _195 = times(_196)(_197);auto _193 = plus(_194)(_195);return _193;} }(); return _191;}; return _190;};

std::function<_Tuple<_List<uint64_t>,_List<_List<uint64_t>>>(_List<_List<uint64_t>>)> split = [](auto ls) { auto _198 = [ls]() { auto _199 = ls; switch (   _199.type) {  case Nil: {auto _201 = *(std::static_pointer_cast<_List_Nil<_List<uint64_t>>>(_199.data));auto _202 = _List<uint64_t>::_Nil();auto _203 = _List<_List<uint64_t>>::_Nil();auto _200 = _Tuple<_List<uint64_t>,_List<_List<uint64_t>>>::_MkTuple(_202,_203); return _200;} case Cons: {auto _205 = *(std::static_pointer_cast<_List_Cons<_List<uint64_t>>>(_199.data));auto y = _205._1;auto xss = _205._2;auto _204 = [ls,y,xss]() { auto _206 = y; switch (   _206.type) {  case Nil: {auto _208 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_206.data));auto _209 = _List<uint64_t>::_Nil();auto _210 = _List<_List<uint64_t>>::_Nil();auto _207 = _Tuple<_List<uint64_t>,_List<_List<uint64_t>>>::_MkTuple(_209,_210); return _207;} case Cons: {auto _212 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_206.data));auto x = _212._1;auto xs = _212._2;auto _211 = [ls,y,xss,x,xs]() { auto _214 = xss;auto _213 = split(_214); switch (   _213.type) {  case MkTuple: {auto _216 = *(std::static_pointer_cast<_Tuple_MkTuple<_List<uint64_t>,_List<_List<uint64_t>>>>(_213.data));auto hd = _216._1;auto tl = _216._2;auto _219 = x;auto _220 = hd;auto _217 = _List<uint64_t>::_Cons(_219,_220);auto _221 = xs;auto _222 = tl;auto _218 = _List<_List<uint64_t>>::_Cons(_221,_222);auto _215 = _Tuple<_List<uint64_t>,_List<_List<uint64_t>>>::_MkTuple(_217,_218); return _215;}} }(); return _211;}} }(); return _204;}} }(); return _198;};

std::function<std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)>(_Tuple<_List<uint64_t>,_List<_List<uint64_t>>>)> tP = [](auto tup) { auto _223 = [tup](auto z) { auto _224 = [tup,z]() { auto _225 = tup; switch (   _225.type) {  case MkTuple: {auto _227 = *(std::static_pointer_cast<_Tuple_MkTuple<_List<uint64_t>,_List<_List<uint64_t>>>>(_225.data));auto a = _227._1;auto b = _227._2;auto _226 = [tup,a,z,b]() { auto _228 = a; switch (   _228.type) {  case Nil: {auto _230 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_228.data));auto _229 = z; return _229;} case Cons: {auto _232 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_228.data));auto g = _232._1;auto gs = _232._2;auto _235 = b;auto _233 = split(_235);auto _236 = z;auto _239 = a;auto _240 = _List<_List<uint64_t>>::_Nil();auto _237 = _List<_List<uint64_t>>::_Cons(_239,_240);auto _234 = append<_List<uint64_t>>(_236)(_237);auto _231 = tP(_233)(_234); return _231;}} }(); return _226;}} }(); return _224;}; return _223;};

std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)> transpose = [](auto m) { auto _244 = m;auto _242 = split(_244);auto _243 = _List<_List<uint64_t>>::_Nil();auto _241 = tP(_242)(_243); return _241;};

std::function<std::function<uint64_t(_List<uint64_t>)>(_List<uint64_t>)> dot = [](auto lA) { auto _245 = [lA](auto lB) { auto _246 = [lA,lB]() { auto _247 = lA; switch (   _247.type) {  case Nil: {auto _249 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_247.data));auto _248 = (uint64_t)0; return _248;} case Cons: {auto _251 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_247.data));auto x = _251._1;auto xs = _251._2;auto _250 = [lA,lB,x,xs]() { auto _252 = lB; switch (   _252.type) {  case Nil: {auto _254 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_252.data));auto _253 = (uint64_t)0; return _253;} case Cons: {auto _256 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_252.data));auto y = _256._1;auto ys = _256._2;auto _259 = x;auto _260 = y;auto _257 = times(_259)(_260);auto _261 = xs;auto _262 = ys;auto _258 = dot(_261)(_262);auto _255 = plus(_257)(_258); return _255;}} }(); return _250;}} }(); return _246;}; return _245;};

std::function<std::function<_List<uint64_t>(_List<_List<uint64_t>>)>(_List<uint64_t>)> rowXcol = [](auto r) { auto _263 = [r](auto l) { auto _264 = [l,r]() { auto _265 = l; switch (   _265.type) {  case Nil: {auto _267 = *(std::static_pointer_cast<_List_Nil<_List<uint64_t>>>(_265.data));auto _266 = _List<uint64_t>::_Nil(); return _266;} case Cons: {auto _269 = *(std::static_pointer_cast<_List_Cons<_List<uint64_t>>>(_265.data));auto c = _269._1;auto cs = _269._2;auto _272 = r;auto _273 = c;auto _270 = dot(_272)(_273);auto _274 = r;auto _275 = cs;auto _271 = rowXcol(_274)(_275);auto _268 = _List<uint64_t>::_Cons(_270,_271); return _268;}} }(); return _264;}; return _263;};

std::function<std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)>(_List<_List<uint64_t>>)> multP = [](auto l1) { auto _276 = [l1](auto b) { auto _277 = [l1,b]() { auto _278 = l1; switch (   _278.type) {  case Nil: {auto _280 = *(std::static_pointer_cast<_List_Nil<_List<uint64_t>>>(_278.data));auto _279 = _List<_List<uint64_t>>::_Nil(); return _279;} case Cons: {auto _282 = *(std::static_pointer_cast<_List_Cons<_List<uint64_t>>>(_278.data));auto a = _282._1;auto as = _282._2;auto _285 = a;auto _286 = b;auto _283 = rowXcol(_285)(_286);auto _287 = as;auto _288 = b;auto _284 = multP(_287)(_288);auto _281 = _List<_List<uint64_t>>::_Cons(_283,_284); return _281;}} }(); return _277;}; return _276;};

std::function<std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)>(_List<_List<uint64_t>>)> multPar = [](auto l1) { auto _289 = [l1](auto b) { auto _291 = [b](auto a) { auto _296 = a;auto _297 = b;auto _295 = rowXcol(_296)(_297); return _295;};auto _292 = l1;auto _290 = map<_List<uint64_t>,_List<uint64_t>>(_291)(_292); return _290;}; return _289;};

std::function<std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)>(_List<_List<uint64_t>>)> multM = [](auto m1) { auto _298 = [m1](auto m2) { auto _300 = m1;auto _302 = m2;auto _301 = transpose(_302);auto _299 = multP(_300)(_301); return _299;}; return _298;};

std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)> multMPar = [](auto m1) { auto _304 = m1;auto _306 = m1;auto _305 = transpose(_306);auto _303 = multPar(_304)(_305); return _303;};

std::function<std::function<_List<_List<uint64_t>>(_List<_List<uint64_t>>)>(_List<_List<uint64_t>>)> add = [](auto l1) { auto _307 = [l1](auto l2) { auto _308 = [l1,l2]() { auto _309 = l1; switch (   _309.type) {  case Nil: {auto _311 = *(std::static_pointer_cast<_List_Nil<_List<uint64_t>>>(_309.data));auto _310 = _List<_List<uint64_t>>::_Nil(); return _310;} case Cons: {auto _313 = *(std::static_pointer_cast<_List_Cons<_List<uint64_t>>>(_309.data));auto xs = _313._1;auto xss = _313._2;auto _312 = [l1,l2,xs,xss]() { auto _314 = l2; switch (   _314.type) {  case Nil: {auto _316 = *(std::static_pointer_cast<_List_Nil<_List<uint64_t>>>(_314.data));auto _315 = _List<_List<uint64_t>>::_Nil(); return _315;} case Cons: {auto _318 = *(std::static_pointer_cast<_List_Cons<_List<uint64_t>>>(_314.data));auto ys = _318._1;auto yss = _318._2;auto _321 = plus;auto _322 = xs;auto _323 = ys;auto _319 = zipWith<uint64_t,uint64_t,uint64_t>(_321)(_322)(_323);auto _327 = xss;auto _328 = yss;auto _320 = add(_327)(_328);auto _317 = _List<_List<uint64_t>>::_Cons(_319,_320); return _317;}} }(); return _312;}} }(); return _308;}; return _307;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> trans = [](auto pf1) { auto _329 = [pf1](auto pf2) { auto _331 = pf1;auto _330 = _331; return _330;}; return _329;};
enum _enum_ElemVec_type {HereV,ThereV};template <class A> class _ElemVec_HereV;
template <class A> class _ElemVec_ThereV;
template <class A> class _ElemVec { public: enum _enum_ElemVec_type type; std::shared_ptr<void> data;static _ElemVec<A> _HereV(_Vec<A> _1);static _ElemVec<A> _ThereV(_Vec<A> _1, A _2, _ElemVec<A> _3);_ElemVec<A>(_enum_ElemVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_ElemVec<A>(const _ElemVec<A>& other);
_ElemVec<A>() = default;};template <class A> class _ElemVec_HereV { public: _Vec<A> _1;_ElemVec_HereV (_Vec<A> _1) {this->_1= _1;};_ElemVec_HereV (const _ElemVec_HereV* other) { this->_1= other->_1;} };template <class A> class _ElemVec_ThereV { public: _Vec<A> _1;A _2;_ElemVec<A> _3;_ElemVec_ThereV (_Vec<A> _1, A _2, _ElemVec<A> _3) {this->_1= _1;this->_2= _2;this->_3= _3;};_ElemVec_ThereV (const _ElemVec_ThereV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;} };template <class A>  inline _ElemVec<A> _ElemVec<A>::_HereV(_Vec<A> _1){ return  _ElemVec<A> ( HereV, std::make_shared<_ElemVec_HereV<A>>(_1)); };template <class A>  inline _ElemVec<A> _ElemVec<A>::_ThereV(_Vec<A> _1, A _2, _ElemVec<A> _3){ return  _ElemVec<A> ( ThereV, std::make_shared<_ElemVec_ThereV<A>>(_1, _2, _3)); };template <class A> _ElemVec<A>::_ElemVec(const _ElemVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Void(_ElemVec<A>)> xNotInNilV = [](auto p) { auto _332 = [p]() { auto _333 = p; return _Void(); }(); return _332;};

std::function<std::function<std::function<_Void(_ElemVec<uint64_t>)>(std::function<_Void(_ElemVec<uint64_t>)>)>(std::function<_Void(_TyEq)>)> neitherHereNorThereVec = [](auto xneqy) { auto _334 = [xneqy](auto xninxs) { auto _335 = [xneqy,xninxs](auto p) { auto _336 = [p,xneqy,xninxs]() { auto _337 = p; switch (   _337.type) {  case HereV: {auto _339 = *(std::static_pointer_cast<_ElemVec_HereV<uint64_t>>(_337.data));auto as = _339._1;auto _340 = _TyEq::_Refl()
;auto _338 = xneqy(_340); return _338;} case ThereV: {auto _342 = *(std::static_pointer_cast<_ElemVec_ThereV<uint64_t>>(_337.data));auto as = _342._1;auto b = _342._2;auto prf = _342._3;auto _343 = prf;auto _341 = xninxs(_343); return _341;}} }(); return _336;}; return _335;}; return _334;};

std::function<std::function<_Dec<_ElemVec<uint64_t>>(_Vec<uint64_t>)>(uint64_t)> isElemVec = [](auto x) { auto _344 = [x](auto xs) { auto _345 = [xs,x]() { auto _346 = xs; switch (   _346.type) {  case NilV: {auto _348 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_346.data));auto _349 = xNotInNilV<uint64_t>;auto _347 = _Dec<_ElemVec<uint64_t>>::_No(_349); return _347;} case ConsV: {auto _354 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_346.data));auto y = _354._1;auto ys = _354._2;auto _353 = [xs,x,y,ys]() { auto _356 = x;auto _357 = y;auto _355 = decEqNat(_356)(_357); switch (   _355.type) {  case Yes: {auto _359 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_355.data));auto pf = _359._1;auto _362 = ys;auto _361 = _ElemVec<uint64_t>::_HereV(_362);auto _360 = _361;auto _358 = _Dec<_ElemVec<uint64_t>>::_Yes(_360); return _358;} case No: {auto _365 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_355.data));auto xneqyPf = _365._1;auto _364 = [xs,x,y,ys,xneqyPf]() { auto _367 = x;auto _368 = ys;auto _366 = isElemVec(_367)(_368); switch (   _366.type) {  case Yes: {auto _371 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_366.data));auto pf = _371._1;auto _373 = ys;auto _374 = x;auto _375 = pf;auto _372 = _ElemVec<uint64_t>::_ThereV(_373,_374,_375);auto _370 = _Dec<_ElemVec<uint64_t>>::_Yes(_372); return _370;} case No: {auto _378 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_366.data));auto xninysPf = _378._1;auto _380 = xneqyPf;auto _381 = xninysPf;auto _379 = neitherHereNorThereVec(_380)(_381);auto _377 = _Dec<_ElemVec<uint64_t>>::_No(_379); return _377;}} }(); return _364;}} }(); return _353;}} }(); return _345;}; return _344;};
enum _enum_Disjoint_type {DNil,DCons};template <class A> class _Disjoint_DNil;
template <class A> class _Disjoint_DCons;
template <class A> class _Disjoint { public: enum _enum_Disjoint_type type; std::shared_ptr<void> data;static _Disjoint<A> _DNil();static _Disjoint<A> _DCons(A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4);_Disjoint<A>(_enum_Disjoint_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Disjoint<A>(const _Disjoint<A>& other);
_Disjoint<A>() = default;};template <class A> class _Disjoint_DNil { public: _Disjoint_DNil () {};_Disjoint_DNil (const _Disjoint_DNil* other) { } };template <class A> class _Disjoint_DCons { public: A _1;_List<A> _2;std::function<_Void(_Elem<A>)> _3;_Disjoint<A> _4;_Disjoint_DCons (A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_Disjoint_DCons (const _Disjoint_DCons* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _Disjoint<A> _Disjoint<A>::_DNil(){ return  _Disjoint<A> ( DNil, std::make_shared<_Disjoint_DNil<A>>()); };template <class A>  inline _Disjoint<A> _Disjoint<A>::_DCons(A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4){ return  _Disjoint<A> ( DCons, std::make_shared<_Disjoint_DCons<A>>(_1, _2, _3, _4)); };template <class A> _Disjoint<A>::_Disjoint(const _Disjoint<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Void(_Elem<A>)> xNotInNil = [](auto p) { auto _386 = [p]() { auto _387 = p; return _Void(); }(); return _386;};

template <class A> std::function<std::function<_Disjoint<A>(_TyEq)>(_List<A>)> lemma_y_empty_disjoint = [](auto a) { auto _388 = [a](auto pf) { auto _389 = [a,pf]() { auto _390 = a; switch (   _390.type) {  case Nil: {auto _392 = *(std::static_pointer_cast<_List_Nil<A>>(_390.data));auto _391 = _Disjoint<A>::_DNil(); return _391;} case Cons: {auto _394 = *(std::static_pointer_cast<_List_Cons<A>>(_390.data));auto x = _394._1;auto xs = _394._2;auto _395 = x;auto _396 = xs;auto _399 = xNotInNil<A>;auto _397 = _399;auto _402 = xs;auto _403 = pf;auto _398 = lemma_y_empty_disjoint<A>(_402)(_403);auto _393 = _Disjoint<A>::_DCons(_395,_396,_397,_398); return _393;}} }(); return _389;}; return _388;};

template <class A> std::function<std::function<_Void(_Disjoint<A>)>(_Elem<A>)> lemma_x_in_b = [](auto xInB) { auto _406 = [xInB](auto pf) { auto _407 = [pf,xInB]() { auto _408 = pf; switch (   _408.type) {  case DCons: {auto _410 = *(std::static_pointer_cast<_Disjoint_DCons<A>>(_408.data));auto i = _410._1;auto is = _410._2;auto pfFori = _410._3;auto others = _410._4;auto _411 = xInB;auto _409 = pfFori(_411); return _409;}} }(); return _407;}; return _406;};

template <class A> std::function<std::function<_Void(_Disjoint<A>)>(std::function<_Void(_Disjoint<A>)>)> lemma_xs_in_b = [](auto pf) { auto _412 = [pf](auto p) { auto _413 = [p,pf]() { auto _414 = p; switch (   _414.type) {  case DCons: {auto _416 = *(std::static_pointer_cast<_Disjoint_DCons<A>>(_414.data));auto i = _416._1;auto is = _416._2;auto pfFori = _416._3;auto others = _416._4;auto _417 = others;auto _415 = pf(_417); return _415;}} }(); return _413;}; return _412;};

std::function<std::function<_Dec<_Disjoint<uint64_t>>(_List<uint64_t>)>(_List<uint64_t>)> decDisjointLists = [](auto a) { auto _418 = [a](auto b) { auto _419 = [a,b]() { auto _420 = a; switch (   _420.type) {  case Nil: {auto _422 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_420.data));auto _423 = _Disjoint<uint64_t>::_DNil();auto _421 = _Dec<_Disjoint<uint64_t>>::_Yes(_423); return _421;} case Cons: {auto _425 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_420.data));auto x = _425._1;auto xs = _425._2;auto _424 = [a,b,xs,x]() { auto _426 = b; switch (   _426.type) {  case Nil: {auto _428 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_426.data));auto _430 = a;auto _431 = _TyEq::_Refl()
;auto _429 = lemma_y_empty_disjoint<uint64_t>(_430)(_431);auto _427 = _Dec<_Disjoint<uint64_t>>::_Yes(_429); return _427;} case Cons: {auto _435 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_426.data));auto y = _435._1;auto ys = _435._2;auto _434 = [a,b,xs,x]() { auto _437 = xs;auto _438 = b;auto _436 = decDisjointLists(_437)(_438); switch (   _436.type) {  case Yes: {auto _440 = *(std::static_pointer_cast<_Dec_Yes<_Disjoint<uint64_t>>>(_436.data));auto pf = _440._1;auto _439 = [a,b,xs,x,pf]() { auto _442 = x;auto _443 = b;auto _441 = isElem(_442)(_443); switch (   _441.type) {  case Yes: {auto _445 = *(std::static_pointer_cast<_Dec_Yes<_Elem<uint64_t>>>(_441.data));auto elemPf = _445._1;auto _447 = elemPf;auto _446 = lemma_x_in_b<uint64_t>(_447);auto _444 = _Dec<_Disjoint<uint64_t>>::_No(_446); return _444;} case No: {auto _454 = *(std::static_pointer_cast<_Dec_No<_Elem<uint64_t>>>(_441.data));auto p = _454._1;auto _456 = x;auto _457 = xs;auto _458 = p;auto _459 = pf;auto _455 = _Disjoint<uint64_t>::_DCons(_456,_457,_458,_459);auto _453 = _Dec<_Disjoint<uint64_t>>::_Yes(_455); return _453;}} }(); return _439;} case No: {auto _461 = *(std::static_pointer_cast<_Dec_No<_Disjoint<uint64_t>>>(_436.data));auto p = _461._1;auto _463 = p;auto _462 = lemma_xs_in_b<uint64_t>(_463);auto _460 = _Dec<_Disjoint<uint64_t>>::_No(_462); return _460;}} }(); return _434;}} }(); return _424;}} }(); return _419;}; return _418;};
enum _enum_DisjointVec_type {DNilV,DConsV};template <class A> class _DisjointVec_DNilV;
template <class A> class _DisjointVec_DConsV;
template <class A> class _DisjointVec { public: enum _enum_DisjointVec_type type; std::shared_ptr<void> data;static _DisjointVec<A> _DNilV();static _DisjointVec<A> _DConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4);_DisjointVec<A>(_enum_DisjointVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_DisjointVec<A>(const _DisjointVec<A>& other);
_DisjointVec<A>() = default;};template <class A> class _DisjointVec_DNilV { public: _DisjointVec_DNilV () {};_DisjointVec_DNilV (const _DisjointVec_DNilV* other) { } };template <class A> class _DisjointVec_DConsV { public: A _1;_Vec<A> _2;std::function<_Void(_ElemVec<A>)> _3;_DisjointVec<A> _4;_DisjointVec_DConsV (A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_DisjointVec_DConsV (const _DisjointVec_DConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _DisjointVec<A> _DisjointVec<A>::_DNilV(){ return  _DisjointVec<A> ( DNilV, std::make_shared<_DisjointVec_DNilV<A>>()); };template <class A>  inline _DisjointVec<A> _DisjointVec<A>::_DConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4){ return  _DisjointVec<A> ( DConsV, std::make_shared<_DisjointVec_DConsV<A>>(_1, _2, _3, _4)); };template <class A> _DisjointVec<A>::_DisjointVec(const _DisjointVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_DisjointVec<A>(_TyEq)>(_Vec<A>)> lemma_y_empty_disjoint_vec = [](auto a) { auto _468 = [a](auto pf) { auto _469 = [a,pf]() { auto _470 = a; switch (   _470.type) {  case NilV: {auto _472 = *(std::static_pointer_cast<_Vec_NilV<A>>(_470.data));auto _471 = _DisjointVec<A>::_DNilV(); return _471;} case ConsV: {auto _474 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_470.data));auto x = _474._1;auto xs = _474._2;auto _475 = x;auto _476 = xs;auto _480 = xNotInNilV<A>;auto _477 = _480;auto _484 = xs;auto _485 = pf;auto _478 = lemma_y_empty_disjoint_vec<A>(_484)(_485);auto _473 = _DisjointVec<A>::_DConsV(_475,_476,_477,_478); return _473;}} }(); return _469;}; return _468;};

template <class A> std::function<std::function<_Void(_DisjointVec<A>)>(_ElemVec<A>)> lemma_x_in_b_vec = [](auto xInB) { auto _489 = [xInB](auto pf) { auto _490 = [pf,xInB]() { auto _491 = pf; switch (   _491.type) {  case DConsV: {auto _493 = *(std::static_pointer_cast<_DisjointVec_DConsV<A>>(_491.data));auto y = _493._1;auto ys = _493._2;auto pfFory = _493._3;auto others = _493._4;auto _494 = xInB;auto _492 = pfFory(_494); return _492;}} }(); return _490;}; return _489;};

template <class A> std::function<std::function<_Void(_DisjointVec<A>)>(std::function<_Void(_DisjointVec<A>)>)> lemma_xs_in_b_vec = [](auto pf) { auto _495 = [pf](auto p) { auto _496 = [p,pf]() { auto _497 = p; switch (   _497.type) {  case DConsV: {auto _499 = *(std::static_pointer_cast<_DisjointVec_DConsV<A>>(_497.data));auto i = _499._1;auto is = _499._2;auto pfFori = _499._3;auto others = _499._4;auto _500 = others;auto _498 = pf(_500); return _498;}} }(); return _496;}; return _495;};

std::function<std::function<_Dec<_DisjointVec<uint64_t>>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decDisjointVecs = [](auto a) { auto _501 = [a](auto b) { auto _502 = [a,b]() { auto _503 = a; switch (   _503.type) {  case NilV: {auto _505 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_503.data));auto _506 = _DisjointVec<uint64_t>::_DNilV();auto _504 = _Dec<_DisjointVec<uint64_t>>::_Yes(_506); return _504;} case ConsV: {auto _508 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_503.data));auto x = _508._1;auto xs = _508._2;auto _507 = [a,b,xs,x]() { auto _509 = b; switch (   _509.type) {  case NilV: {auto _511 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_509.data));auto _513 = a;auto _514 = _TyEq::_Refl()
;auto _512 = lemma_y_empty_disjoint_vec<uint64_t>(_513)(_514);auto _510 = _Dec<_DisjointVec<uint64_t>>::_Yes(_512); return _510;} case ConsV: {auto _519 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_509.data));auto y = _519._1;auto ys = _519._2;auto _518 = [a,b,xs,x]() { auto _521 = xs;auto _522 = b;auto _520 = decDisjointVecs(_521)(_522); switch (   _520.type) {  case Yes: {auto _526 = *(std::static_pointer_cast<_Dec_Yes<_DisjointVec<uint64_t>>>(_520.data));auto pf = _526._1;auto _525 = [a,b,xs,x,pf]() { auto _528 = x;auto _529 = b;auto _527 = isElemVec(_528)(_529); switch (   _527.type) {  case Yes: {auto _532 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_527.data));auto elemPf = _532._1;auto _534 = elemPf;auto _533 = lemma_x_in_b_vec<uint64_t>(_534);auto _531 = _Dec<_DisjointVec<uint64_t>>::_No(_533); return _531;} case No: {auto _543 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_527.data));auto p = _543._1;auto _545 = x;auto _546 = xs;auto _547 = p;auto _548 = pf;auto _544 = _DisjointVec<uint64_t>::_DConsV(_545,_546,_547,_548);auto _542 = _Dec<_DisjointVec<uint64_t>>::_Yes(_544); return _542;}} }(); return _525;} case No: {auto _551 = *(std::static_pointer_cast<_Dec_No<_DisjointVec<uint64_t>>>(_520.data));auto p = _551._1;auto _553 = p;auto _552 = lemma_xs_in_b_vec<uint64_t>(_553);auto _550 = _Dec<_DisjointVec<uint64_t>>::_No(_552); return _550;}} }(); return _518;}} }(); return _507;}} }(); return _502;}; return _501;};

std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjLem = [](auto prf1) { auto _560 = [](auto prf2) { auto _563 = prf2;auto _562 = f_equal<_Vec<uint64_t>,_Vec<uint64_t>>(_563);auto _561 = _562; return _561;}; return _560;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjective = [](auto p1) { auto _569 = [](auto p2) { auto _572 = p2;auto _571 = f_equal<_Vec<A>,_Vec<A>>(_572);auto _570 = _571; return _570;}; return _569;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjectiveTail = [](auto p1) { auto _578 = [](auto p2) { auto _580 = p2;auto _579 = f_equal<_Vec<A>,A>(_580); return _579;}; return _578;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)>(_TyEq)> lemma_x_eq_xs_neq_vec = [](auto prf1) { auto _586 = [prf1](auto p) { auto _587 = [p,prf1](auto prf2) { auto _590 = prf1;auto _591 = prf2;auto _589 = consVInjective<A>(_590)(_591);auto _588 = p(_589); return _588;}; return _587;}; return _586;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(_TyEq)>(std::function<_Void(_TyEq)>)> lemma_x_neq_xs_eq_vec = [](auto p) { auto _598 = [p](auto p2) { auto _599 = [p,p2](auto p3) { auto _602 = p2;auto _603 = p3;auto _601 = consVInjectiveTail<A>(_602)(_603);auto _600 = p(_601); return _600;}; return _599;}; return _598;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)>(std::function<_Void(_TyEq)>)> lemma_x_neq_xs_neq_vec = [](auto p) { auto _610 = [p](auto p2) { auto _611 = [p](auto p3) { auto _614 = p3;auto _613 = f_equal<_Vec<A>,A>(_614);auto _612 = p(_613); return _612;}; return _611;}; return _610;};

std::function<std::function<_Dec<_TyEq>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decEqVec = [](auto a) { auto _620 = [a](auto b) { auto _621 = [a,b]() { auto _622 = a; switch (   _622.type) {  case NilV: {auto _624 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_622.data));auto _623 = [a,b]() { auto _625 = b; switch (   _625.type) {  case NilV: {auto _627 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_625.data));auto _628 = _TyEq::_Refl()
;auto _626 = _Dec<_TyEq>::_Yes(_628); return _626;}} }(); return _623;} case ConsV: {auto _630 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_622.data));auto x = _630._1;auto xs = _630._2;auto _629 = [a,b,x,xs]() { auto _631 = b; switch (   _631.type) {  case ConsV: {auto _633 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_631.data));auto y = _633._1;auto ys = _633._2;auto _632 = [a,b,x,y,xs,ys]() { auto _635 = x;auto _636 = y;auto _634 = decEqNat(_635)(_636); switch (   _634.type) {  case Yes: {auto _638 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_634.data));auto xeqy = _638._1;auto _637 = [a,b,x,y,xs,ys,xeqy]() { auto _640 = xs;auto _641 = ys;auto _639 = decEqVec(_640)(_641); switch (   _639.type) {  case Yes: {auto _644 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_639.data));auto xseqys = _644._1;auto _646 = xeqy;auto _647 = xseqys;auto _645 = consVInjLem(_646)(_647);auto _643 = _Dec<_TyEq>::_Yes(_645); return _643;} case No: {auto _654 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_639.data));auto xsneqys = _654._1;auto _656 = xeqy;auto _657 = xsneqys;auto _655 = lemma_x_eq_xs_neq_vec<uint64_t>(_656)(_657);auto _653 = _Dec<_TyEq>::_No(_655); return _653;}} }(); return _637;} case No: {auto _665 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_634.data));auto xneqy = _665._1;auto _664 = [a,b,x,y,xs,ys,xneqy]() { auto _667 = xs;auto _668 = ys;auto _666 = decEqVec(_667)(_668); switch (   _666.type) {  case Yes: {auto _671 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_666.data));auto xseqys = _671._1;auto _673 = xneqy;auto _674 = xseqys;auto _672 = lemma_x_neq_xs_eq_vec<uint64_t>(_673)(_674);auto _670 = _Dec<_TyEq>::_No(_672); return _670;} case No: {auto _682 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_666.data));auto xsneqys = _682._1;auto _684 = xneqy;auto _685 = xsneqys;auto _683 = lemma_x_neq_xs_neq_vec<uint64_t>(_684)(_685);auto _681 = _Dec<_TyEq>::_No(_683); return _681;}} }(); return _664;}} }(); return _632;}} }(); return _629;}} }(); return _621;}; return _620;};
enum _enum_UniqueVec_type {UNilV,UConsV};template <class A> class _UniqueVec_UNilV;
template <class A> class _UniqueVec_UConsV;
template <class A> class _UniqueVec { public: enum _enum_UniqueVec_type type; std::shared_ptr<void> data;static _UniqueVec<A> _UNilV();static _UniqueVec<A> _UConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4);_UniqueVec<A>(_enum_UniqueVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_UniqueVec<A>(const _UniqueVec<A>& other);
_UniqueVec<A>() = default;};template <class A> class _UniqueVec_UNilV { public: _UniqueVec_UNilV () {};_UniqueVec_UNilV (const _UniqueVec_UNilV* other) { } };template <class A> class _UniqueVec_UConsV { public: A _1;_Vec<A> _2;std::function<_Void(_ElemVec<A>)> _3;_UniqueVec<A> _4;_UniqueVec_UConsV (A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_UniqueVec_UConsV (const _UniqueVec_UConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _UniqueVec<A> _UniqueVec<A>::_UNilV(){ return  _UniqueVec<A> ( UNilV, std::make_shared<_UniqueVec_UNilV<A>>()); };template <class A>  inline _UniqueVec<A> _UniqueVec<A>::_UConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4){ return  _UniqueVec<A> ( UConsV, std::make_shared<_UniqueVec_UConsV<A>>(_1, _2, _3, _4)); };template <class A> _UniqueVec<A>::_UniqueVec(const _UniqueVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_Void(_UniqueVec<A>)>(_ElemVec<A>)> lemma_x_in_xs_not_unique = [](auto pf) { auto _692 = [pf](auto p) { auto _693 = [p,pf]() { auto _694 = p; switch (   _694.type) {  case UConsV: {auto _696 = *(std::static_pointer_cast<_UniqueVec_UConsV<A>>(_694.data));auto x = _696._1;auto xs = _696._2;auto xNInXs = _696._3;auto others = _696._4;auto _697 = pf;auto _695 = xNInXs(_697); return _695;}} }(); return _693;}; return _692;};

template <class A> std::function<std::function<_Void(_UniqueVec<A>)>(std::function<_Void(_UniqueVec<A>)>)> lemma_xs_not_unique = [](auto pf) { auto _698 = [pf](auto p) { auto _699 = [p,pf]() { auto _700 = p; switch (   _700.type) {  case UConsV: {auto _702 = *(std::static_pointer_cast<_UniqueVec_UConsV<A>>(_700.data));auto x = _702._1;auto xs = _702._2;auto xNInXs = _702._3;auto others = _702._4;auto _703 = others;auto _701 = pf(_703); return _701;}} }(); return _699;}; return _698;};

std::function<_Dec<_UniqueVec<uint64_t>>(_Vec<uint64_t>)> decUniqueVec = [](auto v) { auto _704 = [v]() { auto _705 = v; switch (   _705.type) {  case NilV: {auto _707 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_705.data));auto _708 = _UniqueVec<uint64_t>::_UNilV();auto _706 = _Dec<_UniqueVec<uint64_t>>::_Yes(_708); return _706;} case ConsV: {auto _710 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_705.data));auto x = _710._1;auto xs = _710._2;auto _709 = [v,x,xs]() { auto _712 = x;auto _713 = xs;auto _711 = isElemVec(_712)(_713); switch (   _711.type) {  case Yes: {auto _716 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_711.data));auto xInXs = _716._1;auto _718 = xInXs;auto _717 = lemma_x_in_xs_not_unique<uint64_t>(_718);auto _715 = _Dec<_UniqueVec<uint64_t>>::_No(_717); return _715;} case No: {auto _724 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_711.data));auto xNInXs = _724._1;auto _723 = [v,x,xs,xNInXs]() { auto _726 = xs;auto _725 = decUniqueVec(_726); switch (   _725.type) {  case Yes: {auto _729 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_725.data));auto xsU = _729._1;auto _731 = x;auto _732 = xs;auto _733 = xNInXs;auto _734 = xsU;auto _730 = _UniqueVec<uint64_t>::_UConsV(_731,_732,_733,_734);auto _728 = _Dec<_UniqueVec<uint64_t>>::_Yes(_730); return _728;} case No: {auto _737 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_725.data));auto xsNU = _737._1;auto _739 = xsNU;auto _738 = lemma_xs_not_unique<uint64_t>(_739);auto _736 = _Dec<_UniqueVec<uint64_t>>::_No(_738); return _736;}} }(); return _723;}} }(); return _709;}} }(); return _704;};
enum _enum_SubsetVec_type {SNilV1,SNilV2,SConsV};template <class A> class _SubsetVec_SNilV1;
template <class A> class _SubsetVec_SNilV2;
template <class A> class _SubsetVec_SConsV;
template <class A> class _SubsetVec { public: enum _enum_SubsetVec_type type; std::shared_ptr<void> data;static _SubsetVec<A> _SNilV1();static _SubsetVec<A> _SNilV2();static _SubsetVec<A> _SConsV(A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4);_SubsetVec<A>(_enum_SubsetVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_SubsetVec<A>(const _SubsetVec<A>& other);
_SubsetVec<A>() = default;};template <class A> class _SubsetVec_SNilV1 { public: _SubsetVec_SNilV1 () {};_SubsetVec_SNilV1 (const _SubsetVec_SNilV1* other) { } };template <class A> class _SubsetVec_SNilV2 { public: _SubsetVec_SNilV2 () {};_SubsetVec_SNilV2 (const _SubsetVec_SNilV2* other) { } };template <class A> class _SubsetVec_SConsV { public: A _1;_Vec<A> _2;_ElemVec<A> _3;_SubsetVec<A> _4;_SubsetVec_SConsV (A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_SubsetVec_SConsV (const _SubsetVec_SConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SNilV1(){ return  _SubsetVec<A> ( SNilV1, std::make_shared<_SubsetVec_SNilV1<A>>()); };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SNilV2(){ return  _SubsetVec<A> ( SNilV2, std::make_shared<_SubsetVec_SNilV2<A>>()); };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SConsV(A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4){ return  _SubsetVec<A> ( SConsV, std::make_shared<_SubsetVec_SConsV<A>>(_1, _2, _3, _4)); };template <class A> _SubsetVec<A>::_SubsetVec(const _SubsetVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_Void(_SubsetVec<A>)>(std::function<_Void(_ElemVec<A>)>)> lemma_x_not_in_b_vec = [](auto pfXNotInb) { auto _744 = [pfXNotInb](auto pf) { auto _745 = [pf,pfXNotInb]() { auto _746 = pf; switch (   _746.type) {  case SConsV: {auto _748 = *(std::static_pointer_cast<_SubsetVec_SConsV<A>>(_746.data));auto a = _748._1;auto as = _748._2;auto pfFora = _748._3;auto others = _748._4;auto _749 = pfFora;auto _747 = pfXNotInb(_749); return _747;}} }(); return _745;}; return _744;};

template <class A> std::function<std::function<_Void(_SubsetVec<A>)>(std::function<_Void(_SubsetVec<A>)>)> lemma_xs_not_subset_b_vec = [](auto xsNotSubsetPf) { auto _750 = [xsNotSubsetPf](auto p) { auto _751 = [p,xsNotSubsetPf]() { auto _752 = p; switch (   _752.type) {  case SConsV: {auto _754 = *(std::static_pointer_cast<_SubsetVec_SConsV<A>>(_752.data));auto a = _754._1;auto as = _754._2;auto pfFora = _754._3;auto others = _754._4;auto _755 = others;auto _753 = xsNotSubsetPf(_755); return _753;}} }(); return _751;}; return _750;};

std::function<std::function<_Dec<_SubsetVec<uint64_t>>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decSubsetVecs = [](auto a) { auto _756 = [a](auto b) { auto _757 = [a,b]() { auto _758 = a; switch (   _758.type) {  case NilV: {auto _760 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_758.data));auto _761 = _SubsetVec<uint64_t>::_SNilV1();auto _759 = _Dec<_SubsetVec<uint64_t>>::_Yes(_761); return _759;} case ConsV: {auto _763 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_758.data));auto x = _763._1;auto xs = _763._2;auto _762 = [a,b,xs,x]() { auto _764 = b; switch (   _764.type) {  case NilV: {auto _766 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_764.data));auto _767 = _SubsetVec<uint64_t>::_SNilV2();auto _765 = _Dec<_SubsetVec<uint64_t>>::_Yes(_767); return _765;} case ConsV: {auto _769 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_764.data));auto y = _769._1;auto ys = _769._2;auto _768 = [a,b,xs,x]() { auto _771 = xs;auto _772 = b;auto _770 = decSubsetVecs(_771)(_772); switch (   _770.type) {  case Yes: {auto _776 = *(std::static_pointer_cast<_Dec_Yes<_SubsetVec<uint64_t>>>(_770.data));auto pf = _776._1;auto _775 = [a,b,xs,x,pf]() { auto _778 = x;auto _779 = b;auto _777 = isElemVec(_778)(_779); switch (   _777.type) {  case Yes: {auto _782 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_777.data));auto elemPf = _782._1;auto _784 = x;auto _785 = xs;auto _786 = elemPf;auto _787 = pf;auto _783 = _SubsetVec<uint64_t>::_SConsV(_784,_785,_786,_787);auto _781 = _Dec<_SubsetVec<uint64_t>>::_Yes(_783); return _781;} case No: {auto _790 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_777.data));auto p = _790._1;auto _792 = p;auto _791 = lemma_x_not_in_b_vec<uint64_t>(_792);auto _789 = _Dec<_SubsetVec<uint64_t>>::_No(_791); return _789;}} }(); return _775;} case No: {auto _801 = *(std::static_pointer_cast<_Dec_No<_SubsetVec<uint64_t>>>(_770.data));auto p = _801._1;auto _803 = p;auto _802 = lemma_xs_not_subset_b_vec<uint64_t>(_803);auto _800 = _Dec<_SubsetVec<uint64_t>>::_No(_802); return _800;}} }(); return _768;}} }(); return _762;}} }(); return _757;}; return _756;};
enum _enum_IO_type {MkIO};template <class A> class _IO_MkIO;
template <class A> class _IO { public: enum _enum_IO_type type; std::shared_ptr<void> data;static _IO<A> _MkIO(A _1);_IO<A>(_enum_IO_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_IO<A>(const _IO<A>& other);
_IO<A>() = default;};template <class A> class _IO_MkIO { public: A _1;_IO_MkIO (A _1) {this->_1= _1;};_IO_MkIO (const _IO_MkIO* other) { this->_1= other->_1;} };template <class A>  inline _IO<A> _IO<A>::_MkIO(A _1){ return  _IO<A> ( MkIO, std::make_shared<_IO_MkIO<A>>(_1)); };template <class A> _IO<A>::_IO(const _IO<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_IO<A>(A)> returnIO = [](auto a) { auto _812 = a;auto _811 = _IO<A>::_MkIO(_812); return _811;};

template <class A,class B> std::function<std::function<_IO<B>(std::function<_IO<B>(A)>)>(_IO<A>)> bindEq = [](auto a) { auto _813 = [a](auto f) { auto _814 = [a,f]() { auto _815 = a; switch (   _815.type) {  case MkIO: {auto _817 = *(std::static_pointer_cast<_IO_MkIO<A>>(_815.data));auto inner = _817._1;auto _818 = inner;auto _816 = f(_818); return _816;}} }(); return _814;}; return _813;};

template <class A,class B> std::function<std::function<_IO<B>(_IO<B>)>(_IO<A>)> bind = [](auto a) { auto _819 = [a](auto b) { auto _821 = a;auto _822 = [a,b](auto c) { auto _825 = b; return _825;};auto _820 = bindEq<A,B>(_821)(_822); return _820;}; return _819;};

std::function<_IO<_Unit>(_List<char>)> print = [](auto l) {auto _653 = [l]() {auto _654 = l;switch (_654.type) {case Nil: {std::cout << "\n" << std::flush;return returnIO<_Unit>(_Unit::_unit());}case Cons: {auto _660 = *(std::static_pointer_cast<_List_Cons<char>>(_654.data));auto c = _660._1;auto cs = _660._2;std::cout << c;return print(cs);}}}();return _653;};

std::function<_IO<_Unit>(_List<_List<char>>)> printList = [](auto l) { auto _826 = [l]() { auto _827 = l; switch (   _827.type) {  case Nil: {auto _829 = *(std::static_pointer_cast<_List_Nil<_List<char>>>(_827.data));auto _830 = _Unit::_unit();auto _828 = returnIO<_Unit>(_830); return _828;} case Cons: {auto _833 = *(std::static_pointer_cast<_List_Cons<_List<char>>>(_827.data));auto x = _833._1;auto xs = _833._2;auto _838 = x;auto _834 = print(_838);auto _839 = xs;auto _835 = printList(_839);auto _832 = bind<_Unit,_Unit>(_834)(_835); return _832;}} }(); return _826;};
enum _enum_Channel_type {MkChannel};template <class A> class _Channel_MkChannel;
template <class A> class _Channel { public: enum _enum_Channel_type type; std::shared_ptr<void> data;static _Channel<A> _MkChannel(uint64_t _1);_Channel<A>(_enum_Channel_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Channel<A>(const _Channel<A>& other);
_Channel<A>() = default;};template <class A> class _Channel_MkChannel { public: uint64_t _1;_Channel_MkChannel (uint64_t _1) {this->_1= _1;};_Channel_MkChannel (const _Channel_MkChannel* other) { this->_1= other->_1;} };template <class A>  inline _Channel<A> _Channel<A>::_MkChannel(uint64_t _1){ return  _Channel<A> ( MkChannel, std::make_shared<_Channel_MkChannel<A>>(_1)); };template <class A> _Channel<A>::_Channel(const _Channel<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Bool(uint64_t)> prim_create_channel = [](auto id) {LockingCQueue<_Maybe<A>>* q = new LockingCQueue<_Maybe<A>>();addChannel(id, q);return _Bool::_True();};

template <class A> std::function<std::function<std::function<_IO<_Unit>(_Channel<A>)>(_Maybe<A>)>(uint64_t)> channelEnqueue = [](auto id) {auto _629 = [id](auto x) {auto _630 = [id, x](auto ch) {LockingCQueue<_Maybe<A>>* queue = (LockingCQueue<_Maybe<A>>*)getChannel(id);queue->enqueue(x);auto _632 = _Unit::_unit();auto _631 = returnIO<_Unit>(_632);return _631;};return _630;};return _629;};;

template <class A> std::function<std::function<_IO<_Maybe<A>>(_Channel<A>)>(uint64_t)> channelDequeue = [](auto id) {auto _630 = [id](auto ch) {LockingCQueue<_Maybe<A>>* queue = (LockingCQueue<_Maybe<A>>*)getChannel(id);auto result = queue->dequeue();auto _631 = returnIO<_Maybe<A>>(result);return _631;};return _630;};;

_IO<_Unit> end = []() {auto _631 = _Unit::_unit();auto _630 = returnIO<_Unit>(_631);return _630;}();

template <class A> std::function<std::function<std::function<_IO<_Unit>(_Channel<A>)>(_Maybe<A>)>(uint64_t)> send = [](auto id) { auto _840 = [id](auto x) { auto _841 = [id,x](auto ch) { auto _843 = id;auto _844 = x;auto _845 = ch;auto _842 = channelEnqueue<A>(_843)(_844)(_845); return _842;}; return _841;}; return _840;};

template <class A> std::function<std::function<_IO<_Maybe<A>>(_Channel<A>)>(uint64_t)> receive = [](auto id) { auto _847 = [id](auto ch) { auto _849 = id;auto _850 = ch;auto _848 = channelDequeue<A>(_849)(_850); return _848;}; return _847;};

template <class A> std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)> link = [](auto id) { auto _852 = [id](auto idSet) { auto _853 = [id,idSet](auto pf) { auto _854 = [id,idSet]() { auto _856 = id;auto _855 = prim_create_channel<A>(_856); switch (   _855.type) {  case True: {auto _859 = *(std::static_pointer_cast<_Bool_True>(_855.data));auto _863 = id;auto _867 = id;auto _865 = _Channel<A>::_MkChannel(_867);auto _870 = id;auto _871 = idSet;auto _868 = _Vec<uint64_t>::_ConsV(_870,_871);auto _873 = _TyEq::_Refl()
;auto _874 = _TyEq::_Refl()
;auto _869 = _Sigma<_TyEq,_TyEq>::_Prod(_873,_874);auto _866 = _Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>::_Prod(_868,_869);auto _864 = _Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>::_Prod(_865,_866);auto _862 = _Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>::_Prod(_863,_864);auto _860 = _Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>::_Just(_862);auto _858 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_860); return _858;} case False: {auto _876 = *(std::static_pointer_cast<_Bool_False>(_855.data));auto _877 = _Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>::_Nothing();auto _875 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_877); return _875;}} }(); return _854;}; return _853;}; return _852;};

std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)> spawn = [](auto pid) { auto _879 = [pid](auto n) { auto _880 = [pid](auto pidSet) { auto _881 = [pid,pidSet](auto pf) { auto _886 = pid;auto _890 = pid;auto _891 = pidSet;auto _888 = _Vec<uint64_t>::_ConsV(_890,_891);auto _893 = _TyEq::_Refl()
;auto _894 = _TyEq::_Refl()
;auto _889 = _Sigma<_TyEq,_TyEq>::_Prod(_893,_894);auto _887 = _Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>::_Prod(_888,_889);auto _885 = _Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>::_Prod(_886,_887);auto _883 = _Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>::_Just(_885);auto _882 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_883); return _882;}; return _881;}; return _880;}; return _879;};

std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_IO<_Unit>)>(_ElemVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)> run = [](auto pid) { auto _895 = [](auto n) { auto _896 = [](auto pidSet) { auto _897 = [pidSet](auto pf) { auto _898 = [pidSet](auto process) { auto _903 = pidSet;auto _904 = _TyEq::_Refl()
;auto _902 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_903,_904);auto _900 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_902);auto _899 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_900); return _899;}; return _898;}; return _897;}; return _896;}; return _895;};

std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(std::function<void(void)>)>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)> spawnAndRun = [](auto pid) {auto _719 = [pid](auto pidSet) {auto _720 = [pid, pidSet](auto pf) {auto _721 = [pid, pidSet](auto proc) {// Spawning the thread
try {std::thread* t = new std::thread([proc](){proc();});addThread(pid, t);} catch (std::system_error) {return returnIO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>::_Nothing());}auto _726 = pid;auto _730 = pid;auto _731 = pidSet;auto _728 = _Vec<uint64_t>::_ConsV(_730, _731);auto _733 = _TyEq::_Refl();auto _734 = _TyEq::_Refl();auto _729 = _Sigma<_TyEq, _TyEq>::_Prod(_733, _734);auto _727 =_Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>::_Prod(_728, _729);auto _725 =_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>::_Prod(_726, _727);auto _723 =_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>::_Just(_725);auto _722 = returnIO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(_723);return _722;};return _721;};return _720;};return _719;};

std::function<_IO<uint64_t>(uint64_t)> getTime = [](auto i) {return returnIO<uint64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());};
enum _enum_Farm_type {MkFarm};template <class A> class _Farm_MkFarm;
template <class A> class _Farm { public: enum _enum_Farm_type type; std::shared_ptr<void> data;static _Farm<A> _MkFarm(uint64_t _1, std::function<A(A)> _2);_Farm<A>(_enum_Farm_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Farm<A>(const _Farm<A>& other);
_Farm<A>() = default;};template <class A> class _Farm_MkFarm { public: uint64_t _1;std::function<A(A)> _2;_Farm_MkFarm (uint64_t _1, std::function<A(A)> _2) {this->_1= _1;this->_2= _2;};_Farm_MkFarm (const _Farm_MkFarm* other) { this->_1= other->_1;this->_2= other->_2;} };template <class A>  inline _Farm<A> _Farm<A>::_MkFarm(uint64_t _1, std::function<A(A)> _2){ return  _Farm<A> ( MkFarm, std::make_shared<_Farm_MkFarm<A>>(_1, _2)); };template <class A> _Farm<A>::_Farm(const _Farm<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<std::function<_IO<_Unit>(_List<A>)>(_Channel<A>)>(uint64_t)> producerWrapper = [](auto id) { auto _905 = [id](auto ch) { auto _906 = [id,ch](auto list) { auto _907 = [list,id,ch]() { auto _908 = list; switch (   _908.type) {  case Nil: {auto _910 = *(std::static_pointer_cast<_List_Nil<A>>(_908.data));auto _915 = id;auto _916 = _Maybe<A>::_Nothing();auto _917 = ch;auto _911 = send<A>(_915)(_916)(_917);auto _912 = end;auto _909 = bind<_Unit,_Unit>(_911)(_912); return _909;} case Cons: {auto _920 = *(std::static_pointer_cast<_List_Cons<A>>(_908.data));auto x = _920._1;auto xs = _920._2;auto _925 = id;auto _929 = x;auto _926 = _Maybe<A>::_Just(_929);auto _927 = ch;auto _921 = send<A>(_925)(_926)(_927);auto _930 = id;auto _931 = ch;auto _932 = xs;auto _922 = producerWrapper<A>(_930)(_931)(_932);auto _919 = bind<_Unit,_Unit>(_921)(_922); return _919;}} }(); return _907;}; return _906;}; return _905;};

template <class A> std::function<_IO<_Unit>(_Vec<_Sigma<uint64_t,_Channel<A>>>)> propgateTermination = [](auto chs) { auto _934 = [chs]() { auto _935 = chs; switch (   _935.type) {  case NilV: {auto _937 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_935.data));auto _936 = end; return _936;} case ConsV: {auto _939 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_935.data));auto ch = _939._1;auto restChs = _939._2;auto _938 = [chs,ch,restChs]() { auto _940 = ch; switch (   _940.type) {  case Prod: {auto _942 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_940.data));auto chid = _942._1;auto channel = _942._2;auto _947 = chid;auto _948 = _Maybe<A>::_Nothing();auto _949 = channel;auto _943 = send<A>(_947)(_948)(_949);auto _951 = restChs;auto _944 = propgateTermination<A>(_951);auto _941 = bind<_Unit,_Unit>(_943)(_944); return _941;}} }(); return _938;}} }(); return _934;};

template <class A> std::function<std::function<std::function<_IO<_Unit>(_List<A>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)> farmProducerWrapper = [](auto allChs) { auto _954 = [allChs](auto chs) { auto _955 = [allChs,chs](auto list) { auto _956 = [list,allChs,chs]() { auto _957 = list; switch (   _957.type) {  case Nil: {auto _959 = *(std::static_pointer_cast<_List_Nil<A>>(_957.data));auto _960 = allChs;auto _958 = propgateTermination<A>(_960); return _958;} case Cons: {auto _964 = *(std::static_pointer_cast<_List_Cons<A>>(_957.data));auto x = _964._1;auto xs = _964._2;auto _963 = [list,allChs,chs,x,xs]() { auto _965 = chs; switch (   _965.type) {  case NilV: {auto _967 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_965.data));auto _968 = allChs;auto _969 = allChs;auto _970 = list;auto _966 = farmProducerWrapper<A>(_968)(_969)(_970); return _966;} case ConsV: {auto _975 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_965.data));auto ch = _975._1;auto restChs = _975._2;auto _974 = [list,allChs,chs,ch,x,restChs,xs]() { auto _976 = ch; switch (   _976.type) {  case Prod: {auto _978 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_976.data));auto chid = _978._1;auto channel = _978._2;auto _983 = chid;auto _987 = x;auto _984 = _Maybe<A>::_Just(_987);auto _985 = channel;auto _979 = send<A>(_983)(_984)(_985);auto _988 = allChs;auto _989 = restChs;auto _990 = xs;auto _980 = farmProducerWrapper<A>(_988)(_989)(_990);auto _977 = bind<_Unit,_Unit>(_979)(_980); return _977;}} }(); return _974;}} }(); return _963;}} }(); return _956;}; return _955;}; return _954;};

template <class A> std::function<std::function<std::function<std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_Channel<A>)>(_Channel<A>)>(uint64_t)>(uint64_t)> workerWrapper = [](auto receiveId) { auto _994 = [receiveId](auto sendId) { auto _995 = [receiveId,sendId](auto receiveChannel) { auto _996 = [receiveId,receiveChannel,sendId](auto sendChannel) { auto _997 = [receiveId,receiveChannel,sendId,sendChannel](auto f) { auto _1003 = receiveId;auto _1004 = receiveChannel;auto _999 = receive<A>(_1003)(_1004);auto _1000 = [receiveId,receiveChannel,sendId,sendChannel,f](auto mx) { auto _1006 = [receiveId,receiveChannel,mx,sendId,sendChannel,f]() { auto _1007 = mx; switch (   _1007.type) {  case Nothing: {auto _1009 = *(std::static_pointer_cast<_Maybe_Nothing<A>>(_1007.data));auto _1014 = sendId;auto _1015 = _Maybe<A>::_Nothing();auto _1016 = sendChannel;auto _1010 = send<A>(_1014)(_1015)(_1016);auto _1011 = end;auto _1008 = bind<_Unit,_Unit>(_1010)(_1011); return _1008;} case Just: {auto _1019 = *(std::static_pointer_cast<_Maybe_Just<A>>(_1007.data));auto x = _1019._1;auto _1024 = sendId;auto _1029 = x;auto _1028 = f(_1029);auto _1025 = _Maybe<A>::_Just(_1028);auto _1026 = sendChannel;auto _1020 = send<A>(_1024)(_1025)(_1026);auto _1030 = receiveId;auto _1031 = sendId;auto _1032 = receiveChannel;auto _1033 = sendChannel;auto _1034 = f;auto _1021 = workerWrapper<A>(_1030)(_1031)(_1032)(_1033)(_1034);auto _1018 = bind<_Unit,_Unit>(_1020)(_1021); return _1018;}} }(); return _1006;};auto _998 = bindEq<_Maybe<A>,_Unit>(_999)(_1000); return _998;}; return _997;}; return _996;}; return _995;}; return _994;};

template <class A> std::function<std::function<std::function<_IO<_List<A>>(uint64_t)>(_Channel<A>)>(uint64_t)> farmConsumerWrapper = [](auto chid) { auto _1036 = [chid](auto ch) { auto _1037 = [chid,ch](auto numLeft) { auto _1038 = [numLeft,chid,ch]() {auto _1039 = numLeft; if ( !_1039 ) {auto _1041 = _List<A>::_Nil();auto _1040 = returnIO<_List<A>>(_1041);return _1040; } else {auto n = _1039 - 1;auto _1047 = chid;auto _1048 = ch;auto _1043 = receive<A>(_1047)(_1048);auto _1044 = [numLeft,chid,ch,n](auto mx) { auto _1050 = [numLeft,chid,ch,mx,n]() { auto _1051 = mx; switch (   _1051.type) {  case Nothing: {auto _1053 = *(std::static_pointer_cast<_Maybe_Nothing<A>>(_1051.data));auto _1054 = chid;auto _1055 = ch;auto _1056 = n;auto _1052 = farmConsumerWrapper<A>(_1054)(_1055)(_1056); return _1052;} case Just: {auto _1059 = *(std::static_pointer_cast<_Maybe_Just<A>>(_1051.data));auto x = _1059._1;auto _1064 = chid;auto _1065 = ch;auto _1066 = numLeft;auto _1060 = farmConsumerWrapper<A>(_1064)(_1065)(_1066);auto _1061 = [numLeft,chid,ch,mx,n,x](auto res) { auto _1071 = x;auto _1072 = res;auto _1069 = _List<A>::_Cons(_1071,_1072);auto _1068 = returnIO<_List<A>>(_1069); return _1068;};auto _1058 = bindEq<_List<A>,_List<A>>(_1060)(_1061); return _1058;}} }(); return _1050;};auto _1040 = bindEq<_Maybe<A>,_List<A>>(_1043)(_1044);return _1040;} }(); return _1038;}; return _1037;}; return _1036;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(std::function<A(A)>)>(_Sigma<uint64_t,_Channel<A>>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> spawnWorkersFarm = [](auto n) { auto _1073 = [n](auto pidSet) { auto _1074 = [pidSet,n](auto nDash) { auto _1075 = [pidSet,n,nDash](auto pids) { auto _1076 = [pids,pidSet,n,nDash](auto pidPf) { auto _1077 = [pids,pidSet,pidPf,n,nDash](auto chs) { auto _1078 = [pids,pidSet,pidPf,chs,n,nDash](auto consumerCh) { auto _1079 = [consumerCh,pids,pidSet,pidPf,chs,n,nDash](auto f) { auto _1080 = [consumerCh,pids,pidSet,pidPf,chs,f,n,nDash]() { auto _1081 = consumerCh; switch (   _1081.type) {  case Prod: {auto _1083 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1081.data));auto consumerChid = _1083._1;auto consumerChannel = _1083._2;auto _1082 = [consumerCh,pids,pidSet,pidPf,chs,consumerChid,consumerChannel,f,n,nDash]() { auto _1084 = pids; switch (   _1084.type) {  case NilV: {auto _1086 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1084.data));auto _1090 = pidSet;auto _1091 = _TyEq::_Refl()
;auto _1089 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1090,_1091);auto _1087 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_1089);auto _1085 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1087); return _1085;} case ConsV: {auto _1093 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1084.data));auto x = _1093._1;auto xs = _1093._2;auto _1092 = [consumerCh,pids,pidSet,pidPf,chs,consumerChid,consumerChannel,f,n,nDash,xs]() { auto _1094 = pidPf; switch (   _1094.type) {  case UConsV: {auto _1096 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1094.data));auto y = _1096._1;auto ys = _1096._2;auto pf = _1096._3;auto restPf = _1096._4;auto _1095 = [consumerCh,pids,pidSet,pidPf,chs,y,ys,pf,consumerChid,consumerChannel,f,n,nDash,xs,restPf]() { auto _1097 = chs; switch (   _1097.type) {  case ConsV: {auto _1099 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_1097.data));auto curCh = _1099._1;auto restChs = _1099._2;auto _1098 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,consumerChid,consumerChannel,f,n,nDash,xs,restPf,restChs]() { auto _1100 = curCh; switch (   _1100.type) {  case Prod: {auto _1102 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1100.data));auto currChid = _1102._1;auto currChannel = _1102._2;auto _1107 = y;auto _1108 = ys;auto _1109 = pf;auto _1103 = spawnAndRun(_1107)(_1108)(_1109)([consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f](){auto _1112 = currChid;auto _1113 = consumerChid;auto _1114 = currChannel;auto _1115 = consumerChannel;auto _1116 = f;auto _1110 = workerWrapper<A>(_1112)(_1113)(_1114)(_1115)(_1116);});auto _1104 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,n,nDash,xs,restPf,restChs](auto mres) { auto _1118 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs]() { auto _1119 = mres; switch (   _1119.type) {  case Nothing: {auto _1121 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1119.data));auto _1122 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Nothing();auto _1120 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1122); return _1120;} case Just: {auto _1125 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1119.data));auto res = _1125._1;auto _1130 = n;auto _1131 = pidSet;auto _1139 = nDash;auto _1132 = pred(_1139);auto _1133 = xs;auto _1134 = restPf;auto _1135 = restChs;auto _1136 = consumerCh;auto _1137 = f;auto _1126 = spawnWorkersFarm<A>(_1130)(_1131)(_1132)(_1133)(_1134)(_1135)(_1136)(_1137);auto _1127 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs](auto mress) { auto _1140 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs,mress]() { auto _1141 = mress; switch (   _1141.type) {  case Nothing: {auto _1143 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1141.data));auto _1144 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Nothing();auto _1142 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1144); return _1142;} case Just: {auto _1147 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1141.data));auto res = _1147._1;auto _1146 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs,mress,res]() { auto _1148 = res; switch (   _1148.type) {  case Prod: {auto _1150 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1148.data));auto newPidSet = _1150._1;auto pfNewPidSetCorrect = _1150._2;auto _1156 = y;auto _1157 = newPidSet;auto _1154 = _Vec<uint64_t>::_ConsV(_1156,_1157);auto _1159 = _TyEq::_Refl()
;auto _1155 = _1159;auto _1153 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1154,_1155);auto _1151 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_1153);auto _1149 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1151); return _1149;}} }(); return _1146;}} }(); return _1140;};auto _1124 = bindEq<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>,_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1126)(_1127); return _1124;}} }(); return _1118;};auto _1101 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>,_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1103)(_1104); return _1101;}} }(); return _1098;}} }(); return _1095;}} }(); return _1092;}} }(); return _1082;}} }(); return _1080;}; return _1079;}; return _1078;}; return _1077;}; return _1076;}; return _1075;}; return _1074;}; return _1073;};

template <class A> std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> createChannelsFarm = [](auto m) { auto _1160 = [m](auto chidSet) { auto _1161 = [chidSet,m](auto mDash) { auto _1162 = [chidSet,m,mDash](auto chids) { auto _1163 = [chids,chidSet,m,mDash](auto chidPf) { auto _1164 = [chids,chidSet,chidPf,m,mDash]() { auto _1165 = chids; switch (   _1165.type) {  case NilV: {auto _1167 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1165.data));auto _1171 = _Vec<_Sigma<uint64_t,_Channel<A>>>::_NilV();auto _1173 = chidSet;auto _1174 = _TyEq::_Refl()
;auto _1172 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1173,_1174);auto _1170 = _Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1171,_1172);auto _1168 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1170);auto _1166 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1168); return _1166;} case ConsV: {auto _1176 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1165.data));auto x = _1176._1;auto xs = _1176._2;auto _1175 = [chids,chidSet,chidPf,m,mDash,xs]() { auto _1177 = chidPf; switch (   _1177.type) {  case UConsV: {auto _1179 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1177.data));auto y = _1179._1;auto ys = _1179._2;auto pf = _1179._3;auto restPf = _1179._4;auto _1184 = y;auto _1185 = ys;auto _1186 = pf;auto _1180 = link<A>(_1184)(_1185)(_1186);auto _1181 = [chids,chidSet,chidPf,y,ys,pf,m,mDash,xs,restPf](auto mres) { auto _1189 = [chids,chidSet,chidPf,y,ys,pf,mres,m,mDash,xs,restPf]() { auto _1190 = mres; switch (   _1190.type) {  case Nothing: {auto _1192 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_1190.data));auto _1193 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1191 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1193); return _1191;} case Just: {auto _1196 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_1190.data));auto res = _1196._1;auto _1195 = [chids,chidSet,chidPf,y,ys,pf,mres,res,m,mDash,xs,restPf]() { auto _1197 = res; switch (   _1197.type) {  case Prod: {auto _1199 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1197.data));auto resChid = _1199._1;auto rest1 = _1199._2;auto _1198 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,m,mDash,xs,restPf]() { auto _1200 = rest1; switch (   _1200.type) {  case Prod: {auto _1202 = *(std::static_pointer_cast<_Sigma_Prod<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>(_1200.data));auto ch = _1202._1;auto rest2 = _1202._2;auto _1201 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,m,mDash,xs,restPf,ch]() { auto _1203 = rest2; switch (   _1203.type) {  case Prod: {auto _1205 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>(_1203.data));auto newChidSet = _1205._1;auto pfs = _1205._2;auto _1204 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,ch]() { auto _1206 = pfs; switch (   _1206.type) {  case Prod: {auto _1208 = *(std::static_pointer_cast<_Sigma_Prod<_TyEq,_TyEq>>(_1206.data));auto chidEqResChidPf = _1208._1;auto pfNewChidSetCorrect = _1208._2;auto _1213 = m;auto _1214 = chidSet;auto _1219 = mDash;auto _1215 = pred(_1219);auto _1216 = xs;auto _1217 = restPf;auto _1209 = createChannelsFarm<A>(_1213)(_1214)(_1215)(_1216)(_1217);auto _1210 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,ch](auto mress) { auto _1220 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ch]() { auto _1221 = mress; switch (   _1221.type) {  case Nothing: {auto _1223 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1221.data));auto _1224 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1222 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1224); return _1222;} case Just: {auto _1227 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1221.data));auto ress = _1227._1;auto _1226 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ress,ch]() { auto _1228 = ress; switch (   _1228.type) {  case Prod: {auto _1230 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1228.data));auto chs = _1230._1;auto rest3 = _1230._2;auto _1229 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ress,rest3,ch,chs]() { auto _1231 = rest3; switch (   _1231.type) {  case Prod: {auto _1233 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1231.data));auto returnedChidSet = _1233._1;auto pfReturnedChidSetCorrect = _1233._2;auto _1243 = y;auto _1244 = ch;auto _1242 = _Sigma<uint64_t,_Channel<A>>::_Prod(_1243,_1244);auto _1239 = _1242;auto _1240 = chs;auto _1237 = _Vec<_Sigma<uint64_t,_Channel<A>>>::_ConsV(_1239,_1240);auto _1247 = y;auto _1248 = returnedChidSet;auto _1245 = _Vec<uint64_t>::_ConsV(_1247,_1248);auto _1250 = _TyEq::_Refl()
;auto _1246 = _1250;auto _1238 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1245,_1246);auto _1236 = _Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1237,_1238);auto _1234 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1236);auto _1232 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1234); return _1232;}} }(); return _1229;}} }(); return _1226;}} }(); return _1220;};auto _1207 = bindEq<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1209)(_1210); return _1207;}} }(); return _1204;}} }(); return _1201;}} }(); return _1198;}} }(); return _1195;}} }(); return _1189;};auto _1178 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>,_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1180)(_1181); return _1178;}} }(); return _1175;}} }(); return _1164;}; return _1163;}; return _1162;}; return _1161;}; return _1160;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_List<A>)>(std::function<A(A)>)>(_TyEq)>(_TyEq)>(std::function<_Void(_TyEq)>)>(uint64_t)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> createFarm = [](auto n) { auto _1251 = [n](auto pidSet) { auto _1252 = [n,pidSet](auto nDash) { auto _1253 = [n,pidSet,nDash](auto pids) { auto _1254 = [pids,n,pidSet,nDash](auto pidPf) { auto _1255 = [pids,pidPf,n,pidSet,nDash](auto m) { auto _1256 = [m,pids,pidPf,n,pidSet,nDash](auto chidSet) { auto _1257 = [m,chidSet,pids,pidPf,n,pidSet,nDash](auto mDash) { auto _1258 = [m,chidSet,mDash,pids,pidPf,n,pidSet,nDash](auto chids) { auto _1259 = [m,chidSet,mDash,chids,pids,pidPf,n,pidSet,nDash](auto chidPf) { auto _1260 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash](auto numWorkers) { auto _1261 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfNotZ) { auto _1262 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfPidsNCorrect) { auto _1263 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfChidsMCorrect) { auto _1264 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto f) { auto _1265 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,f,numWorkers](auto input) { auto _1271 = m;auto _1272 = chidSet;auto _1273 = mDash;auto _1274 = chids;auto _1275 = chidPf;auto _1267 = createChannelsFarm<A>(_1271)(_1272)(_1273)(_1274)(_1275);auto _1268 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,input,n,pidSet,nDash,f,numWorkers](auto mres1) { auto _1277 = [m,chidSet,mDash,chids,chidPf,mres1,pids,pidPf,input,n,pidSet,nDash,f,numWorkers]() { auto _1278 = mres1; switch (   _1278.type) {  case Nothing: {auto _1280 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1278.data));auto _1281 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1279 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1281); return _1279;} case Just: {auto _1284 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1278.data));auto res1 = _1284._1;auto _1283 = [m,chidSet,mDash,chids,chidPf,mres1,res1,pids,pidPf,input,n,pidSet,nDash,f,numWorkers]() { auto _1285 = res1; switch (   _1285.type) {  case Prod: {auto _1287 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1285.data));auto chs = _1287._1;auto chidPfToReturn = _1287._2;auto _1286 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,pids,pidPf,input,n,pidSet,nDash,f,numWorkers,chidPfToReturn]() { auto _1288 = chs; switch (   _1288.type) {  case NilV: {auto _1290 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_1288.data));auto _1291 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1289 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1291); return _1289;} case ConsV: {auto _1294 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_1288.data));auto consumerCh = _1294._1;auto otherChs = _1294._2;auto _1293 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,f,numWorkers,chidPfToReturn]() { auto _1295 = consumerCh; switch (   _1295.type) {  case Prod: {auto _1297 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1295.data));auto consumerChid = _1297._1;auto consumerChannel = _1297._2;auto _1296 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1298 = pids; switch (   _1298.type) {  case NilV: {auto _1300 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1298.data));auto _1301 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1299 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1301); return _1299;} case ConsV: {auto _1304 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1298.data));auto x = _1304._1;auto xs = _1304._2;auto _1303 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,xs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1305 = pidPf; switch (   _1305.type) {  case UConsV: {auto _1307 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1305.data));auto producerPid = _1307._1;auto restPids = _1307._2;auto producerPidPf = _1307._3;auto restPfs = _1307._4;auto _1312 = producerPid;auto _1313 = restPids;auto _1314 = producerPidPf;auto _1308 = spawnAndRun(_1312)(_1313)(_1314)([m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input](){auto _1317 = otherChs;auto _1318 = otherChs;auto _1319 = input;auto _1315 = farmProducerWrapper<A>(_1317)(_1318)(_1319);});auto _1309 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn](auto mres2) { auto _1323 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1324 = mres2; switch (   _1324.type) {  case Nothing: {auto _1326 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1324.data));auto _1327 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1325 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1327); return _1325;} case Just: {auto _1330 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1324.data));auto res2 = _1330._1;auto _1335 = n;auto _1336 = pidSet;auto _1344 = nDash;auto _1337 = pred(_1344);auto _1338 = xs;auto _1339 = restPfs;auto _1345 = otherChs;auto _1340 = _1345;auto _1341 = consumerCh;auto _1342 = f;auto _1331 = spawnWorkersFarm<A>(_1335)(_1336)(_1337)(_1338)(_1339)(_1340)(_1341)(_1342);auto _1332 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn](auto mres3) { auto _1346 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1347 = mres3; switch (   _1347.type) {  case Nothing: {auto _1349 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1347.data));auto _1350 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1348 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1350); return _1348;} case Just: {auto _1353 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1347.data));auto workerPidPfs = _1353._1;auto _1352 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,workerPidPfs,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1354 = workerPidPfs; switch (   _1354.type) {  case Prod: {auto _1356 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1354.data));auto workersPidSet = _1356._1;auto workerPidSetPf = _1356._2;auto _1361 = consumerChid;auto _1362 = consumerChannel;auto _1363 = numWorkers;auto _1357 = farmConsumerWrapper<A>(_1361)(_1362)(_1363);auto _1358 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,workerPidPfs,consumerChid,consumerChannel,numWorkers,workersPidSet,workerPidSetPf,chidPfToReturn](auto resultantList) { auto _1369 = resultantList;auto _1373 = numWorkers;auto _1374 = f;auto _1371 = _Farm<A>::_MkFarm(_1373,_1374);auto _1379 = producerPid;auto _1380 = workersPidSet;auto _1377 = _Vec<uint64_t>::_ConsV(_1379,_1380);auto _1382 = _TyEq::_Refl()
;auto _1383 = workerPidSetPf;auto _1378 = consVInjLem(_1382)(_1383);auto _1375 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1377,_1378);auto _1376 = chidPfToReturn;auto _1372 = _Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1375,_1376);auto _1370 = _Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Prod(_1371,_1372);auto _1368 = _Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>::_Prod(_1369,_1370);auto _1366 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Just(_1368);auto _1365 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1366); return _1365;};auto _1355 = bindEq<_List<A>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1357)(_1358); return _1355;}} }(); return _1352;}} }(); return _1346;};auto _1329 = bindEq<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1331)(_1332); return _1329;}} }(); return _1323;};auto _1306 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1308)(_1309); return _1306;}} }(); return _1303;}} }(); return _1296;}} }(); return _1293;}} }(); return _1286;}} }(); return _1283;}} }(); return _1277;};auto _1266 = bindEq<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1267)(_1268); return _1266;}; return _1265;}; return _1264;}; return _1263;}; return _1262;}; return _1261;}; return _1260;}; return _1259;}; return _1258;}; return _1257;}; return _1256;}; return _1255;}; return _1254;}; return _1253;}; return _1252;}; return _1251;};

std::function<uint64_t(uint64_t)> id = [](auto a) { auto _1390 = a;auto _1389 = _1390 + 1;; return _1389;};

template <class A> std::function<_IO<_Unit>(A)> runInIO = [](auto f) { auto _1392 = _Unit::_unit();auto _1391 = returnIO<_Unit>(_1392); return _1391;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> baseRun = [](auto inList) { auto _1394 = [inList](auto func) { auto _1400 = (uint64_t)0;auto _1396 = getTime(_1400);auto _1397 = [func,inList](auto startTime1) { auto _1407 = startTime1;auto _1406 = natToString(_1407);auto _1402 = print(_1406);auto _1414 = func;auto _1415 = inList;auto _1412 = map<A,A>(_1414)(_1415);auto _1408 = runInIO<_List<A>>(_1412);auto _1422 = (uint64_t)0;auto _1418 = getTime(_1422);auto _1419 = [startTime1,func,inList](auto endTime1) { auto _1429 = endTime1;auto _1428 = natToString(_1429);auto _1424 = print(_1428);auto _1425 = end;auto _1423 = bind<_Unit,_Unit>(_1424)(_1425); return _1423;};auto _1409 = bindEq<uint64_t,_Unit>(_1418)(_1419);auto _1403 = bind<_Unit,_Unit>(_1408)(_1409);auto _1401 = bind<_Unit,_Unit>(_1402)(_1403); return _1401;};auto _1395 = bindEq<uint64_t,_Unit>(_1396)(_1397); return _1395;}; return _1394;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)>(std::function<A(A)>)>(_List<A>)> runFarm = [](auto inList) { auto _1430 = [inList](auto func) { auto _1431 = [func,inList](auto numWorkers) { auto _1432 = [numWorkers,func,inList](auto n) { auto _1433 = [numWorkers,n,func,inList](auto pidSet) { auto _1434 = [pidSet,numWorkers,n,func,inList](auto x) { auto _1435 = [pidSet,numWorkers,x,n,func,inList](auto pidsToAdd) { auto _1436 = [pidsToAdd,pidSet,numWorkers,x,n,func,inList](auto m) { auto _1437 = [pidsToAdd,pidSet,numWorkers,x,n,m,func,inList](auto chidSet) { auto _1438 = [pidsToAdd,pidSet,chidSet,numWorkers,x,n,m,func,inList](auto y) { auto _1439 = [pidsToAdd,pidSet,chidSet,numWorkers,x,y,n,m,func,inList](auto chidsToAdd) { auto _1440 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,m,func,inList]() { auto _1444 = pidsToAdd;auto _1445 = pidSet;auto _1442 = appendVec<uint64_t>(_1444)(_1445);auto _1441 = decUniqueVec(_1442); switch (   _1441.type) {  case Yes: {auto _1450 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1441.data));auto pidsProof = _1450._1;auto _1449 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,func,inList]() { auto _1454 = chidsToAdd;auto _1455 = chidSet;auto _1452 = appendVec<uint64_t>(_1454)(_1455);auto _1451 = decUniqueVec(_1452); switch (   _1451.type) {  case Yes: {auto _1460 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1451.data));auto chidsProof = _1460._1;auto _1459 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,func,inList]() { auto _1462 = numWorkers;auto _1463 = (uint64_t)0;auto _1461 = decEqNat(_1462)(_1463); switch (   _1461.type) {  case No: {auto _1465 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1461.data));auto numWneq0 = _1465._1;auto _1464 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,func,inList]() { auto _1467 = x;auto _1469 = numWorkers;auto _1468 = _1469 + 1;;auto _1466 = decEqNat(_1467)(_1468); switch (   _1466.type) {  case Yes: {auto _1471 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1466.data));auto xProof = _1471._1;auto _1470 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,func,inList]() { auto _1473 = y;auto _1475 = numWorkers;auto _1474 = _1475 + 1;;auto _1472 = decEqNat(_1473)(_1474); switch (   _1472.type) {  case Yes: {auto _1477 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1472.data));auto yProof = _1477._1;auto _1482 = (uint64_t)0;auto _1478 = getTime(_1482);auto _1479 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto startTime) { auto _1489 = startTime;auto _1488 = natToString(_1489);auto _1484 = print(_1488);auto _1494 = n;auto _1495 = pidSet;auto _1496 = x;auto _1497 = pidsToAdd;auto _1498 = pidsProof;auto _1499 = m;auto _1500 = chidSet;auto _1501 = y;auto _1502 = chidsToAdd;auto _1503 = chidsProof;auto _1504 = numWorkers;auto _1505 = numWneq0;auto _1506 = xProof;auto _1507 = yProof;auto _1508 = func;auto _1509 = inList;auto _1490 = createFarm<A>(_1494)(_1495)(_1496)(_1497)(_1498)(_1499)(_1500)(_1501)(_1502)(_1503)(_1504)(_1505)(_1506)(_1507)(_1508)(_1509);auto _1491 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto mresult) { auto _1511 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult]() { auto _1512 = mresult; switch (   _1512.type) {  case Just: {auto _1514 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1512.data));auto result = _1514._1;auto _1513 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result]() { auto _1515 = result; switch (   _1515.type) {  case Prod: {auto _1517 = *(std::static_pointer_cast<_Sigma_Prod<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>(_1515.data));auto output = _1517._1;auto rest1 = _1517._2;auto _1516 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result,rest1]() { auto _1518 = rest1; switch (   _1518.type) {  case Prod: {auto _1520 = *(std::static_pointer_cast<_Sigma_Prod<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1518.data));auto farmObject = _1520._1;auto toReturn = _1520._2;auto _1525 = (uint64_t)0;auto _1521 = getTime(_1525);auto _1522 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result,rest1,toReturn](auto endTime) { auto _1532 = endTime;auto _1531 = natToString(_1532);auto _1527 = print(_1531);auto _1535 = toReturn;auto _1533 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1535);auto _1528 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1533);auto _1526 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1527)(_1528); return _1526;};auto _1519 = bindEq<uint64_t,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1521)(_1522); return _1519;}} }(); return _1516;}} }(); return _1513;} case Nothing: {auto _1537 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1512.data));auto _1538 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1536 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1538); return _1536;}} }(); return _1511;};auto _1485 = bindEq<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1490)(_1491);auto _1483 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1484)(_1485); return _1483;};auto _1476 = bindEq<uint64_t,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1478)(_1479); return _1476;} case No: {auto _1541 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1472.data));auto xYProof = _1541._1;auto _1547 = 'E';auto _1549 = 'r';auto _1551 = 'r';auto _1553 = 'o';auto _1555 = 'r';auto _1556 = _List<char>::_Nil();auto _1554 = _List<char>::_Cons(_1555,_1556);auto _1552 = _List<char>::_Cons(_1553,_1554);auto _1550 = _List<char>::_Cons(_1551,_1552);auto _1548 = _List<char>::_Cons(_1549,_1550);auto _1546 = _List<char>::_Cons(_1547,_1548);auto _1542 = print(_1546);auto _1557 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1543 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1557);auto _1540 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1542)(_1543); return _1540;}} }(); return _1470;} case No: {auto _1560 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1466.data));auto cXProof = _1560._1;auto _1566 = 'E';auto _1568 = 'r';auto _1570 = 'r';auto _1572 = 'o';auto _1574 = 'r';auto _1575 = _List<char>::_Nil();auto _1573 = _List<char>::_Cons(_1574,_1575);auto _1571 = _List<char>::_Cons(_1572,_1573);auto _1569 = _List<char>::_Cons(_1570,_1571);auto _1567 = _List<char>::_Cons(_1568,_1569);auto _1565 = _List<char>::_Cons(_1566,_1567);auto _1561 = print(_1565);auto _1576 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1562 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1576);auto _1559 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1561)(_1562); return _1559;}} }(); return _1464;} case Yes: {auto _1579 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1461.data));auto numWeq0 = _1579._1;auto _1585 = 'E';auto _1587 = 'r';auto _1589 = 'r';auto _1591 = 'o';auto _1593 = 'r';auto _1594 = _List<char>::_Nil();auto _1592 = _List<char>::_Cons(_1593,_1594);auto _1590 = _List<char>::_Cons(_1591,_1592);auto _1588 = _List<char>::_Cons(_1589,_1590);auto _1586 = _List<char>::_Cons(_1587,_1588);auto _1584 = _List<char>::_Cons(_1585,_1586);auto _1580 = print(_1584);auto _1595 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1581 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1595);auto _1578 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1580)(_1581); return _1578;}} }(); return _1459;} case No: {auto _1598 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1451.data));auto cChidsProof = _1598._1;auto _1604 = 'E';auto _1606 = 'r';auto _1608 = 'r';auto _1610 = 'o';auto _1612 = 'r';auto _1613 = _List<char>::_Nil();auto _1611 = _List<char>::_Cons(_1612,_1613);auto _1609 = _List<char>::_Cons(_1610,_1611);auto _1607 = _List<char>::_Cons(_1608,_1609);auto _1605 = _List<char>::_Cons(_1606,_1607);auto _1603 = _List<char>::_Cons(_1604,_1605);auto _1599 = print(_1603);auto _1614 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1600 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1614);auto _1597 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1599)(_1600); return _1597;}} }(); return _1449;} case No: {auto _1617 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1441.data));auto cPidsProof = _1617._1;auto _1623 = 'E';auto _1625 = 'r';auto _1627 = 'r';auto _1629 = 'o';auto _1631 = 'r';auto _1632 = _List<char>::_Nil();auto _1630 = _List<char>::_Cons(_1631,_1632);auto _1628 = _List<char>::_Cons(_1629,_1630);auto _1626 = _List<char>::_Cons(_1627,_1628);auto _1624 = _List<char>::_Cons(_1625,_1626);auto _1622 = _List<char>::_Cons(_1623,_1624);auto _1618 = print(_1622);auto _1633 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1619 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1633);auto _1616 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1618)(_1619); return _1616;}} }(); return _1440;}; return _1439;}; return _1438;}; return _1437;}; return _1436;}; return _1435;}; return _1434;}; return _1433;}; return _1432;}; return _1431;}; return _1430;};

std::function<_Vec<uint64_t>(uint64_t)> genList = [](auto n) { auto _1635 = [n]() {auto _1636 = n; if ( !_1636 ) {auto _1638 = (uint64_t)1;auto _1639 = _Vec<uint64_t>::_NilV();auto _1637 = _Vec<uint64_t>::_ConsV(_1638,_1639);return _1637; } else {auto n2 = _1636 - 1;auto _1645 = n2;auto _1644 = _1645 + 1;;auto _1641 = _1644 + 1;;auto _1646 = n2;auto _1642 = genList(_1646);auto _1637 = _Vec<uint64_t>::_ConsV(_1641,_1642);return _1637;} }(); return _1635;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm2 = [](auto inList) { auto _1647 = [inList](auto func) { auto _1653 = inList;auto _1654 = func;auto _1655 = (uint64_t)2;auto _1656 = (uint64_t)0;auto _1657 = _Vec<uint64_t>::_NilV();auto _1658 = (uint64_t)3;auto _1665 = (uint64_t)2;auto _1659 = genList(_1665);auto _1660 = (uint64_t)0;auto _1661 = _Vec<uint64_t>::_NilV();auto _1662 = (uint64_t)3;auto _1666 = (uint64_t)2;auto _1663 = genList(_1666);auto _1649 = runFarm<A>(_1653)(_1654)(_1655)(_1656)(_1657)(_1658)(_1659)(_1660)(_1661)(_1662)(_1663);auto _1650 = end;auto _1648 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1649)(_1650); return _1648;}; return _1647;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm4 = [](auto inList) { auto _1667 = [inList](auto func) { auto _1673 = inList;auto _1674 = func;auto _1675 = (uint64_t)4;auto _1676 = (uint64_t)0;auto _1677 = _Vec<uint64_t>::_NilV();auto _1678 = (uint64_t)5;auto _1685 = (uint64_t)4;auto _1679 = genList(_1685);auto _1680 = (uint64_t)0;auto _1681 = _Vec<uint64_t>::_NilV();auto _1682 = (uint64_t)5;auto _1686 = (uint64_t)4;auto _1683 = genList(_1686);auto _1669 = runFarm<A>(_1673)(_1674)(_1675)(_1676)(_1677)(_1678)(_1679)(_1680)(_1681)(_1682)(_1683);auto _1670 = end;auto _1668 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1669)(_1670); return _1668;}; return _1667;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm6 = [](auto inList) { auto _1687 = [inList](auto func) { auto _1693 = inList;auto _1694 = func;auto _1695 = (uint64_t)6;auto _1696 = (uint64_t)0;auto _1697 = _Vec<uint64_t>::_NilV();auto _1698 = (uint64_t)7;auto _1705 = (uint64_t)6;auto _1699 = genList(_1705);auto _1700 = (uint64_t)0;auto _1701 = _Vec<uint64_t>::_NilV();auto _1702 = (uint64_t)7;auto _1706 = (uint64_t)6;auto _1703 = genList(_1706);auto _1689 = runFarm<A>(_1693)(_1694)(_1695)(_1696)(_1697)(_1698)(_1699)(_1700)(_1701)(_1702)(_1703);auto _1690 = end;auto _1688 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1689)(_1690); return _1688;}; return _1687;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm8 = [](auto inList) { auto _1707 = [inList](auto func) { auto _1713 = inList;auto _1714 = func;auto _1715 = (uint64_t)8;auto _1716 = (uint64_t)0;auto _1717 = _Vec<uint64_t>::_NilV();auto _1718 = (uint64_t)9;auto _1725 = (uint64_t)8;auto _1719 = genList(_1725);auto _1720 = (uint64_t)0;auto _1721 = _Vec<uint64_t>::_NilV();auto _1722 = (uint64_t)9;auto _1726 = (uint64_t)8;auto _1723 = genList(_1726);auto _1709 = runFarm<A>(_1713)(_1714)(_1715)(_1716)(_1717)(_1718)(_1719)(_1720)(_1721)(_1722)(_1723);auto _1710 = end;auto _1708 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1709)(_1710); return _1708;}; return _1707;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm10 = [](auto inList) { auto _1727 = [inList](auto func) { auto _1733 = inList;auto _1734 = func;auto _1735 = (uint64_t)10;auto _1736 = (uint64_t)0;auto _1737 = _Vec<uint64_t>::_NilV();auto _1738 = (uint64_t)11;auto _1745 = (uint64_t)10;auto _1739 = genList(_1745);auto _1740 = (uint64_t)0;auto _1741 = _Vec<uint64_t>::_NilV();auto _1742 = (uint64_t)11;auto _1746 = (uint64_t)10;auto _1743 = genList(_1746);auto _1729 = runFarm<A>(_1733)(_1734)(_1735)(_1736)(_1737)(_1738)(_1739)(_1740)(_1741)(_1742)(_1743);auto _1730 = end;auto _1728 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1729)(_1730); return _1728;}; return _1727;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm12 = [](auto inList) { auto _1747 = [inList](auto func) { auto _1753 = inList;auto _1754 = func;auto _1755 = (uint64_t)12;auto _1756 = (uint64_t)0;auto _1757 = _Vec<uint64_t>::_NilV();auto _1758 = (uint64_t)13;auto _1765 = (uint64_t)12;auto _1759 = genList(_1765);auto _1760 = (uint64_t)0;auto _1761 = _Vec<uint64_t>::_NilV();auto _1762 = (uint64_t)13;auto _1766 = (uint64_t)12;auto _1763 = genList(_1766);auto _1749 = runFarm<A>(_1753)(_1754)(_1755)(_1756)(_1757)(_1758)(_1759)(_1760)(_1761)(_1762)(_1763);auto _1750 = end;auto _1748 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1749)(_1750); return _1748;}; return _1747;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm14 = [](auto inList) { auto _1767 = [inList](auto func) { auto _1773 = inList;auto _1774 = func;auto _1775 = (uint64_t)14;auto _1776 = (uint64_t)0;auto _1777 = _Vec<uint64_t>::_NilV();auto _1778 = (uint64_t)15;auto _1785 = (uint64_t)14;auto _1779 = genList(_1785);auto _1780 = (uint64_t)0;auto _1781 = _Vec<uint64_t>::_NilV();auto _1782 = (uint64_t)15;auto _1786 = (uint64_t)14;auto _1783 = genList(_1786);auto _1769 = runFarm<A>(_1773)(_1774)(_1775)(_1776)(_1777)(_1778)(_1779)(_1780)(_1781)(_1782)(_1783);auto _1770 = end;auto _1768 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1769)(_1770); return _1768;}; return _1767;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm16 = [](auto inList) { auto _1787 = [inList](auto func) { auto _1793 = inList;auto _1794 = func;auto _1795 = (uint64_t)16;auto _1796 = (uint64_t)0;auto _1797 = _Vec<uint64_t>::_NilV();auto _1798 = (uint64_t)17;auto _1805 = (uint64_t)16;auto _1799 = genList(_1805);auto _1800 = (uint64_t)0;auto _1801 = _Vec<uint64_t>::_NilV();auto _1802 = (uint64_t)17;auto _1806 = (uint64_t)16;auto _1803 = genList(_1806);auto _1789 = runFarm<A>(_1793)(_1794)(_1795)(_1796)(_1797)(_1798)(_1799)(_1800)(_1801)(_1802)(_1803);auto _1790 = end;auto _1788 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1789)(_1790); return _1788;}; return _1787;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm18 = [](auto inList) { auto _1807 = [inList](auto func) { auto _1813 = inList;auto _1814 = func;auto _1815 = (uint64_t)18;auto _1816 = (uint64_t)0;auto _1817 = _Vec<uint64_t>::_NilV();auto _1818 = (uint64_t)19;auto _1825 = (uint64_t)18;auto _1819 = genList(_1825);auto _1820 = (uint64_t)0;auto _1821 = _Vec<uint64_t>::_NilV();auto _1822 = (uint64_t)19;auto _1826 = (uint64_t)18;auto _1823 = genList(_1826);auto _1809 = runFarm<A>(_1813)(_1814)(_1815)(_1816)(_1817)(_1818)(_1819)(_1820)(_1821)(_1822)(_1823);auto _1810 = end;auto _1808 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1809)(_1810); return _1808;}; return _1807;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm20 = [](auto inList) { auto _1827 = [inList](auto func) { auto _1833 = inList;auto _1834 = func;auto _1835 = (uint64_t)20;auto _1836 = (uint64_t)0;auto _1837 = _Vec<uint64_t>::_NilV();auto _1838 = (uint64_t)21;auto _1845 = (uint64_t)20;auto _1839 = genList(_1845);auto _1840 = (uint64_t)0;auto _1841 = _Vec<uint64_t>::_NilV();auto _1842 = (uint64_t)21;auto _1846 = (uint64_t)20;auto _1843 = genList(_1846);auto _1829 = runFarm<A>(_1833)(_1834)(_1835)(_1836)(_1837)(_1838)(_1839)(_1840)(_1841)(_1842)(_1843);auto _1830 = end;auto _1828 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1829)(_1830); return _1828;}; return _1827;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm22 = [](auto inList) { auto _1847 = [inList](auto func) { auto _1853 = inList;auto _1854 = func;auto _1855 = (uint64_t)22;auto _1856 = (uint64_t)0;auto _1857 = _Vec<uint64_t>::_NilV();auto _1858 = (uint64_t)23;auto _1865 = (uint64_t)22;auto _1859 = genList(_1865);auto _1860 = (uint64_t)0;auto _1861 = _Vec<uint64_t>::_NilV();auto _1862 = (uint64_t)23;auto _1866 = (uint64_t)22;auto _1863 = genList(_1866);auto _1849 = runFarm<A>(_1853)(_1854)(_1855)(_1856)(_1857)(_1858)(_1859)(_1860)(_1861)(_1862)(_1863);auto _1850 = end;auto _1848 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1849)(_1850); return _1848;}; return _1847;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm24 = [](auto inList) { auto _1867 = [inList](auto func) { auto _1873 = inList;auto _1874 = func;auto _1875 = (uint64_t)24;auto _1876 = (uint64_t)0;auto _1877 = _Vec<uint64_t>::_NilV();auto _1878 = (uint64_t)25;auto _1885 = (uint64_t)24;auto _1879 = genList(_1885);auto _1880 = (uint64_t)0;auto _1881 = _Vec<uint64_t>::_NilV();auto _1882 = (uint64_t)25;auto _1886 = (uint64_t)24;auto _1883 = genList(_1886);auto _1869 = runFarm<A>(_1873)(_1874)(_1875)(_1876)(_1877)(_1878)(_1879)(_1880)(_1881)(_1882)(_1883);auto _1870 = end;auto _1868 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1869)(_1870); return _1868;}; return _1867;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm26 = [](auto inList) { auto _1887 = [inList](auto func) { auto _1893 = inList;auto _1894 = func;auto _1895 = (uint64_t)26;auto _1896 = (uint64_t)0;auto _1897 = _Vec<uint64_t>::_NilV();auto _1898 = (uint64_t)27;auto _1905 = (uint64_t)26;auto _1899 = genList(_1905);auto _1900 = (uint64_t)0;auto _1901 = _Vec<uint64_t>::_NilV();auto _1902 = (uint64_t)27;auto _1906 = (uint64_t)26;auto _1903 = genList(_1906);auto _1889 = runFarm<A>(_1893)(_1894)(_1895)(_1896)(_1897)(_1898)(_1899)(_1900)(_1901)(_1902)(_1903);auto _1890 = end;auto _1888 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1889)(_1890); return _1888;}; return _1887;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> callFarm28 = [](auto inList) { auto _1907 = [inList](auto func) { auto _1913 = inList;auto _1914 = func;auto _1915 = (uint64_t)28;auto _1916 = (uint64_t)0;auto _1917 = _Vec<uint64_t>::_NilV();auto _1918 = (uint64_t)29;auto _1925 = (uint64_t)28;auto _1919 = genList(_1925);auto _1920 = (uint64_t)0;auto _1921 = _Vec<uint64_t>::_NilV();auto _1922 = (uint64_t)29;auto _1926 = (uint64_t)28;auto _1923 = genList(_1926);auto _1909 = runFarm<A>(_1913)(_1914)(_1915)(_1916)(_1917)(_1918)(_1919)(_1920)(_1921)(_1922)(_1923);auto _1910 = end;auto _1908 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1909)(_1910); return _1908;}; return _1907;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> runFarms4 = [](auto inList) { auto _1927 = [inList](auto func) { auto _1934 = '2';auto _1936 = '6';auto _1938 = ' ';auto _1940 = 'c';auto _1942 = 'o';auto _1944 = 'r';auto _1946 = 'e';auto _1948 = 's';auto _1949 = _List<char>::_Nil();auto _1947 = _List<char>::_Cons(_1948,_1949);auto _1945 = _List<char>::_Cons(_1946,_1947);auto _1943 = _List<char>::_Cons(_1944,_1945);auto _1941 = _List<char>::_Cons(_1942,_1943);auto _1939 = _List<char>::_Cons(_1940,_1941);auto _1937 = _List<char>::_Cons(_1938,_1939);auto _1935 = _List<char>::_Cons(_1936,_1937);auto _1933 = _List<char>::_Cons(_1934,_1935);auto _1929 = print(_1933);auto _1954 = inList;auto _1955 = func;auto _1950 = callFarm26<A>(_1954)(_1955);auto _1962 = '2';auto _1964 = '8';auto _1966 = ' ';auto _1968 = 'c';auto _1970 = 'o';auto _1972 = 'r';auto _1974 = 'e';auto _1976 = 's';auto _1977 = _List<char>::_Nil();auto _1975 = _List<char>::_Cons(_1976,_1977);auto _1973 = _List<char>::_Cons(_1974,_1975);auto _1971 = _List<char>::_Cons(_1972,_1973);auto _1969 = _List<char>::_Cons(_1970,_1971);auto _1967 = _List<char>::_Cons(_1968,_1969);auto _1965 = _List<char>::_Cons(_1966,_1967);auto _1963 = _List<char>::_Cons(_1964,_1965);auto _1961 = _List<char>::_Cons(_1962,_1963);auto _1957 = print(_1961);auto _1982 = inList;auto _1983 = func;auto _1978 = callFarm28<A>(_1982)(_1983);auto _1979 = end;auto _1958 = bind<_Unit,_Unit>(_1978)(_1979);auto _1951 = bind<_Unit,_Unit>(_1957)(_1958);auto _1930 = bind<_Unit,_Unit>(_1950)(_1951);auto _1928 = bind<_Unit,_Unit>(_1929)(_1930); return _1928;}; return _1927;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> runFarms3 = [](auto inList) { auto _1985 = [inList](auto func) { auto _1992 = '1';auto _1994 = '8';auto _1996 = ' ';auto _1998 = 'c';auto _2000 = 'o';auto _2002 = 'r';auto _2004 = 'e';auto _2006 = 's';auto _2007 = _List<char>::_Nil();auto _2005 = _List<char>::_Cons(_2006,_2007);auto _2003 = _List<char>::_Cons(_2004,_2005);auto _2001 = _List<char>::_Cons(_2002,_2003);auto _1999 = _List<char>::_Cons(_2000,_2001);auto _1997 = _List<char>::_Cons(_1998,_1999);auto _1995 = _List<char>::_Cons(_1996,_1997);auto _1993 = _List<char>::_Cons(_1994,_1995);auto _1991 = _List<char>::_Cons(_1992,_1993);auto _1987 = print(_1991);auto _2012 = inList;auto _2013 = func;auto _2008 = callFarm18<A>(_2012)(_2013);auto _2020 = '2';auto _2022 = '0';auto _2024 = ' ';auto _2026 = 'c';auto _2028 = 'o';auto _2030 = 'r';auto _2032 = 'e';auto _2034 = 's';auto _2035 = _List<char>::_Nil();auto _2033 = _List<char>::_Cons(_2034,_2035);auto _2031 = _List<char>::_Cons(_2032,_2033);auto _2029 = _List<char>::_Cons(_2030,_2031);auto _2027 = _List<char>::_Cons(_2028,_2029);auto _2025 = _List<char>::_Cons(_2026,_2027);auto _2023 = _List<char>::_Cons(_2024,_2025);auto _2021 = _List<char>::_Cons(_2022,_2023);auto _2019 = _List<char>::_Cons(_2020,_2021);auto _2015 = print(_2019);auto _2040 = inList;auto _2041 = func;auto _2036 = callFarm20<A>(_2040)(_2041);auto _2048 = '2';auto _2050 = '2';auto _2052 = ' ';auto _2054 = 'c';auto _2056 = 'o';auto _2058 = 'r';auto _2060 = 'e';auto _2062 = 's';auto _2063 = _List<char>::_Nil();auto _2061 = _List<char>::_Cons(_2062,_2063);auto _2059 = _List<char>::_Cons(_2060,_2061);auto _2057 = _List<char>::_Cons(_2058,_2059);auto _2055 = _List<char>::_Cons(_2056,_2057);auto _2053 = _List<char>::_Cons(_2054,_2055);auto _2051 = _List<char>::_Cons(_2052,_2053);auto _2049 = _List<char>::_Cons(_2050,_2051);auto _2047 = _List<char>::_Cons(_2048,_2049);auto _2043 = print(_2047);auto _2068 = inList;auto _2069 = func;auto _2064 = callFarm22<A>(_2068)(_2069);auto _2076 = '2';auto _2078 = '4';auto _2080 = ' ';auto _2082 = 'c';auto _2084 = 'o';auto _2086 = 'r';auto _2088 = 'e';auto _2090 = 's';auto _2091 = _List<char>::_Nil();auto _2089 = _List<char>::_Cons(_2090,_2091);auto _2087 = _List<char>::_Cons(_2088,_2089);auto _2085 = _List<char>::_Cons(_2086,_2087);auto _2083 = _List<char>::_Cons(_2084,_2085);auto _2081 = _List<char>::_Cons(_2082,_2083);auto _2079 = _List<char>::_Cons(_2080,_2081);auto _2077 = _List<char>::_Cons(_2078,_2079);auto _2075 = _List<char>::_Cons(_2076,_2077);auto _2071 = print(_2075);auto _2096 = inList;auto _2097 = func;auto _2092 = callFarm24<A>(_2096)(_2097);auto _2099 = inList;auto _2100 = func;auto _2093 = runFarms4<A>(_2099)(_2100);auto _2072 = bind<_Unit,_Unit>(_2092)(_2093);auto _2065 = bind<_Unit,_Unit>(_2071)(_2072);auto _2044 = bind<_Unit,_Unit>(_2064)(_2065);auto _2037 = bind<_Unit,_Unit>(_2043)(_2044);auto _2016 = bind<_Unit,_Unit>(_2036)(_2037);auto _2009 = bind<_Unit,_Unit>(_2015)(_2016);auto _1988 = bind<_Unit,_Unit>(_2008)(_2009);auto _1986 = bind<_Unit,_Unit>(_1987)(_1988); return _1986;}; return _1985;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> runFarms2 = [](auto inList) { auto _2102 = [inList](auto func) { auto _2109 = '1';auto _2111 = '0';auto _2113 = ' ';auto _2115 = 'c';auto _2117 = 'o';auto _2119 = 'r';auto _2121 = 'e';auto _2123 = 's';auto _2124 = _List<char>::_Nil();auto _2122 = _List<char>::_Cons(_2123,_2124);auto _2120 = _List<char>::_Cons(_2121,_2122);auto _2118 = _List<char>::_Cons(_2119,_2120);auto _2116 = _List<char>::_Cons(_2117,_2118);auto _2114 = _List<char>::_Cons(_2115,_2116);auto _2112 = _List<char>::_Cons(_2113,_2114);auto _2110 = _List<char>::_Cons(_2111,_2112);auto _2108 = _List<char>::_Cons(_2109,_2110);auto _2104 = print(_2108);auto _2129 = inList;auto _2130 = func;auto _2125 = callFarm10<A>(_2129)(_2130);auto _2137 = '1';auto _2139 = '2';auto _2141 = ' ';auto _2143 = 'c';auto _2145 = 'o';auto _2147 = 'r';auto _2149 = 'e';auto _2151 = 's';auto _2152 = _List<char>::_Nil();auto _2150 = _List<char>::_Cons(_2151,_2152);auto _2148 = _List<char>::_Cons(_2149,_2150);auto _2146 = _List<char>::_Cons(_2147,_2148);auto _2144 = _List<char>::_Cons(_2145,_2146);auto _2142 = _List<char>::_Cons(_2143,_2144);auto _2140 = _List<char>::_Cons(_2141,_2142);auto _2138 = _List<char>::_Cons(_2139,_2140);auto _2136 = _List<char>::_Cons(_2137,_2138);auto _2132 = print(_2136);auto _2157 = inList;auto _2158 = func;auto _2153 = callFarm12<A>(_2157)(_2158);auto _2165 = '1';auto _2167 = '4';auto _2169 = ' ';auto _2171 = 'c';auto _2173 = 'o';auto _2175 = 'r';auto _2177 = 'e';auto _2179 = 's';auto _2180 = _List<char>::_Nil();auto _2178 = _List<char>::_Cons(_2179,_2180);auto _2176 = _List<char>::_Cons(_2177,_2178);auto _2174 = _List<char>::_Cons(_2175,_2176);auto _2172 = _List<char>::_Cons(_2173,_2174);auto _2170 = _List<char>::_Cons(_2171,_2172);auto _2168 = _List<char>::_Cons(_2169,_2170);auto _2166 = _List<char>::_Cons(_2167,_2168);auto _2164 = _List<char>::_Cons(_2165,_2166);auto _2160 = print(_2164);auto _2185 = inList;auto _2186 = func;auto _2181 = callFarm14<A>(_2185)(_2186);auto _2193 = '1';auto _2195 = '6';auto _2197 = ' ';auto _2199 = 'c';auto _2201 = 'o';auto _2203 = 'r';auto _2205 = 'e';auto _2207 = 's';auto _2208 = _List<char>::_Nil();auto _2206 = _List<char>::_Cons(_2207,_2208);auto _2204 = _List<char>::_Cons(_2205,_2206);auto _2202 = _List<char>::_Cons(_2203,_2204);auto _2200 = _List<char>::_Cons(_2201,_2202);auto _2198 = _List<char>::_Cons(_2199,_2200);auto _2196 = _List<char>::_Cons(_2197,_2198);auto _2194 = _List<char>::_Cons(_2195,_2196);auto _2192 = _List<char>::_Cons(_2193,_2194);auto _2188 = print(_2192);auto _2213 = inList;auto _2214 = func;auto _2209 = callFarm16<A>(_2213)(_2214);auto _2216 = inList;auto _2217 = func;auto _2210 = runFarms3<A>(_2216)(_2217);auto _2189 = bind<_Unit,_Unit>(_2209)(_2210);auto _2182 = bind<_Unit,_Unit>(_2188)(_2189);auto _2161 = bind<_Unit,_Unit>(_2181)(_2182);auto _2154 = bind<_Unit,_Unit>(_2160)(_2161);auto _2133 = bind<_Unit,_Unit>(_2153)(_2154);auto _2126 = bind<_Unit,_Unit>(_2132)(_2133);auto _2105 = bind<_Unit,_Unit>(_2125)(_2126);auto _2103 = bind<_Unit,_Unit>(_2104)(_2105); return _2103;}; return _2102;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> runFarms1 = [](auto inList) { auto _2219 = [inList](auto func) { auto _2226 = '2';auto _2228 = ' ';auto _2230 = 'c';auto _2232 = 'o';auto _2234 = 'r';auto _2236 = 'e';auto _2238 = 's';auto _2239 = _List<char>::_Nil();auto _2237 = _List<char>::_Cons(_2238,_2239);auto _2235 = _List<char>::_Cons(_2236,_2237);auto _2233 = _List<char>::_Cons(_2234,_2235);auto _2231 = _List<char>::_Cons(_2232,_2233);auto _2229 = _List<char>::_Cons(_2230,_2231);auto _2227 = _List<char>::_Cons(_2228,_2229);auto _2225 = _List<char>::_Cons(_2226,_2227);auto _2221 = print(_2225);auto _2244 = inList;auto _2245 = func;auto _2240 = callFarm2<A>(_2244)(_2245);auto _2252 = '4';auto _2254 = ' ';auto _2256 = 'c';auto _2258 = 'o';auto _2260 = 'r';auto _2262 = 'e';auto _2264 = 's';auto _2265 = _List<char>::_Nil();auto _2263 = _List<char>::_Cons(_2264,_2265);auto _2261 = _List<char>::_Cons(_2262,_2263);auto _2259 = _List<char>::_Cons(_2260,_2261);auto _2257 = _List<char>::_Cons(_2258,_2259);auto _2255 = _List<char>::_Cons(_2256,_2257);auto _2253 = _List<char>::_Cons(_2254,_2255);auto _2251 = _List<char>::_Cons(_2252,_2253);auto _2247 = print(_2251);auto _2270 = inList;auto _2271 = func;auto _2266 = callFarm4<A>(_2270)(_2271);auto _2278 = '6';auto _2280 = ' ';auto _2282 = 'c';auto _2284 = 'o';auto _2286 = 'r';auto _2288 = 'e';auto _2290 = 's';auto _2291 = _List<char>::_Nil();auto _2289 = _List<char>::_Cons(_2290,_2291);auto _2287 = _List<char>::_Cons(_2288,_2289);auto _2285 = _List<char>::_Cons(_2286,_2287);auto _2283 = _List<char>::_Cons(_2284,_2285);auto _2281 = _List<char>::_Cons(_2282,_2283);auto _2279 = _List<char>::_Cons(_2280,_2281);auto _2277 = _List<char>::_Cons(_2278,_2279);auto _2273 = print(_2277);auto _2296 = inList;auto _2297 = func;auto _2292 = callFarm6<A>(_2296)(_2297);auto _2304 = '8';auto _2306 = ' ';auto _2308 = 'c';auto _2310 = 'o';auto _2312 = 'r';auto _2314 = 'e';auto _2316 = 's';auto _2317 = _List<char>::_Nil();auto _2315 = _List<char>::_Cons(_2316,_2317);auto _2313 = _List<char>::_Cons(_2314,_2315);auto _2311 = _List<char>::_Cons(_2312,_2313);auto _2309 = _List<char>::_Cons(_2310,_2311);auto _2307 = _List<char>::_Cons(_2308,_2309);auto _2305 = _List<char>::_Cons(_2306,_2307);auto _2303 = _List<char>::_Cons(_2304,_2305);auto _2299 = print(_2303);auto _2322 = inList;auto _2323 = func;auto _2318 = callFarm8<A>(_2322)(_2323);auto _2325 = inList;auto _2326 = func;auto _2319 = runFarms2<A>(_2325)(_2326);auto _2300 = bind<_Unit,_Unit>(_2318)(_2319);auto _2293 = bind<_Unit,_Unit>(_2299)(_2300);auto _2274 = bind<_Unit,_Unit>(_2292)(_2293);auto _2267 = bind<_Unit,_Unit>(_2273)(_2274);auto _2248 = bind<_Unit,_Unit>(_2266)(_2267);auto _2241 = bind<_Unit,_Unit>(_2247)(_2248);auto _2222 = bind<_Unit,_Unit>(_2240)(_2241);auto _2220 = bind<_Unit,_Unit>(_2221)(_2222); return _2220;}; return _2219;};

std::function<_List<uint64_t>(uint64_t)> randoms = [](auto m) { auto _2328 = [m]() {auto _2329 = m; if ( !_2329 ) {auto _2330 = _List<uint64_t>::_Nil();return _2330; } else {auto n = _2329 - 1;auto _2331 = (uint64_t)1024;auto _2333 = n;auto _2332 = randoms(_2333);auto _2330 = _List<uint64_t>::_Cons(_2331,_2332);return _2330;} }(); return _2328;};

std::function<std::function<_List<_List<uint64_t>>(uint64_t)>(uint64_t)> genMatrix = [](auto m) { auto _2334 = [m](auto n) { auto _2335 = [m,n]() {auto _2336 = m; if ( !_2336 ) {auto _2337 = _List<_List<uint64_t>>::_Nil();return _2337; } else {auto m2 = _2336 - 1;auto _2340 = n;auto _2338 = randoms(_2340);auto _2341 = m2;auto _2342 = n;auto _2339 = genMatrix(_2341)(_2342);auto _2337 = _List<_List<uint64_t>>::_Cons(_2338,_2339);return _2337;} }(); return _2335;}; return _2334;};

_IO<_Unit> mainFunc = []() {auto _2349 = (uint64_t)100;auto _2350 = (uint64_t)100;auto _2347 = genMatrix(_2349)(_2350);auto _2348 = _List<_List<_List<uint64_t>>>::_Nil();auto _2344 = _List<_List<_List<uint64_t>>>::_Cons(_2347,_2348);auto _2345 = multMPar;auto _2343 = runFarms1<_List<_List<uint64_t>>>(_2344)(_2345); return _2343;}();
//////////////////////////////////////
// GLOBAL STATE AND HELPER FUNCTION //
//////////////////////////////////////



// Helper functions for pids
std::thread* getThread(uint64_t pid) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(pidMutex);

  // return the information
  return pidsMap[pid];
}

void addThread(uint64_t pid, std::thread* t) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(pidMutex);

  // Adding the thread, will never overwrite
  pidsMap[pid] = t;
}

// Helper functions for channels
void* getChannel(uint64_t chid) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(channelMutex);

  //  returning the channel
  return channelsMap[chid];
}

template <typename A>
void addChannel(uint64_t chid, LockingCQueue<_Maybe<A>>* queue) {
  // Aquireing the lock
  std::lock_guard<std::mutex> lock(channelMutex);

  // adding the channel
  channelsMap[chid] = queue;
}


int main(){}