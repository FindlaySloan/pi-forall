#include <vector>
#include <functional>
#include <thread>
#include <optional>
#include <iostream>
#include <memory>
#include <system_error>
#include <map>
#include <string>
#include <cstdint>
#include "LockingCQueue.hpp"
#include "Semaphore.hpp"

// Forward declares
template <typename A>
class _Maybe;
std::thread* getThread(uint64_t pid);
void addThread(uint64_t pid, std::thread* t);
void* getChannel(uint64_t chid);
template <typename A>
void addChannel(uint64_t chid, LockingCQueue<_Maybe<A>>* queue);

// map of threads
std::map<uint64_t, std::thread*> pidsMap;
std::mutex pidMutex;

// map of channels
std::map<uint64_t, void*> channelsMap;
std::mutex channelMutex;

// enum _enum_Nat_type { Zero, Succ };
// class _Nat_Zero;
// class _Nat_Succ;
// class _Nat {
//  public:
//   enum _enum_Nat_type type;
//   std::shared_ptr<void> data;
//   static _Nat _Zero();
//   static _Nat _Succ(_Nat _1);
//   _Nat(_enum_Nat_type t, std::shared_ptr<void> d) {
//     type = t;
//     data = d;
//   }
//   _Nat(const _Nat& other);
//   _Nat() = default;
// };
// class _Nat_Zero {
//  public:
//   _Nat_Zero(){};
//   _Nat_Zero(const _Nat_Zero* other) {}
// };
// class _Nat_Succ {
//  public:
//   _Nat _1;
//   _Nat_Succ(_Nat _1) { this->_1 = _1; };
//   _Nat_Succ(const _Nat_Succ* other) { this->_1 = other->_1; }
// };
// inline _Nat _Nat::_Zero() {
//   return _Nat(Zero, std::static_pointer_cast<void>(std::make_shared<_Nat_Zero>()));
// };
// inline _Nat _Nat::_Succ(_Nat _1) {
//   return _Nat(Succ, std::static_pointer_cast<void>(std::make_shared<_Nat_Succ>(_1)));
// };
// _Nat::_Nat(const _Nat& other) {
//   type = other.type;
//   data = other.data;
// }
// std::function<uint64_t(_Nat)> intFromNat = [](_Nat n) {
//     if (n.type == Zero) {
//         return 0;
//     } else {
//         return (uint64_t)1 + intFromNat((*(std::static_pointer_cast<_Nat_Succ>(n.data)))._1);
//     }
// };

// List



// Void 
enum _enum_Void_type {};
class _Void {
 public:
  enum _enum_Void_type type;
  std::shared_ptr<void> data;
};


// TyEq

class _TyEq { 
    public: 
        static _TyEq _Refl();
};

inline _TyEq _TyEq::_Refl() {
    return _TyEq{};
}enum _enum_Sigma_type {Prod};template <class a, class b> class _Sigma_Prod;
template <class a, class b> class _Sigma { public: enum _enum_Sigma_type type; std::shared_ptr<void> data;static _Sigma<a,b> _Prod(a _1, b _2);_Sigma<a,b>(_enum_Sigma_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Sigma<a,b>(const _Sigma<a,b>& other);
_Sigma<a,b>() = default;};template <class a, class b> class _Sigma_Prod { public: a _1;b _2;_Sigma_Prod (a _1, b _2) {this->_1= _1;this->_2= _2;};_Sigma_Prod (const _Sigma_Prod* other) { this->_1= other->_1;this->_2= other->_2;} };template <class a, class b>  inline _Sigma<a,b> _Sigma<a,b>::_Prod(a _1, b _2){ return  _Sigma<a,b> ( Prod, std::make_shared<_Sigma_Prod<a,b>>(_1, _2)); };template <class a, class b> _Sigma<a,b>::_Sigma(const _Sigma<a,b>& other) { type = other.type; data = other.data; } 
enum _enum_Unit_type {unit};class _Unit_unit;
class _Unit { public: enum _enum_Unit_type type; std::shared_ptr<void> data;static _Unit _unit();_Unit(_enum_Unit_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Unit(const _Unit& other);
_Unit() = default;};class _Unit_unit { public: _Unit_unit () {};_Unit_unit (const _Unit_unit* other) { } }; inline _Unit _Unit::_unit(){ return  _Unit ( unit, std::make_shared<_Unit_unit>()); };_Unit::_Unit(const _Unit& other) { type = other.type; data = other.data; } 
enum _enum_Bool_type {False,True};class _Bool_False;
class _Bool_True;
class _Bool { public: enum _enum_Bool_type type; std::shared_ptr<void> data;static _Bool _False();static _Bool _True();_Bool(_enum_Bool_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Bool(const _Bool& other);
_Bool() = default;};class _Bool_False { public: _Bool_False () {};_Bool_False (const _Bool_False* other) { } };class _Bool_True { public: _Bool_True () {};_Bool_True (const _Bool_True* other) { } }; inline _Bool _Bool::_False(){ return  _Bool ( False, std::make_shared<_Bool_False>()); }; inline _Bool _Bool::_True(){ return  _Bool ( True, std::make_shared<_Bool_True>()); };_Bool::_Bool(const _Bool& other) { type = other.type; data = other.data; } 
enum _enum_List_type {Nil,Cons};template <class c> class _List_Nil;
template <class c> class _List_Cons;
template <class c> class _List { public: enum _enum_List_type type; std::shared_ptr<void> data;static _List<c> _Nil();static _List<c> _Cons(c _1, _List<c> _2);_List<c>(_enum_List_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_List<c>(const _List<c>& other);
_List<c>() = default;};template <class c> class _List_Nil { public: _List_Nil () {};_List_Nil (const _List_Nil* other) { } };template <class c> class _List_Cons { public: c _1;_List<c> _2;_List_Cons (c _1, _List<c> _2) {this->_1= _1;this->_2= _2;};_List_Cons (const _List_Cons* other) { this->_1= other->_1;this->_2= other->_2;} };template <class c>  inline _List<c> _List<c>::_Nil(){ return  _List<c> ( Nil, std::make_shared<_List_Nil<c>>()); };template <class c>  inline _List<c> _List<c>::_Cons(c _1, _List<c> _2){ return  _List<c> ( Cons, std::make_shared<_List_Cons<c>>(_1, _2)); };template <class c> _List<c>::_List(const _List<c>& other) { type = other.type; data = other.data; } 
enum _enum_Maybe_type {Nothing,Just};template <class A> class _Maybe_Nothing;
template <class A> class _Maybe_Just;
template <class A> class _Maybe { public: enum _enum_Maybe_type type; std::shared_ptr<void> data;static _Maybe<A> _Nothing();static _Maybe<A> _Just(A _1);_Maybe<A>(_enum_Maybe_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Maybe<A>(const _Maybe<A>& other);
_Maybe<A>() = default;};template <class A> class _Maybe_Nothing { public: _Maybe_Nothing () {};_Maybe_Nothing (const _Maybe_Nothing* other) { } };template <class A> class _Maybe_Just { public: A _1;_Maybe_Just (A _1) {this->_1= _1;};_Maybe_Just (const _Maybe_Just* other) { this->_1= other->_1;} };template <class A>  inline _Maybe<A> _Maybe<A>::_Nothing(){ return  _Maybe<A> ( Nothing, std::make_shared<_Maybe_Nothing<A>>()); };template <class A>  inline _Maybe<A> _Maybe<A>::_Just(A _1){ return  _Maybe<A> ( Just, std::make_shared<_Maybe_Just<A>>(_1)); };template <class A> _Maybe<A>::_Maybe(const _Maybe<A>& other) { type = other.type; data = other.data; } 
enum _enum_Vec_type {NilV,ConsV};template <class A> class _Vec_NilV;
template <class A> class _Vec_ConsV;
template <class A> class _Vec { public: enum _enum_Vec_type type; std::shared_ptr<void> data;static _Vec<A> _NilV();static _Vec<A> _ConsV(A _1, _Vec<A> _2);_Vec<A>(_enum_Vec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Vec<A>(const _Vec<A>& other);
_Vec<A>() = default;};template <class A> class _Vec_NilV { public: _Vec_NilV () {};_Vec_NilV (const _Vec_NilV* other) { } };template <class A> class _Vec_ConsV { public: A _1;_Vec<A> _2;_Vec_ConsV (A _1, _Vec<A> _2) {this->_1= _1;this->_2= _2;};_Vec_ConsV (const _Vec_ConsV* other) { this->_1= other->_1;this->_2= other->_2;} };template <class A>  inline _Vec<A> _Vec<A>::_NilV(){ return  _Vec<A> ( NilV, std::make_shared<_Vec_NilV<A>>()); };template <class A>  inline _Vec<A> _Vec<A>::_ConsV(A _1, _Vec<A> _2){ return  _Vec<A> ( ConsV, std::make_shared<_Vec_ConsV<A>>(_1, _2)); };template <class A> _Vec<A>::_Vec(const _Vec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<A(_Vec<A>)> head = [](auto x) { auto _1 = [x]() { auto _2 = x; switch (   _2.type) {  case ConsV: {auto _4 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_2.data));auto y = _4._1;auto ys = _4._2;auto _3 = y; return _3;}} }(); return _1;};

template <class A> std::function<_Vec<A>(_Vec<A>)> tail = [](auto x) { auto _5 = [x]() { auto _6 = x; switch (   _6.type) {  case ConsV: {auto _8 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_6.data));auto y = _8._1;auto ys = _8._2;auto _7 = ys; return _7;}} }(); return _5;};

std::function<_List<char>(uint64_t)> natToString = [](auto n) {std::string stringVersion = std::to_string(n);std::function<_List<char>(std::string)> toList = [&toList](std::string s) {if (s.empty()) {return _List<char>::_Nil();}return _List<char>::_Cons(s.at(0), toList(std::string(s).erase(0, 1)));};return toList(stringVersion);};

template <class a,class b> std::function<std::function<_List<b>(_List<a>)>(std::function<b(a)>)> map = [](auto f) { auto _9 = [f](auto xs) { auto _10 = [xs,f]() { auto _11 = xs; switch (   _11.type) {  case Nil: {auto _13 = *(std::static_pointer_cast<_List_Nil<a>>(_11.data));auto _12 = _List<b>::_Nil(); return _12;} case Cons: {auto _15 = *(std::static_pointer_cast<_List_Cons<a>>(_11.data));auto y = _15._1;auto ys = _15._2;auto _18 = y;auto _16 = f(_18);auto _19 = f;auto _20 = ys;auto _17 = map<a,b>(_19)(_20);auto _14 = _List<b>::_Cons(_16,_17); return _14;}} }(); return _10;}; return _9;};
enum _enum_Dec_type {Yes,No};template <class prop> class _Dec_Yes;
template <class prop> class _Dec_No;
template <class prop> class _Dec { public: enum _enum_Dec_type type; std::shared_ptr<void> data;static _Dec<prop> _Yes(prop _1);static _Dec<prop> _No(std::function<_Void(prop)> _1);_Dec<prop>(_enum_Dec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Dec<prop>(const _Dec<prop>& other);
_Dec<prop>() = default;};template <class prop> class _Dec_Yes { public: prop _1;_Dec_Yes (prop _1) {this->_1= _1;};_Dec_Yes (const _Dec_Yes* other) { this->_1= other->_1;} };template <class prop> class _Dec_No { public: std::function<_Void(prop)> _1;_Dec_No (std::function<_Void(prop)> _1) {this->_1= _1;};_Dec_No (const _Dec_No* other) { this->_1= other->_1;} };template <class prop>  inline _Dec<prop> _Dec<prop>::_Yes(prop _1){ return  _Dec<prop> ( Yes, std::make_shared<_Dec_Yes<prop>>(_1)); };template <class prop>  inline _Dec<prop> _Dec<prop>::_No(std::function<_Void(prop)> _1){ return  _Dec<prop> ( No, std::make_shared<_Dec_No<prop>>(_1)); };template <class prop> _Dec<prop>::_Dec(const _Dec<prop>& other) { type = other.type; data = other.data; } 

template <class A,class B> std::function<_TyEq(_TyEq)> f_equal = [](auto pf) { auto _24 = _TyEq::_Refl()
;auto _23 = _24; return _23;};

std::function<std::function<_Void(_TyEq)>(uint64_t)> ZnotS = [](auto n) { auto _25 = [](auto r) { auto _26 = _Void(); return _26;}; return _25;};

template <class A> std::function<_TyEq(_TyEq)> sym = [](auto pf) { auto _28 = _TyEq::_Refl()
;auto _27 = _28; return _27;};

template <class t> std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)> negEqSym = [](auto p) { auto _29 = [p](auto h) { auto _32 = h;auto _31 = sym<t>(_32);auto _30 = p(_31); return _30;}; return _29;};

std::function<uint64_t(uint64_t)> pred = [](auto n) { auto _36 = [n]() {auto _37 = n; if ( !_37 ) {auto _38 = (uint64_t)0;return _38; } else {auto m = _37 - 1;auto _38 = m;return _38;} }(); return _36;};

std::function<_TyEq(_TyEq)> succInjective = [](auto p) { auto _40 = p;auto _39 = f_equal<uint64_t,uint64_t>(_40); return _39;};

std::function<std::function<_Dec<_TyEq>(uint64_t)>(uint64_t)> decEqNat = [](auto a) { auto _46 = [a](auto b) { auto _47 = [a,b]() {auto _48 = a; if ( !_48 ) {auto _49 = [a,b]() {auto _50 = b; if ( !_50 ) {auto _52 = _TyEq::_Refl()
;auto _51 = _Dec<_TyEq>::_Yes(_52);return _51; } else {auto n = _50 - 1;auto _54 = n;auto _53 = ZnotS(_54);auto _51 = _Dec<_TyEq>::_No(_53);return _51;} }();return _49; } else {auto n = _48 - 1;auto _49 = [a,b,n]() {auto _55 = b; if ( !_55 ) {auto _62 = n;auto _58 = ZnotS(_62);auto _57 = negEqSym<uint64_t>(_58);auto _56 = _Dec<_TyEq>::_No(_57);return _56; } else {auto m = _55 - 1;auto _56 = [a,b,n,m]() { auto _64 = n;auto _65 = m;auto _63 = decEqNat(_64)(_65); switch (   _63.type) {  case Yes: {auto _67 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_63.data));auto p = _67._1;auto _69 = p;auto _68 = f_equal<uint64_t,uint64_t>(_69);auto _66 = _Dec<_TyEq>::_Yes(_68); return _66;} case No: {auto _76 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_63.data));auto p = _76._1;auto _77 = [a,b,n,m,p](auto h) { auto _80 = h;auto _79 = succInjective(_80);auto _78 = p(_79); return _78;};auto _75 = _Dec<_TyEq>::_No(_77); return _75;}} }();return _56;} }();return _49;} }(); return _47;}; return _46;};
enum _enum_Elem_type {Here,There};template <class a> class _Elem_Here;
template <class a> class _Elem_There;
template <class a> class _Elem { public: enum _enum_Elem_type type; std::shared_ptr<void> data;static _Elem<a> _Here(a _1, _List<a> _2);static _Elem<a> _There(a _1, a _2, _List<a> _3, _Elem<a> _4);_Elem<a>(_enum_Elem_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Elem<a>(const _Elem<a>& other);
_Elem<a>() = default;};template <class a> class _Elem_Here { public: a _1;_List<a> _2;_Elem_Here (a _1, _List<a> _2) {this->_1= _1;this->_2= _2;};_Elem_Here (const _Elem_Here* other) { this->_1= other->_1;this->_2= other->_2;} };template <class a> class _Elem_There { public: a _1;a _2;_List<a> _3;_Elem<a> _4;_Elem_There (a _1, a _2, _List<a> _3, _Elem<a> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_Elem_There (const _Elem_There* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class a>  inline _Elem<a> _Elem<a>::_Here(a _1, _List<a> _2){ return  _Elem<a> ( Here, std::make_shared<_Elem_Here<a>>(_1, _2)); };template <class a>  inline _Elem<a> _Elem<a>::_There(a _1, a _2, _List<a> _3, _Elem<a> _4){ return  _Elem<a> ( There, std::make_shared<_Elem_There<a>>(_1, _2, _3, _4)); };template <class a> _Elem<a>::_Elem(const _Elem<a>& other) { type = other.type; data = other.data; } 

std::function<std::function<std::function<_Void(_Elem<uint64_t>)>(std::function<_Void(_Elem<uint64_t>)>)>(std::function<_Void(_TyEq)>)> neitherHereNorThere = [](auto xneqy) { auto _83 = [xneqy](auto xninxs) { auto _84 = [xneqy,xninxs](auto p) { auto _85 = [p,xneqy,xninxs]() { auto _86 = p; switch (   _86.type) {  case Here: {auto _88 = *(std::static_pointer_cast<_Elem_Here<uint64_t>>(_86.data));auto a = _88._1;auto as = _88._2;auto _89 = _TyEq::_Refl()
;auto _87 = xneqy(_89); return _87;} case There: {auto _91 = *(std::static_pointer_cast<_Elem_There<uint64_t>>(_86.data));auto b = _91._1;auto a = _91._2;auto as = _91._3;auto prf = _91._4;auto _92 = prf;auto _90 = xninxs(_92); return _90;}} }(); return _85;}; return _84;}; return _83;};

std::function<_Void(_Elem<uint64_t>)> xNotElemOfNil = [](auto p) { auto _93 = [p]() { auto _94 = p; return _Void(); }(); return _93;};

std::function<std::function<_Dec<_Elem<uint64_t>>(_List<uint64_t>)>(uint64_t)> isElem = [](auto x) { auto _95 = [x](auto xs) { auto _96 = [xs,x]() { auto _97 = xs; switch (   _97.type) {  case Nil: {auto _99 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_97.data));auto _100 = xNotElemOfNil;auto _98 = _Dec<_Elem<uint64_t>>::_No(_100); return _98;} case Cons: {auto _103 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_97.data));auto y = _103._1;auto ys = _103._2;auto _102 = [xs,x,y,ys]() { auto _105 = x;auto _106 = y;auto _104 = decEqNat(_105)(_106); switch (   _104.type) {  case Yes: {auto _108 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_104.data));auto p = _108._1;auto _110 = y;auto _111 = ys;auto _109 = _Elem<uint64_t>::_Here(_110,_111);auto _107 = _Dec<_Elem<uint64_t>>::_Yes(_109); return _107;} case No: {auto _113 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_104.data));auto xneqy = _113._1;auto _112 = [xs,x,y,ys,xneqy]() { auto _115 = x;auto _116 = ys;auto _114 = isElem(_115)(_116); switch (   _114.type) {  case Yes: {auto _118 = *(std::static_pointer_cast<_Dec_Yes<_Elem<uint64_t>>>(_114.data));auto xinys = _118._1;auto _120 = y;auto _121 = x;auto _122 = ys;auto _123 = xinys;auto _119 = _Elem<uint64_t>::_There(_120,_121,_122,_123);auto _117 = _Dec<_Elem<uint64_t>>::_Yes(_119); return _117;} case No: {auto _125 = *(std::static_pointer_cast<_Dec_No<_Elem<uint64_t>>>(_114.data));auto xninys = _125._1;auto _127 = xneqy;auto _128 = xninys;auto _126 = neitherHereNorThere(_127)(_128);auto _124 = _Dec<_Elem<uint64_t>>::_No(_126); return _124;}} }(); return _112;}} }(); return _102;}} }(); return _96;}; return _95;};

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> plus = [](auto n) {auto _133 = [n](auto m) {return n+m;};return _133;};;

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> mult = [](auto n) {auto _133 = [n](auto m) {return n*m;};return _133;};;

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> minus = [](auto n) {auto _133 = [n](auto m) {return n-m;};return _133;};;

std::function<uint64_t(uint64_t)> fib = [](auto x) { auto _132 = [x]() {auto _133 = x; if ( !_133 ) {auto _134 = (uint64_t)1;return _134; } else {auto y = _133 - 1;auto _134 = [x,y]() {auto _135 = y; if ( !_135 ) {auto _136 = (uint64_t)1;return _136; } else {auto z = _135 - 1;auto _139 = y;auto _137 = fib(_139);auto _140 = z;auto _138 = fib(_140);auto _136 = plus(_137)(_138);return _136;} }();return _134;} }(); return _132;};

std::function<uint64_t(uint64_t)> fact = [](auto n) { auto _141 = [n]() {auto _142 = n; if ( !_142 ) {auto _143 = (uint64_t)1;return _143; } else {auto m = _142 - 1;auto _144 = n;auto _146 = m;auto _145 = fact(_146);auto _143 = mult(_144)(_145);return _143;} }(); return _141;};

template <class A> std::function<std::function<_Vec<A>(_Vec<A>)>(_Vec<A>)> append = [](auto v1) { auto _147 = [v1](auto ys) { auto _148 = [v1,ys]() { auto _149 = v1; switch (   _149.type) {  case ConsV: {auto _151 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_149.data));auto x = _151._1;auto xs = _151._2;auto _152 = x;auto _155 = xs;auto _156 = ys;auto _153 = append<A>(_155)(_156);auto _150 = _Vec<A>::_ConsV(_152,_153); return _150;} case NilV: {auto _161 = *(std::static_pointer_cast<_Vec_NilV<A>>(_149.data));auto _160 = ys; return _160;}} }(); return _148;}; return _147;};

std::function<std::function<_Bool(uint64_t)>(uint64_t)> lte = [](auto left) { auto _162 = [left](auto right) { auto _163 = [left,right]() {auto _164 = left; if ( !_164 ) {auto _165 = _Bool::_True();return _165; } else {auto l = _164 - 1;auto _165 = [left,right,l]() {auto _166 = right; if ( !_166 ) {auto _167 = _Bool::_False();return _167; } else {auto r = _166 - 1;auto _168 = l;auto _169 = r;auto _167 = lte(_168)(_169);return _167;} }();return _165;} }(); return _163;}; return _162;};

std::function<std::function<std::function<uint64_t(uint64_t)>(uint64_t)>(uint64_t)> mod2 = [](auto l) { auto _170 = [l](auto centre) { auto _171 = [l,centre](auto right) { auto _172 = [l,centre,right]() {auto _173 = l; if ( !_173 ) {auto _174 = centre;return _174; } else {auto left = _173 - 1;auto _174 = [l,centre,right,left]() { auto _176 = centre;auto _177 = right;auto _175 = lte(_176)(_177); switch (   _175.type) {  case True: {auto _179 = *(std::static_pointer_cast<_Bool_True>(_175.data));auto _178 = centre; return _178;} case False: {auto _181 = *(std::static_pointer_cast<_Bool_False>(_175.data));auto _182 = left;auto _185 = centre;auto _187 = right;auto _186 = _187 + 1;;auto _183 = minus(_185)(_186);auto _184 = right;auto _180 = mod2(_182)(_183)(_184); return _180;}} }();return _174;} }(); return _172;}; return _171;}; return _170;};

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> modNatNZ = [](auto left) { auto _188 = [left](auto right) { auto _189 = [right,left]() {auto _190 = right; if ( !_190 ) {auto _191 = (uint64_t)0;return _191; } else {auto r = _190 - 1;auto _192 = left;auto _193 = left;auto _194 = r;auto _191 = mod2(_192)(_193)(_194);return _191;} }(); return _189;}; return _188;};

std::function<_Void(_TyEq)> SIsNotZ = [](auto prf) { auto _195 = _Void(); return _195;};

std::function<std::function<uint64_t(uint64_t)>(uint64_t)> gcd = [](auto a) { auto _196 = [a](auto b) { auto _197 = [b,a]() {auto _198 = b; if ( !_198 ) {auto _199 = a;return _199; } else {auto b2 = _198 - 1;auto _199 = [b,a,b2]() {auto _200 = a; if ( !_200 ) {auto _201 = b2;return _201; } else {auto a2 = _200 - 1;auto _204 = b2;auto _202 = _204 + 1;;auto _207 = a2;auto _205 = _207 + 1;;auto _208 = b2;auto _206 = _208 + 1;;auto _203 = modNatNZ(_205)(_206);auto _201 = gcd(_202)(_203);return _201;} }();return _199;} }(); return _197;}; return _196;};

std::function<std::function<_Bool(uint64_t)>(uint64_t)> nat_eq = [](auto x) { auto _209 = [x](auto y) { auto _210 = [x,y]() {auto _211 = x; if ( !_211 ) {auto _212 = [x,y]() {auto _213 = y; if ( !_213 ) {auto _214 = _Bool::_True();return _214; } else {auto n = _213 - 1;auto _214 = _Bool::_False();return _214;} }();return _212; } else {auto m = _211 - 1;auto _212 = [x,y,m]() {auto _215 = y; if ( !_215 ) {auto _216 = _Bool::_False();return _216; } else {auto n = _215 - 1;auto _217 = m;auto _218 = n;auto _216 = nat_eq(_217)(_218);return _216;} }();return _212;} }(); return _210;}; return _209;};

std::function<std::function<_Bool(uint64_t)>(uint64_t)> relPrime = [](auto x) { auto _219 = [x](auto y) { auto _220 = [x,y]() {auto _221 = x; if ( !_221 ) {auto _222 = _Bool::_False();return _222; } else {auto x2 = _221 - 1;auto _227 = x2;auto _225 = _227 + 1;;auto _226 = y;auto _223 = gcd(_225)(_226);auto _224 = (uint64_t)1;auto _222 = nat_eq(_223)(_224);return _222;} }(); return _220;}; return _219;};

std::function<std::function<_List<uint64_t>(uint64_t)>(uint64_t)> mkList = [](auto n) { auto _228 = [n](auto c) { auto _229 = [n,c]() {auto _230 = n; if ( !_230 ) {auto _231 = _List<uint64_t>::_Nil();return _231; } else {auto m = _230 - 1;auto _232 = c;auto _234 = m;auto _236 = c;auto _235 = _236 + 1;;auto _233 = mkList(_234)(_235);auto _231 = _List<uint64_t>::_Cons(_232,_233);return _231;} }(); return _229;}; return _228;};

template <class a> std::function<std::function<_List<a>(_List<a>)>(std::function<_Bool(a)>)> filter = [](auto f) { auto _237 = [f](auto xs) { auto _238 = [xs,f]() { auto _239 = xs; switch (   _239.type) {  case Nil: {auto _241 = *(std::static_pointer_cast<_List_Nil<a>>(_239.data));auto _240 = _List<a>::_Nil(); return _240;} case Cons: {auto _243 = *(std::static_pointer_cast<_List_Cons<a>>(_239.data));auto y = _243._1;auto ys = _243._2;auto _242 = [xs,f,y,ys]() { auto _245 = y;auto _244 = f(_245); switch (   _244.type) {  case True: {auto _247 = *(std::static_pointer_cast<_Bool_True>(_244.data));auto _248 = y;auto _250 = f;auto _251 = ys;auto _249 = filter<a>(_250)(_251);auto _246 = _List<a>::_Cons(_248,_249); return _246;} case False: {auto _254 = *(std::static_pointer_cast<_Bool_False>(_244.data));auto _255 = f;auto _256 = ys;auto _253 = filter<a>(_255)(_256); return _253;}} }(); return _242;}} }(); return _238;}; return _237;};

template <class a> std::function<uint64_t(_List<a>)> length = [](auto xs) { auto _258 = [xs]() { auto _259 = xs; switch (   _259.type) {  case Nil: {auto _261 = *(std::static_pointer_cast<_List_Nil<a>>(_259.data));auto _260 = (uint64_t)0; return _260;} case Cons: {auto _263 = *(std::static_pointer_cast<_List_Cons<a>>(_259.data));auto y = _263._1;auto ys = _263._2;auto _264 = (uint64_t)1;auto _266 = ys;auto _265 = length<a>(_266);auto _262 = plus(_264)(_265); return _262;}} }(); return _258;};

std::function<uint64_t(uint64_t)> euler = [](auto n) { auto _271 = [n](auto x) { auto _275 = n;auto _276 = x;auto _274 = relPrime(_275)(_276); return _274;};auto _277 = n;auto _278 = (uint64_t)0;auto _272 = mkList(_277)(_278);auto _269 = filter<uint64_t>(_271)(_272);auto _268 = length<uint64_t>(_269); return _268;};

std::function<uint64_t(_List<uint64_t>)> sum = [](auto xs) { auto _279 = [xs]() { auto _280 = xs; switch (   _280.type) {  case Nil: {auto _282 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_280.data));auto _281 = (uint64_t)0; return _281;} case Cons: {auto _284 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_280.data));auto x = _284._1;auto xs2 = _284._2;auto _285 = (uint64_t)1;auto _287 = xs2;auto _286 = sum(_287);auto _283 = plus(_285)(_286); return _283;}} }(); return _279;};

std::function<uint64_t(uint64_t)> sumEuler = [](auto n) { auto _290 = euler;auto _294 = n;auto _295 = (uint64_t)0;auto _291 = mkList(_294)(_295);auto _289 = map<uint64_t,uint64_t>(_290)(_291);auto _288 = sum(_289); return _288;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> trans = [](auto pf1) { auto _296 = [pf1](auto pf2) { auto _298 = pf1;auto _297 = _298; return _297;}; return _296;};
enum _enum_ElemVec_type {HereV,ThereV};template <class A> class _ElemVec_HereV;
template <class A> class _ElemVec_ThereV;
template <class A> class _ElemVec { public: enum _enum_ElemVec_type type; std::shared_ptr<void> data;static _ElemVec<A> _HereV(_Vec<A> _1);static _ElemVec<A> _ThereV(_Vec<A> _1, A _2, _ElemVec<A> _3);_ElemVec<A>(_enum_ElemVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_ElemVec<A>(const _ElemVec<A>& other);
_ElemVec<A>() = default;};template <class A> class _ElemVec_HereV { public: _Vec<A> _1;_ElemVec_HereV (_Vec<A> _1) {this->_1= _1;};_ElemVec_HereV (const _ElemVec_HereV* other) { this->_1= other->_1;} };template <class A> class _ElemVec_ThereV { public: _Vec<A> _1;A _2;_ElemVec<A> _3;_ElemVec_ThereV (_Vec<A> _1, A _2, _ElemVec<A> _3) {this->_1= _1;this->_2= _2;this->_3= _3;};_ElemVec_ThereV (const _ElemVec_ThereV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;} };template <class A>  inline _ElemVec<A> _ElemVec<A>::_HereV(_Vec<A> _1){ return  _ElemVec<A> ( HereV, std::make_shared<_ElemVec_HereV<A>>(_1)); };template <class A>  inline _ElemVec<A> _ElemVec<A>::_ThereV(_Vec<A> _1, A _2, _ElemVec<A> _3){ return  _ElemVec<A> ( ThereV, std::make_shared<_ElemVec_ThereV<A>>(_1, _2, _3)); };template <class A> _ElemVec<A>::_ElemVec(const _ElemVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Void(_ElemVec<A>)> xNotInNilV = [](auto p) { auto _299 = [p]() { auto _300 = p; return _Void(); }(); return _299;};

std::function<std::function<std::function<_Void(_ElemVec<uint64_t>)>(std::function<_Void(_ElemVec<uint64_t>)>)>(std::function<_Void(_TyEq)>)> neitherHereNorThereVec = [](auto xneqy) { auto _301 = [xneqy](auto xninxs) { auto _302 = [xneqy,xninxs](auto p) { auto _303 = [p,xneqy,xninxs]() { auto _304 = p; switch (   _304.type) {  case HereV: {auto _306 = *(std::static_pointer_cast<_ElemVec_HereV<uint64_t>>(_304.data));auto as = _306._1;auto _307 = _TyEq::_Refl()
;auto _305 = xneqy(_307); return _305;} case ThereV: {auto _309 = *(std::static_pointer_cast<_ElemVec_ThereV<uint64_t>>(_304.data));auto as = _309._1;auto b = _309._2;auto prf = _309._3;auto _310 = prf;auto _308 = xninxs(_310); return _308;}} }(); return _303;}; return _302;}; return _301;};

std::function<std::function<_Dec<_ElemVec<uint64_t>>(_Vec<uint64_t>)>(uint64_t)> isElemVec = [](auto x) { auto _311 = [x](auto xs) { auto _312 = [xs,x]() { auto _313 = xs; switch (   _313.type) {  case NilV: {auto _315 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_313.data));auto _316 = xNotInNilV<uint64_t>;auto _314 = _Dec<_ElemVec<uint64_t>>::_No(_316); return _314;} case ConsV: {auto _321 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_313.data));auto y = _321._1;auto ys = _321._2;auto _320 = [xs,x,y,ys]() { auto _323 = x;auto _324 = y;auto _322 = decEqNat(_323)(_324); switch (   _322.type) {  case Yes: {auto _326 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_322.data));auto pf = _326._1;auto _329 = ys;auto _328 = _ElemVec<uint64_t>::_HereV(_329);auto _327 = _328;auto _325 = _Dec<_ElemVec<uint64_t>>::_Yes(_327); return _325;} case No: {auto _332 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_322.data));auto xneqyPf = _332._1;auto _331 = [xs,x,y,ys,xneqyPf]() { auto _334 = x;auto _335 = ys;auto _333 = isElemVec(_334)(_335); switch (   _333.type) {  case Yes: {auto _338 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_333.data));auto pf = _338._1;auto _340 = ys;auto _341 = x;auto _342 = pf;auto _339 = _ElemVec<uint64_t>::_ThereV(_340,_341,_342);auto _337 = _Dec<_ElemVec<uint64_t>>::_Yes(_339); return _337;} case No: {auto _345 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_333.data));auto xninysPf = _345._1;auto _347 = xneqyPf;auto _348 = xninysPf;auto _346 = neitherHereNorThereVec(_347)(_348);auto _344 = _Dec<_ElemVec<uint64_t>>::_No(_346); return _344;}} }(); return _331;}} }(); return _320;}} }(); return _312;}; return _311;};
enum _enum_Disjoint_type {DNil,DCons};template <class A> class _Disjoint_DNil;
template <class A> class _Disjoint_DCons;
template <class A> class _Disjoint { public: enum _enum_Disjoint_type type; std::shared_ptr<void> data;static _Disjoint<A> _DNil();static _Disjoint<A> _DCons(A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4);_Disjoint<A>(_enum_Disjoint_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Disjoint<A>(const _Disjoint<A>& other);
_Disjoint<A>() = default;};template <class A> class _Disjoint_DNil { public: _Disjoint_DNil () {};_Disjoint_DNil (const _Disjoint_DNil* other) { } };template <class A> class _Disjoint_DCons { public: A _1;_List<A> _2;std::function<_Void(_Elem<A>)> _3;_Disjoint<A> _4;_Disjoint_DCons (A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_Disjoint_DCons (const _Disjoint_DCons* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _Disjoint<A> _Disjoint<A>::_DNil(){ return  _Disjoint<A> ( DNil, std::make_shared<_Disjoint_DNil<A>>()); };template <class A>  inline _Disjoint<A> _Disjoint<A>::_DCons(A _1, _List<A> _2, std::function<_Void(_Elem<A>)> _3, _Disjoint<A> _4){ return  _Disjoint<A> ( DCons, std::make_shared<_Disjoint_DCons<A>>(_1, _2, _3, _4)); };template <class A> _Disjoint<A>::_Disjoint(const _Disjoint<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Void(_Elem<A>)> xNotInNil = [](auto p) { auto _353 = [p]() { auto _354 = p; return _Void(); }(); return _353;};

template <class A> std::function<std::function<_Disjoint<A>(_TyEq)>(_List<A>)> lemma_y_empty_disjoint = [](auto a) { auto _355 = [a](auto pf) { auto _356 = [a,pf]() { auto _357 = a; switch (   _357.type) {  case Nil: {auto _359 = *(std::static_pointer_cast<_List_Nil<A>>(_357.data));auto _358 = _Disjoint<A>::_DNil(); return _358;} case Cons: {auto _361 = *(std::static_pointer_cast<_List_Cons<A>>(_357.data));auto x = _361._1;auto xs = _361._2;auto _362 = x;auto _363 = xs;auto _366 = xNotInNil<A>;auto _364 = _366;auto _369 = xs;auto _370 = pf;auto _365 = lemma_y_empty_disjoint<A>(_369)(_370);auto _360 = _Disjoint<A>::_DCons(_362,_363,_364,_365); return _360;}} }(); return _356;}; return _355;};

template <class A> std::function<std::function<_Void(_Disjoint<A>)>(_Elem<A>)> lemma_x_in_b = [](auto xInB) { auto _373 = [xInB](auto pf) { auto _374 = [pf,xInB]() { auto _375 = pf; switch (   _375.type) {  case DCons: {auto _377 = *(std::static_pointer_cast<_Disjoint_DCons<A>>(_375.data));auto i = _377._1;auto is = _377._2;auto pfFori = _377._3;auto others = _377._4;auto _378 = xInB;auto _376 = pfFori(_378); return _376;}} }(); return _374;}; return _373;};

template <class A> std::function<std::function<_Void(_Disjoint<A>)>(std::function<_Void(_Disjoint<A>)>)> lemma_xs_in_b = [](auto pf) { auto _379 = [pf](auto p) { auto _380 = [p,pf]() { auto _381 = p; switch (   _381.type) {  case DCons: {auto _383 = *(std::static_pointer_cast<_Disjoint_DCons<A>>(_381.data));auto i = _383._1;auto is = _383._2;auto pfFori = _383._3;auto others = _383._4;auto _384 = others;auto _382 = pf(_384); return _382;}} }(); return _380;}; return _379;};

std::function<std::function<_Dec<_Disjoint<uint64_t>>(_List<uint64_t>)>(_List<uint64_t>)> decDisjointLists = [](auto a) { auto _385 = [a](auto b) { auto _386 = [a,b]() { auto _387 = a; switch (   _387.type) {  case Nil: {auto _389 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_387.data));auto _390 = _Disjoint<uint64_t>::_DNil();auto _388 = _Dec<_Disjoint<uint64_t>>::_Yes(_390); return _388;} case Cons: {auto _392 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_387.data));auto x = _392._1;auto xs = _392._2;auto _391 = [a,b,xs,x]() { auto _393 = b; switch (   _393.type) {  case Nil: {auto _395 = *(std::static_pointer_cast<_List_Nil<uint64_t>>(_393.data));auto _397 = a;auto _398 = _TyEq::_Refl()
;auto _396 = lemma_y_empty_disjoint<uint64_t>(_397)(_398);auto _394 = _Dec<_Disjoint<uint64_t>>::_Yes(_396); return _394;} case Cons: {auto _402 = *(std::static_pointer_cast<_List_Cons<uint64_t>>(_393.data));auto y = _402._1;auto ys = _402._2;auto _401 = [a,b,xs,x]() { auto _404 = xs;auto _405 = b;auto _403 = decDisjointLists(_404)(_405); switch (   _403.type) {  case Yes: {auto _407 = *(std::static_pointer_cast<_Dec_Yes<_Disjoint<uint64_t>>>(_403.data));auto pf = _407._1;auto _406 = [a,b,xs,x,pf]() { auto _409 = x;auto _410 = b;auto _408 = isElem(_409)(_410); switch (   _408.type) {  case Yes: {auto _412 = *(std::static_pointer_cast<_Dec_Yes<_Elem<uint64_t>>>(_408.data));auto elemPf = _412._1;auto _414 = elemPf;auto _413 = lemma_x_in_b<uint64_t>(_414);auto _411 = _Dec<_Disjoint<uint64_t>>::_No(_413); return _411;} case No: {auto _421 = *(std::static_pointer_cast<_Dec_No<_Elem<uint64_t>>>(_408.data));auto p = _421._1;auto _423 = x;auto _424 = xs;auto _425 = p;auto _426 = pf;auto _422 = _Disjoint<uint64_t>::_DCons(_423,_424,_425,_426);auto _420 = _Dec<_Disjoint<uint64_t>>::_Yes(_422); return _420;}} }(); return _406;} case No: {auto _428 = *(std::static_pointer_cast<_Dec_No<_Disjoint<uint64_t>>>(_403.data));auto p = _428._1;auto _430 = p;auto _429 = lemma_xs_in_b<uint64_t>(_430);auto _427 = _Dec<_Disjoint<uint64_t>>::_No(_429); return _427;}} }(); return _401;}} }(); return _391;}} }(); return _386;}; return _385;};
enum _enum_DisjointVec_type {DNilV,DConsV};template <class A> class _DisjointVec_DNilV;
template <class A> class _DisjointVec_DConsV;
template <class A> class _DisjointVec { public: enum _enum_DisjointVec_type type; std::shared_ptr<void> data;static _DisjointVec<A> _DNilV();static _DisjointVec<A> _DConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4);_DisjointVec<A>(_enum_DisjointVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_DisjointVec<A>(const _DisjointVec<A>& other);
_DisjointVec<A>() = default;};template <class A> class _DisjointVec_DNilV { public: _DisjointVec_DNilV () {};_DisjointVec_DNilV (const _DisjointVec_DNilV* other) { } };template <class A> class _DisjointVec_DConsV { public: A _1;_Vec<A> _2;std::function<_Void(_ElemVec<A>)> _3;_DisjointVec<A> _4;_DisjointVec_DConsV (A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_DisjointVec_DConsV (const _DisjointVec_DConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _DisjointVec<A> _DisjointVec<A>::_DNilV(){ return  _DisjointVec<A> ( DNilV, std::make_shared<_DisjointVec_DNilV<A>>()); };template <class A>  inline _DisjointVec<A> _DisjointVec<A>::_DConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _DisjointVec<A> _4){ return  _DisjointVec<A> ( DConsV, std::make_shared<_DisjointVec_DConsV<A>>(_1, _2, _3, _4)); };template <class A> _DisjointVec<A>::_DisjointVec(const _DisjointVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_DisjointVec<A>(_TyEq)>(_Vec<A>)> lemma_y_empty_disjoint_vec = [](auto a) { auto _435 = [a](auto pf) { auto _436 = [a,pf]() { auto _437 = a; switch (   _437.type) {  case NilV: {auto _439 = *(std::static_pointer_cast<_Vec_NilV<A>>(_437.data));auto _438 = _DisjointVec<A>::_DNilV(); return _438;} case ConsV: {auto _441 = *(std::static_pointer_cast<_Vec_ConsV<A>>(_437.data));auto x = _441._1;auto xs = _441._2;auto _442 = x;auto _443 = xs;auto _447 = xNotInNilV<A>;auto _444 = _447;auto _451 = xs;auto _452 = pf;auto _445 = lemma_y_empty_disjoint_vec<A>(_451)(_452);auto _440 = _DisjointVec<A>::_DConsV(_442,_443,_444,_445); return _440;}} }(); return _436;}; return _435;};

template <class A> std::function<std::function<_Void(_DisjointVec<A>)>(_ElemVec<A>)> lemma_x_in_b_vec = [](auto xInB) { auto _456 = [xInB](auto pf) { auto _457 = [pf,xInB]() { auto _458 = pf; switch (   _458.type) {  case DConsV: {auto _460 = *(std::static_pointer_cast<_DisjointVec_DConsV<A>>(_458.data));auto y = _460._1;auto ys = _460._2;auto pfFory = _460._3;auto others = _460._4;auto _461 = xInB;auto _459 = pfFory(_461); return _459;}} }(); return _457;}; return _456;};

template <class A> std::function<std::function<_Void(_DisjointVec<A>)>(std::function<_Void(_DisjointVec<A>)>)> lemma_xs_in_b_vec = [](auto pf) { auto _462 = [pf](auto p) { auto _463 = [p,pf]() { auto _464 = p; switch (   _464.type) {  case DConsV: {auto _466 = *(std::static_pointer_cast<_DisjointVec_DConsV<A>>(_464.data));auto i = _466._1;auto is = _466._2;auto pfFori = _466._3;auto others = _466._4;auto _467 = others;auto _465 = pf(_467); return _465;}} }(); return _463;}; return _462;};

std::function<std::function<_Dec<_DisjointVec<uint64_t>>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decDisjointVecs = [](auto a) { auto _468 = [a](auto b) { auto _469 = [a,b]() { auto _470 = a; switch (   _470.type) {  case NilV: {auto _472 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_470.data));auto _473 = _DisjointVec<uint64_t>::_DNilV();auto _471 = _Dec<_DisjointVec<uint64_t>>::_Yes(_473); return _471;} case ConsV: {auto _475 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_470.data));auto x = _475._1;auto xs = _475._2;auto _474 = [a,b,xs,x]() { auto _476 = b; switch (   _476.type) {  case NilV: {auto _478 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_476.data));auto _480 = a;auto _481 = _TyEq::_Refl()
;auto _479 = lemma_y_empty_disjoint_vec<uint64_t>(_480)(_481);auto _477 = _Dec<_DisjointVec<uint64_t>>::_Yes(_479); return _477;} case ConsV: {auto _486 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_476.data));auto y = _486._1;auto ys = _486._2;auto _485 = [a,b,xs,x]() { auto _488 = xs;auto _489 = b;auto _487 = decDisjointVecs(_488)(_489); switch (   _487.type) {  case Yes: {auto _493 = *(std::static_pointer_cast<_Dec_Yes<_DisjointVec<uint64_t>>>(_487.data));auto pf = _493._1;auto _492 = [a,b,xs,x,pf]() { auto _495 = x;auto _496 = b;auto _494 = isElemVec(_495)(_496); switch (   _494.type) {  case Yes: {auto _499 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_494.data));auto elemPf = _499._1;auto _501 = elemPf;auto _500 = lemma_x_in_b_vec<uint64_t>(_501);auto _498 = _Dec<_DisjointVec<uint64_t>>::_No(_500); return _498;} case No: {auto _510 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_494.data));auto p = _510._1;auto _512 = x;auto _513 = xs;auto _514 = p;auto _515 = pf;auto _511 = _DisjointVec<uint64_t>::_DConsV(_512,_513,_514,_515);auto _509 = _Dec<_DisjointVec<uint64_t>>::_Yes(_511); return _509;}} }(); return _492;} case No: {auto _518 = *(std::static_pointer_cast<_Dec_No<_DisjointVec<uint64_t>>>(_487.data));auto p = _518._1;auto _520 = p;auto _519 = lemma_xs_in_b_vec<uint64_t>(_520);auto _517 = _Dec<_DisjointVec<uint64_t>>::_No(_519); return _517;}} }(); return _485;}} }(); return _474;}} }(); return _469;}; return _468;};

std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjLem = [](auto prf1) { auto _527 = [](auto prf2) { auto _530 = prf2;auto _529 = f_equal<_Vec<uint64_t>,_Vec<uint64_t>>(_530);auto _528 = _529; return _528;}; return _527;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjective = [](auto p1) { auto _536 = [](auto p2) { auto _539 = p2;auto _538 = f_equal<_Vec<A>,_Vec<A>>(_539);auto _537 = _538; return _537;}; return _536;};

template <class A> std::function<std::function<_TyEq(_TyEq)>(_TyEq)> consVInjectiveTail = [](auto p1) { auto _545 = [](auto p2) { auto _547 = p2;auto _546 = f_equal<_Vec<A>,A>(_547); return _546;}; return _545;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)>(_TyEq)> lemma_x_eq_xs_neq_vec = [](auto prf1) { auto _553 = [prf1](auto p) { auto _554 = [p,prf1](auto prf2) { auto _557 = prf1;auto _558 = prf2;auto _556 = consVInjective<A>(_557)(_558);auto _555 = p(_556); return _555;}; return _554;}; return _553;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(_TyEq)>(std::function<_Void(_TyEq)>)> lemma_x_neq_xs_eq_vec = [](auto p) { auto _565 = [p](auto p2) { auto _566 = [p,p2](auto p3) { auto _569 = p2;auto _570 = p3;auto _568 = consVInjectiveTail<A>(_569)(_570);auto _567 = p(_568); return _567;}; return _566;}; return _565;};

template <class A> std::function<std::function<std::function<_Void(_TyEq)>(std::function<_Void(_TyEq)>)>(std::function<_Void(_TyEq)>)> lemma_x_neq_xs_neq_vec = [](auto p) { auto _577 = [p](auto p2) { auto _578 = [p](auto p3) { auto _581 = p3;auto _580 = f_equal<_Vec<A>,A>(_581);auto _579 = p(_580); return _579;}; return _578;}; return _577;};

std::function<std::function<_Dec<_TyEq>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decEqVec = [](auto a) { auto _587 = [a](auto b) { auto _588 = [a,b]() { auto _589 = a; switch (   _589.type) {  case NilV: {auto _591 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_589.data));auto _590 = [a,b]() { auto _592 = b; switch (   _592.type) {  case NilV: {auto _594 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_592.data));auto _595 = _TyEq::_Refl()
;auto _593 = _Dec<_TyEq>::_Yes(_595); return _593;}} }(); return _590;} case ConsV: {auto _597 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_589.data));auto x = _597._1;auto xs = _597._2;auto _596 = [a,b,x,xs]() { auto _598 = b; switch (   _598.type) {  case ConsV: {auto _600 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_598.data));auto y = _600._1;auto ys = _600._2;auto _599 = [a,b,x,y,xs,ys]() { auto _602 = x;auto _603 = y;auto _601 = decEqNat(_602)(_603); switch (   _601.type) {  case Yes: {auto _605 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_601.data));auto xeqy = _605._1;auto _604 = [a,b,x,y,xs,ys,xeqy]() { auto _607 = xs;auto _608 = ys;auto _606 = decEqVec(_607)(_608); switch (   _606.type) {  case Yes: {auto _611 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_606.data));auto xseqys = _611._1;auto _613 = xeqy;auto _614 = xseqys;auto _612 = consVInjLem(_613)(_614);auto _610 = _Dec<_TyEq>::_Yes(_612); return _610;} case No: {auto _621 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_606.data));auto xsneqys = _621._1;auto _623 = xeqy;auto _624 = xsneqys;auto _622 = lemma_x_eq_xs_neq_vec<uint64_t>(_623)(_624);auto _620 = _Dec<_TyEq>::_No(_622); return _620;}} }(); return _604;} case No: {auto _632 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_601.data));auto xneqy = _632._1;auto _631 = [a,b,x,y,xs,ys,xneqy]() { auto _634 = xs;auto _635 = ys;auto _633 = decEqVec(_634)(_635); switch (   _633.type) {  case Yes: {auto _638 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_633.data));auto xseqys = _638._1;auto _640 = xneqy;auto _641 = xseqys;auto _639 = lemma_x_neq_xs_eq_vec<uint64_t>(_640)(_641);auto _637 = _Dec<_TyEq>::_No(_639); return _637;} case No: {auto _649 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_633.data));auto xsneqys = _649._1;auto _651 = xneqy;auto _652 = xsneqys;auto _650 = lemma_x_neq_xs_neq_vec<uint64_t>(_651)(_652);auto _648 = _Dec<_TyEq>::_No(_650); return _648;}} }(); return _631;}} }(); return _599;}} }(); return _596;}} }(); return _588;}; return _587;};
enum _enum_UniqueVec_type {UNilV,UConsV};template <class A> class _UniqueVec_UNilV;
template <class A> class _UniqueVec_UConsV;
template <class A> class _UniqueVec { public: enum _enum_UniqueVec_type type; std::shared_ptr<void> data;static _UniqueVec<A> _UNilV();static _UniqueVec<A> _UConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4);_UniqueVec<A>(_enum_UniqueVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_UniqueVec<A>(const _UniqueVec<A>& other);
_UniqueVec<A>() = default;};template <class A> class _UniqueVec_UNilV { public: _UniqueVec_UNilV () {};_UniqueVec_UNilV (const _UniqueVec_UNilV* other) { } };template <class A> class _UniqueVec_UConsV { public: A _1;_Vec<A> _2;std::function<_Void(_ElemVec<A>)> _3;_UniqueVec<A> _4;_UniqueVec_UConsV (A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_UniqueVec_UConsV (const _UniqueVec_UConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _UniqueVec<A> _UniqueVec<A>::_UNilV(){ return  _UniqueVec<A> ( UNilV, std::make_shared<_UniqueVec_UNilV<A>>()); };template <class A>  inline _UniqueVec<A> _UniqueVec<A>::_UConsV(A _1, _Vec<A> _2, std::function<_Void(_ElemVec<A>)> _3, _UniqueVec<A> _4){ return  _UniqueVec<A> ( UConsV, std::make_shared<_UniqueVec_UConsV<A>>(_1, _2, _3, _4)); };template <class A> _UniqueVec<A>::_UniqueVec(const _UniqueVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_Void(_UniqueVec<A>)>(_ElemVec<A>)> lemma_x_in_xs_not_unique = [](auto pf) { auto _659 = [pf](auto p) { auto _660 = [p,pf]() { auto _661 = p; switch (   _661.type) {  case UConsV: {auto _663 = *(std::static_pointer_cast<_UniqueVec_UConsV<A>>(_661.data));auto x = _663._1;auto xs = _663._2;auto xNInXs = _663._3;auto others = _663._4;auto _664 = pf;auto _662 = xNInXs(_664); return _662;}} }(); return _660;}; return _659;};

template <class A> std::function<std::function<_Void(_UniqueVec<A>)>(std::function<_Void(_UniqueVec<A>)>)> lemma_xs_not_unique = [](auto pf) { auto _665 = [pf](auto p) { auto _666 = [p,pf]() { auto _667 = p; switch (   _667.type) {  case UConsV: {auto _669 = *(std::static_pointer_cast<_UniqueVec_UConsV<A>>(_667.data));auto x = _669._1;auto xs = _669._2;auto xNInXs = _669._3;auto others = _669._4;auto _670 = others;auto _668 = pf(_670); return _668;}} }(); return _666;}; return _665;};

std::function<_Dec<_UniqueVec<uint64_t>>(_Vec<uint64_t>)> decUniqueVec = [](auto v) { auto _671 = [v]() { auto _672 = v; switch (   _672.type) {  case NilV: {auto _674 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_672.data));auto _675 = _UniqueVec<uint64_t>::_UNilV();auto _673 = _Dec<_UniqueVec<uint64_t>>::_Yes(_675); return _673;} case ConsV: {auto _677 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_672.data));auto x = _677._1;auto xs = _677._2;auto _676 = [v,x,xs]() { auto _679 = x;auto _680 = xs;auto _678 = isElemVec(_679)(_680); switch (   _678.type) {  case Yes: {auto _683 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_678.data));auto xInXs = _683._1;auto _685 = xInXs;auto _684 = lemma_x_in_xs_not_unique<uint64_t>(_685);auto _682 = _Dec<_UniqueVec<uint64_t>>::_No(_684); return _682;} case No: {auto _691 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_678.data));auto xNInXs = _691._1;auto _690 = [v,x,xs,xNInXs]() { auto _693 = xs;auto _692 = decUniqueVec(_693); switch (   _692.type) {  case Yes: {auto _696 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_692.data));auto xsU = _696._1;auto _698 = x;auto _699 = xs;auto _700 = xNInXs;auto _701 = xsU;auto _697 = _UniqueVec<uint64_t>::_UConsV(_698,_699,_700,_701);auto _695 = _Dec<_UniqueVec<uint64_t>>::_Yes(_697); return _695;} case No: {auto _704 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_692.data));auto xsNU = _704._1;auto _706 = xsNU;auto _705 = lemma_xs_not_unique<uint64_t>(_706);auto _703 = _Dec<_UniqueVec<uint64_t>>::_No(_705); return _703;}} }(); return _690;}} }(); return _676;}} }(); return _671;};
enum _enum_SubsetVec_type {SNilV1,SNilV2,SConsV};template <class A> class _SubsetVec_SNilV1;
template <class A> class _SubsetVec_SNilV2;
template <class A> class _SubsetVec_SConsV;
template <class A> class _SubsetVec { public: enum _enum_SubsetVec_type type; std::shared_ptr<void> data;static _SubsetVec<A> _SNilV1();static _SubsetVec<A> _SNilV2();static _SubsetVec<A> _SConsV(A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4);_SubsetVec<A>(_enum_SubsetVec_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_SubsetVec<A>(const _SubsetVec<A>& other);
_SubsetVec<A>() = default;};template <class A> class _SubsetVec_SNilV1 { public: _SubsetVec_SNilV1 () {};_SubsetVec_SNilV1 (const _SubsetVec_SNilV1* other) { } };template <class A> class _SubsetVec_SNilV2 { public: _SubsetVec_SNilV2 () {};_SubsetVec_SNilV2 (const _SubsetVec_SNilV2* other) { } };template <class A> class _SubsetVec_SConsV { public: A _1;_Vec<A> _2;_ElemVec<A> _3;_SubsetVec<A> _4;_SubsetVec_SConsV (A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4) {this->_1= _1;this->_2= _2;this->_3= _3;this->_4= _4;};_SubsetVec_SConsV (const _SubsetVec_SConsV* other) { this->_1= other->_1;this->_2= other->_2;this->_3= other->_3;this->_4= other->_4;} };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SNilV1(){ return  _SubsetVec<A> ( SNilV1, std::make_shared<_SubsetVec_SNilV1<A>>()); };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SNilV2(){ return  _SubsetVec<A> ( SNilV2, std::make_shared<_SubsetVec_SNilV2<A>>()); };template <class A>  inline _SubsetVec<A> _SubsetVec<A>::_SConsV(A _1, _Vec<A> _2, _ElemVec<A> _3, _SubsetVec<A> _4){ return  _SubsetVec<A> ( SConsV, std::make_shared<_SubsetVec_SConsV<A>>(_1, _2, _3, _4)); };template <class A> _SubsetVec<A>::_SubsetVec(const _SubsetVec<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<_Void(_SubsetVec<A>)>(std::function<_Void(_ElemVec<A>)>)> lemma_x_not_in_b_vec = [](auto pfXNotInb) { auto _711 = [pfXNotInb](auto pf) { auto _712 = [pf,pfXNotInb]() { auto _713 = pf; switch (   _713.type) {  case SConsV: {auto _715 = *(std::static_pointer_cast<_SubsetVec_SConsV<A>>(_713.data));auto a = _715._1;auto as = _715._2;auto pfFora = _715._3;auto others = _715._4;auto _716 = pfFora;auto _714 = pfXNotInb(_716); return _714;}} }(); return _712;}; return _711;};

template <class A> std::function<std::function<_Void(_SubsetVec<A>)>(std::function<_Void(_SubsetVec<A>)>)> lemma_xs_not_subset_b_vec = [](auto xsNotSubsetPf) { auto _717 = [xsNotSubsetPf](auto p) { auto _718 = [p,xsNotSubsetPf]() { auto _719 = p; switch (   _719.type) {  case SConsV: {auto _721 = *(std::static_pointer_cast<_SubsetVec_SConsV<A>>(_719.data));auto a = _721._1;auto as = _721._2;auto pfFora = _721._3;auto others = _721._4;auto _722 = others;auto _720 = xsNotSubsetPf(_722); return _720;}} }(); return _718;}; return _717;};

std::function<std::function<_Dec<_SubsetVec<uint64_t>>(_Vec<uint64_t>)>(_Vec<uint64_t>)> decSubsetVecs = [](auto a) { auto _723 = [a](auto b) { auto _724 = [a,b]() { auto _725 = a; switch (   _725.type) {  case NilV: {auto _727 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_725.data));auto _728 = _SubsetVec<uint64_t>::_SNilV1();auto _726 = _Dec<_SubsetVec<uint64_t>>::_Yes(_728); return _726;} case ConsV: {auto _730 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_725.data));auto x = _730._1;auto xs = _730._2;auto _729 = [a,b,xs,x]() { auto _731 = b; switch (   _731.type) {  case NilV: {auto _733 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_731.data));auto _734 = _SubsetVec<uint64_t>::_SNilV2();auto _732 = _Dec<_SubsetVec<uint64_t>>::_Yes(_734); return _732;} case ConsV: {auto _736 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_731.data));auto y = _736._1;auto ys = _736._2;auto _735 = [a,b,xs,x]() { auto _738 = xs;auto _739 = b;auto _737 = decSubsetVecs(_738)(_739); switch (   _737.type) {  case Yes: {auto _743 = *(std::static_pointer_cast<_Dec_Yes<_SubsetVec<uint64_t>>>(_737.data));auto pf = _743._1;auto _742 = [a,b,xs,x,pf]() { auto _745 = x;auto _746 = b;auto _744 = isElemVec(_745)(_746); switch (   _744.type) {  case Yes: {auto _749 = *(std::static_pointer_cast<_Dec_Yes<_ElemVec<uint64_t>>>(_744.data));auto elemPf = _749._1;auto _751 = x;auto _752 = xs;auto _753 = elemPf;auto _754 = pf;auto _750 = _SubsetVec<uint64_t>::_SConsV(_751,_752,_753,_754);auto _748 = _Dec<_SubsetVec<uint64_t>>::_Yes(_750); return _748;} case No: {auto _757 = *(std::static_pointer_cast<_Dec_No<_ElemVec<uint64_t>>>(_744.data));auto p = _757._1;auto _759 = p;auto _758 = lemma_x_not_in_b_vec<uint64_t>(_759);auto _756 = _Dec<_SubsetVec<uint64_t>>::_No(_758); return _756;}} }(); return _742;} case No: {auto _768 = *(std::static_pointer_cast<_Dec_No<_SubsetVec<uint64_t>>>(_737.data));auto p = _768._1;auto _770 = p;auto _769 = lemma_xs_not_subset_b_vec<uint64_t>(_770);auto _767 = _Dec<_SubsetVec<uint64_t>>::_No(_769); return _767;}} }(); return _735;}} }(); return _729;}} }(); return _724;}; return _723;};
enum _enum_IO_type {MkIO};template <class A> class _IO_MkIO;
template <class A> class _IO { public: enum _enum_IO_type type; std::shared_ptr<void> data;static _IO<A> _MkIO(A _1);_IO<A>(_enum_IO_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_IO<A>(const _IO<A>& other);
_IO<A>() = default;};template <class A> class _IO_MkIO { public: A _1;_IO_MkIO (A _1) {this->_1= _1;};_IO_MkIO (const _IO_MkIO* other) { this->_1= other->_1;} };template <class A>  inline _IO<A> _IO<A>::_MkIO(A _1){ return  _IO<A> ( MkIO, std::make_shared<_IO_MkIO<A>>(_1)); };template <class A> _IO<A>::_IO(const _IO<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_IO<A>(A)> returnIO = [](auto a) { auto _779 = a;auto _778 = _IO<A>::_MkIO(_779); return _778;};

template <class A,class B> std::function<std::function<_IO<B>(std::function<_IO<B>(A)>)>(_IO<A>)> bindEq = [](auto a) { auto _780 = [a](auto f) { auto _781 = [a,f]() { auto _782 = a; switch (   _782.type) {  case MkIO: {auto _784 = *(std::static_pointer_cast<_IO_MkIO<A>>(_782.data));auto inner = _784._1;auto _785 = inner;auto _783 = f(_785); return _783;}} }(); return _781;}; return _780;};

template <class A,class B> std::function<std::function<_IO<B>(_IO<B>)>(_IO<A>)> bind = [](auto a) { auto _786 = [a](auto b) { auto _788 = a;auto _789 = [a,b](auto c) { auto _792 = b; return _792;};auto _787 = bindEq<A,B>(_788)(_789); return _787;}; return _786;};

std::function<_IO<_Unit>(_List<char>)> print = [](auto l) {auto _653 = [l]() {auto _654 = l;switch (_654.type) {case Nil: {std::cout << "\n" << std::flush;return returnIO<_Unit>(_Unit::_unit());}case Cons: {auto _660 = *(std::static_pointer_cast<_List_Cons<char>>(_654.data));auto c = _660._1;auto cs = _660._2;std::cout << c;return print(cs);}}}();return _653;};

std::function<_IO<_Unit>(_List<_List<char>>)> printList = [](auto l) { auto _793 = [l]() { auto _794 = l; switch (   _794.type) {  case Nil: {auto _796 = *(std::static_pointer_cast<_List_Nil<_List<char>>>(_794.data));auto _797 = _Unit::_unit();auto _795 = returnIO<_Unit>(_797); return _795;} case Cons: {auto _800 = *(std::static_pointer_cast<_List_Cons<_List<char>>>(_794.data));auto x = _800._1;auto xs = _800._2;auto _805 = x;auto _801 = print(_805);auto _806 = xs;auto _802 = printList(_806);auto _799 = bind<_Unit,_Unit>(_801)(_802); return _799;}} }(); return _793;};
enum _enum_Channel_type {MkChannel};template <class A> class _Channel_MkChannel;
template <class A> class _Channel { public: enum _enum_Channel_type type; std::shared_ptr<void> data;static _Channel<A> _MkChannel(uint64_t _1);_Channel<A>(_enum_Channel_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Channel<A>(const _Channel<A>& other);
_Channel<A>() = default;};template <class A> class _Channel_MkChannel { public: uint64_t _1;_Channel_MkChannel (uint64_t _1) {this->_1= _1;};_Channel_MkChannel (const _Channel_MkChannel* other) { this->_1= other->_1;} };template <class A>  inline _Channel<A> _Channel<A>::_MkChannel(uint64_t _1){ return  _Channel<A> ( MkChannel, std::make_shared<_Channel_MkChannel<A>>(_1)); };template <class A> _Channel<A>::_Channel(const _Channel<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<_Bool(uint64_t)> prim_create_channel = [](auto id) {LockingCQueue<_Maybe<A>>* q = new LockingCQueue<_Maybe<A>>();addChannel(id, q);return _Bool::_True();};

template <class A> std::function<std::function<std::function<_IO<_Unit>(_Channel<A>)>(_Maybe<A>)>(uint64_t)> channelEnqueue = [](auto id) {auto _629 = [id](auto x) {auto _630 = [id, x](auto ch) {LockingCQueue<_Maybe<A>>* queue = (LockingCQueue<_Maybe<A>>*)getChannel(id);queue->enqueue(x);auto _632 = _Unit::_unit();auto _631 = returnIO<_Unit>(_632);return _631;};return _630;};return _629;};;

template <class A> std::function<std::function<_IO<_Maybe<A>>(_Channel<A>)>(uint64_t)> channelDequeue = [](auto id) {auto _630 = [id](auto ch) {LockingCQueue<_Maybe<A>>* queue = (LockingCQueue<_Maybe<A>>*)getChannel(id);auto result = queue->dequeue();auto _631 = returnIO<_Maybe<A>>(result);return _631;};return _630;};;

_IO<_Unit> end = []() {auto _631 = _Unit::_unit();auto _630 = returnIO<_Unit>(_631);return _630;}();

template <class A> std::function<std::function<std::function<_IO<_Unit>(_Channel<A>)>(_Maybe<A>)>(uint64_t)> send = [](auto id) { auto _807 = [id](auto x) { auto _808 = [id,x](auto ch) { auto _810 = id;auto _811 = x;auto _812 = ch;auto _809 = channelEnqueue<A>(_810)(_811)(_812); return _809;}; return _808;}; return _807;};

template <class A> std::function<std::function<_IO<_Maybe<A>>(_Channel<A>)>(uint64_t)> receive = [](auto id) { auto _814 = [id](auto ch) { auto _816 = id;auto _817 = ch;auto _815 = channelDequeue<A>(_816)(_817); return _815;}; return _814;};

template <class A> std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)> link = [](auto id) { auto _819 = [id](auto idSet) { auto _820 = [id,idSet](auto pf) { auto _821 = [id,idSet]() { auto _823 = id;auto _822 = prim_create_channel<A>(_823); switch (   _822.type) {  case True: {auto _826 = *(std::static_pointer_cast<_Bool_True>(_822.data));auto _830 = id;auto _834 = id;auto _832 = _Channel<A>::_MkChannel(_834);auto _837 = id;auto _838 = idSet;auto _835 = _Vec<uint64_t>::_ConsV(_837,_838);auto _840 = _TyEq::_Refl()
;auto _841 = _TyEq::_Refl()
;auto _836 = _Sigma<_TyEq,_TyEq>::_Prod(_840,_841);auto _833 = _Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>::_Prod(_835,_836);auto _831 = _Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>::_Prod(_832,_833);auto _829 = _Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>::_Prod(_830,_831);auto _827 = _Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>::_Just(_829);auto _825 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_827); return _825;} case False: {auto _843 = *(std::static_pointer_cast<_Bool_False>(_822.data));auto _844 = _Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>::_Nothing();auto _842 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_844); return _842;}} }(); return _821;}; return _820;}; return _819;};

std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)> spawn = [](auto pid) { auto _846 = [pid](auto n) { auto _847 = [pid](auto pidSet) { auto _848 = [pid,pidSet](auto pf) { auto _853 = pid;auto _857 = pid;auto _858 = pidSet;auto _855 = _Vec<uint64_t>::_ConsV(_857,_858);auto _860 = _TyEq::_Refl()
;auto _861 = _TyEq::_Refl()
;auto _856 = _Sigma<_TyEq,_TyEq>::_Prod(_860,_861);auto _854 = _Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>::_Prod(_855,_856);auto _852 = _Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>::_Prod(_853,_854);auto _850 = _Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>::_Just(_852);auto _849 = returnIO<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_850); return _849;}; return _848;}; return _847;}; return _846;};

std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_IO<_Unit>)>(_ElemVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)> run = [](auto pid) { auto _862 = [](auto n) { auto _863 = [](auto pidSet) { auto _864 = [pidSet](auto pf) { auto _865 = [pidSet](auto process) { auto _870 = pidSet;auto _871 = _TyEq::_Refl()
;auto _869 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_870,_871);auto _867 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_869);auto _866 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_867); return _866;}; return _865;}; return _864;}; return _863;}; return _862;};

std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(std::function<void(void)>)>(std::function<_Void(_ElemVec<uint64_t>)>)>(_Vec<uint64_t>)>(uint64_t)> spawnAndRun = [](auto pid) {auto _719 = [pid](auto pidSet) {auto _720 = [pid, pidSet](auto pf) {auto _721 = [pid, pidSet](auto proc) {// Spawning the thread
try {std::thread* t = new std::thread([proc](){proc();});addThread(pid, t);} catch (std::system_error) {return returnIO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>::_Nothing());}auto _726 = pid;auto _730 = pid;auto _731 = pidSet;auto _728 = _Vec<uint64_t>::_ConsV(_730, _731);auto _733 = _TyEq::_Refl();auto _734 = _TyEq::_Refl();auto _729 = _Sigma<_TyEq, _TyEq>::_Prod(_733, _734);auto _727 =_Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>::_Prod(_728, _729);auto _725 =_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>::_Prod(_726, _727);auto _723 =_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>::_Just(_725);auto _722 = returnIO<_Maybe<_Sigma<uint64_t, _Sigma<_Vec<uint64_t>, _Sigma<_TyEq, _TyEq>>>>>(_723);return _722;};return _721;};return _720;};return _719;};

std::function<_IO<uint64_t>(uint64_t)> getTime = [](auto i) {return returnIO<uint64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());};
enum _enum_Farm_type {MkFarm};template <class A> class _Farm_MkFarm;
template <class A> class _Farm { public: enum _enum_Farm_type type; std::shared_ptr<void> data;static _Farm<A> _MkFarm(uint64_t _1, std::function<A(A)> _2);_Farm<A>(_enum_Farm_type t, std::shared_ptr<void> d) {type=t; data=d;} 
_Farm<A>(const _Farm<A>& other);
_Farm<A>() = default;};template <class A> class _Farm_MkFarm { public: uint64_t _1;std::function<A(A)> _2;_Farm_MkFarm (uint64_t _1, std::function<A(A)> _2) {this->_1= _1;this->_2= _2;};_Farm_MkFarm (const _Farm_MkFarm* other) { this->_1= other->_1;this->_2= other->_2;} };template <class A>  inline _Farm<A> _Farm<A>::_MkFarm(uint64_t _1, std::function<A(A)> _2){ return  _Farm<A> ( MkFarm, std::make_shared<_Farm_MkFarm<A>>(_1, _2)); };template <class A> _Farm<A>::_Farm(const _Farm<A>& other) { type = other.type; data = other.data; } 

template <class A> std::function<std::function<std::function<_IO<_Unit>(_List<A>)>(_Channel<A>)>(uint64_t)> producerWrapper = [](auto id) { auto _872 = [id](auto ch) { auto _873 = [id,ch](auto list) { auto _874 = [list,id,ch]() { auto _875 = list; switch (   _875.type) {  case Nil: {auto _877 = *(std::static_pointer_cast<_List_Nil<A>>(_875.data));auto _882 = id;auto _883 = _Maybe<A>::_Nothing();auto _884 = ch;auto _878 = send<A>(_882)(_883)(_884);auto _879 = end;auto _876 = bind<_Unit,_Unit>(_878)(_879); return _876;} case Cons: {auto _887 = *(std::static_pointer_cast<_List_Cons<A>>(_875.data));auto x = _887._1;auto xs = _887._2;auto _892 = id;auto _896 = x;auto _893 = _Maybe<A>::_Just(_896);auto _894 = ch;auto _888 = send<A>(_892)(_893)(_894);auto _897 = id;auto _898 = ch;auto _899 = xs;auto _889 = producerWrapper<A>(_897)(_898)(_899);auto _886 = bind<_Unit,_Unit>(_888)(_889); return _886;}} }(); return _874;}; return _873;}; return _872;};

template <class A> std::function<_IO<_Unit>(_Vec<_Sigma<uint64_t,_Channel<A>>>)> propgateTermination = [](auto chs) { auto _901 = [chs]() { auto _902 = chs; switch (   _902.type) {  case NilV: {auto _904 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_902.data));auto _903 = end; return _903;} case ConsV: {auto _906 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_902.data));auto ch = _906._1;auto restChs = _906._2;auto _905 = [chs,ch,restChs]() { auto _907 = ch; switch (   _907.type) {  case Prod: {auto _909 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_907.data));auto chid = _909._1;auto channel = _909._2;auto _914 = chid;auto _915 = _Maybe<A>::_Nothing();auto _916 = channel;auto _910 = send<A>(_914)(_915)(_916);auto _918 = restChs;auto _911 = propgateTermination<A>(_918);auto _908 = bind<_Unit,_Unit>(_910)(_911); return _908;}} }(); return _905;}} }(); return _901;};

template <class A> std::function<std::function<std::function<_IO<_Unit>(_List<A>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)> farmProducerWrapper = [](auto allChs) { auto _921 = [allChs](auto chs) { auto _922 = [allChs,chs](auto list) { auto _923 = [list,allChs,chs]() { auto _924 = list; switch (   _924.type) {  case Nil: {auto _926 = *(std::static_pointer_cast<_List_Nil<A>>(_924.data));auto _927 = allChs;auto _925 = propgateTermination<A>(_927); return _925;} case Cons: {auto _931 = *(std::static_pointer_cast<_List_Cons<A>>(_924.data));auto x = _931._1;auto xs = _931._2;auto _930 = [list,allChs,chs,x,xs]() { auto _932 = chs; switch (   _932.type) {  case NilV: {auto _934 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_932.data));auto _935 = allChs;auto _936 = allChs;auto _937 = list;auto _933 = farmProducerWrapper<A>(_935)(_936)(_937); return _933;} case ConsV: {auto _942 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_932.data));auto ch = _942._1;auto restChs = _942._2;auto _941 = [list,allChs,chs,ch,x,restChs,xs]() { auto _943 = ch; switch (   _943.type) {  case Prod: {auto _945 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_943.data));auto chid = _945._1;auto channel = _945._2;auto _950 = chid;auto _954 = x;auto _951 = _Maybe<A>::_Just(_954);auto _952 = channel;auto _946 = send<A>(_950)(_951)(_952);auto _955 = allChs;auto _956 = restChs;auto _957 = xs;auto _947 = farmProducerWrapper<A>(_955)(_956)(_957);auto _944 = bind<_Unit,_Unit>(_946)(_947); return _944;}} }(); return _941;}} }(); return _930;}} }(); return _923;}; return _922;}; return _921;};

template <class A> std::function<std::function<std::function<std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_Channel<A>)>(_Channel<A>)>(uint64_t)>(uint64_t)> workerWrapper = [](auto receiveId) { auto _961 = [receiveId](auto sendId) { auto _962 = [receiveId,sendId](auto receiveChannel) { auto _963 = [receiveId,receiveChannel,sendId](auto sendChannel) { auto _964 = [receiveId,receiveChannel,sendId,sendChannel](auto f) { auto _970 = receiveId;auto _971 = receiveChannel;auto _966 = receive<A>(_970)(_971);auto _967 = [receiveId,receiveChannel,sendId,sendChannel,f](auto mx) { auto _973 = [receiveId,receiveChannel,mx,sendId,sendChannel,f]() { auto _974 = mx; switch (   _974.type) {  case Nothing: {auto _976 = *(std::static_pointer_cast<_Maybe_Nothing<A>>(_974.data));auto _981 = sendId;auto _982 = _Maybe<A>::_Nothing();auto _983 = sendChannel;auto _977 = send<A>(_981)(_982)(_983);auto _978 = end;auto _975 = bind<_Unit,_Unit>(_977)(_978); return _975;} case Just: {auto _986 = *(std::static_pointer_cast<_Maybe_Just<A>>(_974.data));auto x = _986._1;auto _991 = sendId;auto _996 = x;auto _995 = f(_996);auto _992 = _Maybe<A>::_Just(_995);auto _993 = sendChannel;auto _987 = send<A>(_991)(_992)(_993);auto _997 = receiveId;auto _998 = sendId;auto _999 = receiveChannel;auto _1000 = sendChannel;auto _1001 = f;auto _988 = workerWrapper<A>(_997)(_998)(_999)(_1000)(_1001);auto _985 = bind<_Unit,_Unit>(_987)(_988); return _985;}} }(); return _973;};auto _965 = bindEq<_Maybe<A>,_Unit>(_966)(_967); return _965;}; return _964;}; return _963;}; return _962;}; return _961;};

template <class A> std::function<std::function<std::function<_IO<_List<A>>(uint64_t)>(_Channel<A>)>(uint64_t)> farmConsumerWrapper = [](auto chid) { auto _1003 = [chid](auto ch) { auto _1004 = [chid,ch](auto numLeft) { auto _1005 = [numLeft,chid,ch]() {auto _1006 = numLeft; if ( !_1006 ) {auto _1008 = _List<A>::_Nil();auto _1007 = returnIO<_List<A>>(_1008);return _1007; } else {auto n = _1006 - 1;auto _1014 = chid;auto _1015 = ch;auto _1010 = receive<A>(_1014)(_1015);auto _1011 = [numLeft,chid,ch,n](auto mx) { auto _1017 = [numLeft,chid,ch,mx,n]() { auto _1018 = mx; switch (   _1018.type) {  case Nothing: {auto _1020 = *(std::static_pointer_cast<_Maybe_Nothing<A>>(_1018.data));auto _1021 = chid;auto _1022 = ch;auto _1023 = n;auto _1019 = farmConsumerWrapper<A>(_1021)(_1022)(_1023); return _1019;} case Just: {auto _1026 = *(std::static_pointer_cast<_Maybe_Just<A>>(_1018.data));auto x = _1026._1;auto _1031 = chid;auto _1032 = ch;auto _1033 = numLeft;auto _1027 = farmConsumerWrapper<A>(_1031)(_1032)(_1033);auto _1028 = [numLeft,chid,ch,mx,n,x](auto res) { auto _1038 = x;auto _1039 = res;auto _1036 = _List<A>::_Cons(_1038,_1039);auto _1035 = returnIO<_List<A>>(_1036); return _1035;};auto _1025 = bindEq<_List<A>,_List<A>>(_1027)(_1028); return _1025;}} }(); return _1017;};auto _1007 = bindEq<_Maybe<A>,_List<A>>(_1010)(_1011);return _1007;} }(); return _1005;}; return _1004;}; return _1003;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(std::function<A(A)>)>(_Sigma<uint64_t,_Channel<A>>)>(_Vec<_Sigma<uint64_t,_Channel<A>>>)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> spawnWorkersFarm = [](auto n) { auto _1040 = [n](auto pidSet) { auto _1041 = [pidSet,n](auto nDash) { auto _1042 = [pidSet,n,nDash](auto pids) { auto _1043 = [pids,pidSet,n,nDash](auto pidPf) { auto _1044 = [pids,pidSet,pidPf,n,nDash](auto chs) { auto _1045 = [pids,pidSet,pidPf,chs,n,nDash](auto consumerCh) { auto _1046 = [consumerCh,pids,pidSet,pidPf,chs,n,nDash](auto f) { auto _1047 = [consumerCh,pids,pidSet,pidPf,chs,f,n,nDash]() { auto _1048 = consumerCh; switch (   _1048.type) {  case Prod: {auto _1050 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1048.data));auto consumerChid = _1050._1;auto consumerChannel = _1050._2;auto _1049 = [consumerCh,pids,pidSet,pidPf,chs,consumerChid,consumerChannel,f,n,nDash]() { auto _1051 = pids; switch (   _1051.type) {  case NilV: {auto _1053 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1051.data));auto _1057 = pidSet;auto _1058 = _TyEq::_Refl()
;auto _1056 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1057,_1058);auto _1054 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_1056);auto _1052 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1054); return _1052;} case ConsV: {auto _1060 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1051.data));auto x = _1060._1;auto xs = _1060._2;auto _1059 = [consumerCh,pids,pidSet,pidPf,chs,consumerChid,consumerChannel,f,n,nDash,xs]() { auto _1061 = pidPf; switch (   _1061.type) {  case UConsV: {auto _1063 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1061.data));auto y = _1063._1;auto ys = _1063._2;auto pf = _1063._3;auto restPf = _1063._4;auto _1062 = [consumerCh,pids,pidSet,pidPf,chs,y,ys,pf,consumerChid,consumerChannel,f,n,nDash,xs,restPf]() { auto _1064 = chs; switch (   _1064.type) {  case ConsV: {auto _1066 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_1064.data));auto curCh = _1066._1;auto restChs = _1066._2;auto _1065 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,consumerChid,consumerChannel,f,n,nDash,xs,restPf,restChs]() { auto _1067 = curCh; switch (   _1067.type) {  case Prod: {auto _1069 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1067.data));auto currChid = _1069._1;auto currChannel = _1069._2;auto _1074 = y;auto _1075 = ys;auto _1076 = pf;auto _1070 = spawnAndRun(_1074)(_1075)(_1076)([consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f](){auto _1079 = currChid;auto _1080 = consumerChid;auto _1081 = currChannel;auto _1082 = consumerChannel;auto _1083 = f;auto _1077 = workerWrapper<A>(_1079)(_1080)(_1081)(_1082)(_1083);});auto _1071 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,n,nDash,xs,restPf,restChs](auto mres) { auto _1085 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs]() { auto _1086 = mres; switch (   _1086.type) {  case Nothing: {auto _1088 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1086.data));auto _1089 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Nothing();auto _1087 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1089); return _1087;} case Just: {auto _1092 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1086.data));auto res = _1092._1;auto _1097 = n;auto _1098 = pidSet;auto _1106 = nDash;auto _1099 = pred(_1106);auto _1100 = xs;auto _1101 = restPf;auto _1102 = restChs;auto _1103 = consumerCh;auto _1104 = f;auto _1093 = spawnWorkersFarm<A>(_1097)(_1098)(_1099)(_1100)(_1101)(_1102)(_1103)(_1104);auto _1094 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs](auto mress) { auto _1107 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs,mress]() { auto _1108 = mress; switch (   _1108.type) {  case Nothing: {auto _1110 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1108.data));auto _1111 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Nothing();auto _1109 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1111); return _1109;} case Just: {auto _1114 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1108.data));auto res = _1114._1;auto _1113 = [consumerCh,pids,pidSet,pidPf,chs,curCh,y,ys,pf,currChid,consumerChid,currChannel,consumerChannel,f,mres,n,nDash,xs,restPf,restChs,mress,res]() { auto _1115 = res; switch (   _1115.type) {  case Prod: {auto _1117 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1115.data));auto newPidSet = _1117._1;auto pfNewPidSetCorrect = _1117._2;auto _1123 = y;auto _1124 = newPidSet;auto _1121 = _Vec<uint64_t>::_ConsV(_1123,_1124);auto _1126 = _TyEq::_Refl()
;auto _1122 = _1126;auto _1120 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1121,_1122);auto _1118 = _Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>::_Just(_1120);auto _1116 = returnIO<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1118); return _1116;}} }(); return _1113;}} }(); return _1107;};auto _1091 = bindEq<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>,_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1093)(_1094); return _1091;}} }(); return _1085;};auto _1068 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>,_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1070)(_1071); return _1068;}} }(); return _1065;}} }(); return _1062;}} }(); return _1059;}} }(); return _1049;}} }(); return _1047;}; return _1046;}; return _1045;}; return _1044;}; return _1043;}; return _1042;}; return _1041;}; return _1040;};

template <class A> std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> createChannelsFarm = [](auto m) { auto _1127 = [m](auto chidSet) { auto _1128 = [chidSet,m](auto mDash) { auto _1129 = [chidSet,m,mDash](auto chids) { auto _1130 = [chids,chidSet,m,mDash](auto chidPf) { auto _1131 = [chids,chidSet,chidPf,m,mDash]() { auto _1132 = chids; switch (   _1132.type) {  case NilV: {auto _1134 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1132.data));auto _1138 = _Vec<_Sigma<uint64_t,_Channel<A>>>::_NilV();auto _1140 = chidSet;auto _1141 = _TyEq::_Refl()
;auto _1139 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1140,_1141);auto _1137 = _Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1138,_1139);auto _1135 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1137);auto _1133 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1135); return _1133;} case ConsV: {auto _1143 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1132.data));auto x = _1143._1;auto xs = _1143._2;auto _1142 = [chids,chidSet,chidPf,m,mDash,xs]() { auto _1144 = chidPf; switch (   _1144.type) {  case UConsV: {auto _1146 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1144.data));auto y = _1146._1;auto ys = _1146._2;auto pf = _1146._3;auto restPf = _1146._4;auto _1151 = y;auto _1152 = ys;auto _1153 = pf;auto _1147 = link<A>(_1151)(_1152)(_1153);auto _1148 = [chids,chidSet,chidPf,y,ys,pf,m,mDash,xs,restPf](auto mres) { auto _1156 = [chids,chidSet,chidPf,y,ys,pf,mres,m,mDash,xs,restPf]() { auto _1157 = mres; switch (   _1157.type) {  case Nothing: {auto _1159 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_1157.data));auto _1160 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1158 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1160); return _1158;} case Just: {auto _1163 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>>(_1157.data));auto res = _1163._1;auto _1162 = [chids,chidSet,chidPf,y,ys,pf,mres,res,m,mDash,xs,restPf]() { auto _1164 = res; switch (   _1164.type) {  case Prod: {auto _1166 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1164.data));auto resChid = _1166._1;auto rest1 = _1166._2;auto _1165 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,m,mDash,xs,restPf]() { auto _1167 = rest1; switch (   _1167.type) {  case Prod: {auto _1169 = *(std::static_pointer_cast<_Sigma_Prod<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>(_1167.data));auto ch = _1169._1;auto rest2 = _1169._2;auto _1168 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,m,mDash,xs,restPf,ch]() { auto _1170 = rest2; switch (   _1170.type) {  case Prod: {auto _1172 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>(_1170.data));auto newChidSet = _1172._1;auto pfs = _1172._2;auto _1171 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,ch]() { auto _1173 = pfs; switch (   _1173.type) {  case Prod: {auto _1175 = *(std::static_pointer_cast<_Sigma_Prod<_TyEq,_TyEq>>(_1173.data));auto chidEqResChidPf = _1175._1;auto pfNewChidSetCorrect = _1175._2;auto _1180 = m;auto _1181 = chidSet;auto _1186 = mDash;auto _1182 = pred(_1186);auto _1183 = xs;auto _1184 = restPf;auto _1176 = createChannelsFarm<A>(_1180)(_1181)(_1182)(_1183)(_1184);auto _1177 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,ch](auto mress) { auto _1187 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ch]() { auto _1188 = mress; switch (   _1188.type) {  case Nothing: {auto _1190 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1188.data));auto _1191 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1189 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1191); return _1189;} case Just: {auto _1194 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1188.data));auto ress = _1194._1;auto _1193 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ress,ch]() { auto _1195 = ress; switch (   _1195.type) {  case Prod: {auto _1197 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1195.data));auto chs = _1197._1;auto rest3 = _1197._2;auto _1196 = [chids,chidSet,chidPf,y,ys,pf,mres,res,rest1,rest2,pfs,m,mDash,xs,restPf,mress,ress,rest3,ch,chs]() { auto _1198 = rest3; switch (   _1198.type) {  case Prod: {auto _1200 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1198.data));auto returnedChidSet = _1200._1;auto pfReturnedChidSetCorrect = _1200._2;auto _1210 = y;auto _1211 = ch;auto _1209 = _Sigma<uint64_t,_Channel<A>>::_Prod(_1210,_1211);auto _1206 = _1209;auto _1207 = chs;auto _1204 = _Vec<_Sigma<uint64_t,_Channel<A>>>::_ConsV(_1206,_1207);auto _1214 = y;auto _1215 = returnedChidSet;auto _1212 = _Vec<uint64_t>::_ConsV(_1214,_1215);auto _1217 = _TyEq::_Refl()
;auto _1213 = _1217;auto _1205 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1212,_1213);auto _1203 = _Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1204,_1205);auto _1201 = _Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1203);auto _1199 = returnIO<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1201); return _1199;}} }(); return _1196;}} }(); return _1193;}} }(); return _1187;};auto _1174 = bindEq<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1176)(_1177); return _1174;}} }(); return _1171;}} }(); return _1168;}} }(); return _1165;}} }(); return _1162;}} }(); return _1156;};auto _1145 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Channel<A>,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>,_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1147)(_1148); return _1145;}} }(); return _1142;}} }(); return _1131;}; return _1130;}; return _1129;}; return _1128;}; return _1127;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_List<A>)>(std::function<A(A)>)>(_TyEq)>(_TyEq)>(std::function<_Void(_TyEq)>)>(uint64_t)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_UniqueVec<uint64_t>)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)> createFarm = [](auto n) { auto _1218 = [n](auto pidSet) { auto _1219 = [n,pidSet](auto nDash) { auto _1220 = [n,pidSet,nDash](auto pids) { auto _1221 = [pids,n,pidSet,nDash](auto pidPf) { auto _1222 = [pids,pidPf,n,pidSet,nDash](auto m) { auto _1223 = [m,pids,pidPf,n,pidSet,nDash](auto chidSet) { auto _1224 = [m,chidSet,pids,pidPf,n,pidSet,nDash](auto mDash) { auto _1225 = [m,chidSet,mDash,pids,pidPf,n,pidSet,nDash](auto chids) { auto _1226 = [m,chidSet,mDash,chids,pids,pidPf,n,pidSet,nDash](auto chidPf) { auto _1227 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash](auto numWorkers) { auto _1228 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfNotZ) { auto _1229 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfPidsNCorrect) { auto _1230 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto pfChidsMCorrect) { auto _1231 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,numWorkers](auto f) { auto _1232 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,n,pidSet,nDash,f,numWorkers](auto input) { auto _1238 = m;auto _1239 = chidSet;auto _1240 = mDash;auto _1241 = chids;auto _1242 = chidPf;auto _1234 = createChannelsFarm<A>(_1238)(_1239)(_1240)(_1241)(_1242);auto _1235 = [m,chidSet,mDash,chids,chidPf,pids,pidPf,input,n,pidSet,nDash,f,numWorkers](auto mres1) { auto _1244 = [m,chidSet,mDash,chids,chidPf,mres1,pids,pidPf,input,n,pidSet,nDash,f,numWorkers]() { auto _1245 = mres1; switch (   _1245.type) {  case Nothing: {auto _1247 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1245.data));auto _1248 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1246 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1248); return _1246;} case Just: {auto _1251 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1245.data));auto res1 = _1251._1;auto _1250 = [m,chidSet,mDash,chids,chidPf,mres1,res1,pids,pidPf,input,n,pidSet,nDash,f,numWorkers]() { auto _1252 = res1; switch (   _1252.type) {  case Prod: {auto _1254 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1252.data));auto chs = _1254._1;auto chidPfToReturn = _1254._2;auto _1253 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,pids,pidPf,input,n,pidSet,nDash,f,numWorkers,chidPfToReturn]() { auto _1255 = chs; switch (   _1255.type) {  case NilV: {auto _1257 = *(std::static_pointer_cast<_Vec_NilV<_Sigma<uint64_t,_Channel<A>>>>(_1255.data));auto _1258 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1256 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1258); return _1256;} case ConsV: {auto _1261 = *(std::static_pointer_cast<_Vec_ConsV<_Sigma<uint64_t,_Channel<A>>>>(_1255.data));auto consumerCh = _1261._1;auto otherChs = _1261._2;auto _1260 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,f,numWorkers,chidPfToReturn]() { auto _1262 = consumerCh; switch (   _1262.type) {  case Prod: {auto _1264 = *(std::static_pointer_cast<_Sigma_Prod<uint64_t,_Channel<A>>>(_1262.data));auto consumerChid = _1264._1;auto consumerChannel = _1264._2;auto _1263 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1265 = pids; switch (   _1265.type) {  case NilV: {auto _1267 = *(std::static_pointer_cast<_Vec_NilV<uint64_t>>(_1265.data));auto _1268 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1266 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1268); return _1266;} case ConsV: {auto _1271 = *(std::static_pointer_cast<_Vec_ConsV<uint64_t>>(_1265.data));auto x = _1271._1;auto xs = _1271._2;auto _1270 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,otherChs,input,n,pidSet,nDash,xs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1272 = pidPf; switch (   _1272.type) {  case UConsV: {auto _1274 = *(std::static_pointer_cast<_UniqueVec_UConsV<uint64_t>>(_1272.data));auto producerPid = _1274._1;auto restPids = _1274._2;auto producerPidPf = _1274._3;auto restPfs = _1274._4;auto _1279 = producerPid;auto _1280 = restPids;auto _1281 = producerPidPf;auto _1275 = spawnAndRun(_1279)(_1280)(_1281)([m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input](){auto _1284 = otherChs;auto _1285 = otherChs;auto _1286 = input;auto _1282 = farmProducerWrapper<A>(_1284)(_1285)(_1286);});auto _1276 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn](auto mres2) { auto _1290 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1291 = mres2; switch (   _1291.type) {  case Nothing: {auto _1293 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1291.data));auto _1294 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1292 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1294); return _1292;} case Just: {auto _1297 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>>(_1291.data));auto res2 = _1297._1;auto _1302 = n;auto _1303 = pidSet;auto _1311 = nDash;auto _1304 = pred(_1311);auto _1305 = xs;auto _1306 = restPfs;auto _1312 = otherChs;auto _1307 = _1312;auto _1308 = consumerCh;auto _1309 = f;auto _1298 = spawnWorkersFarm<A>(_1302)(_1303)(_1304)(_1305)(_1306)(_1307)(_1308)(_1309);auto _1299 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,consumerChid,consumerChannel,numWorkers,chidPfToReturn](auto mres3) { auto _1313 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1314 = mres3; switch (   _1314.type) {  case Nothing: {auto _1316 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1314.data));auto _1317 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Nothing();auto _1315 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1317); return _1315;} case Just: {auto _1320 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Vec<uint64_t>,_TyEq>>>(_1314.data));auto workerPidPfs = _1320._1;auto _1319 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,workerPidPfs,consumerChid,consumerChannel,numWorkers,chidPfToReturn]() { auto _1321 = workerPidPfs; switch (   _1321.type) {  case Prod: {auto _1323 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1321.data));auto workersPidSet = _1323._1;auto workerPidSetPf = _1323._2;auto _1328 = consumerChid;auto _1329 = consumerChannel;auto _1330 = numWorkers;auto _1324 = farmConsumerWrapper<A>(_1328)(_1329)(_1330);auto _1325 = [m,chidSet,mDash,chids,chidPf,mres1,res1,chs,consumerCh,pids,pidPf,producerPid,restPids,producerPidPf,otherChs,input,mres2,n,pidSet,nDash,xs,restPfs,f,mres3,workerPidPfs,consumerChid,consumerChannel,numWorkers,workersPidSet,workerPidSetPf,chidPfToReturn](auto resultantList) { auto _1336 = resultantList;auto _1340 = numWorkers;auto _1341 = f;auto _1338 = _Farm<A>::_MkFarm(_1340,_1341);auto _1346 = producerPid;auto _1347 = workersPidSet;auto _1344 = _Vec<uint64_t>::_ConsV(_1346,_1347);auto _1349 = _TyEq::_Refl()
;auto _1350 = workerPidSetPf;auto _1345 = consVInjLem(_1349)(_1350);auto _1342 = _Sigma<_Vec<uint64_t>,_TyEq>::_Prod(_1344,_1345);auto _1343 = chidPfToReturn;auto _1339 = _Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>::_Prod(_1342,_1343);auto _1337 = _Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Prod(_1338,_1339);auto _1335 = _Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>::_Prod(_1336,_1337);auto _1333 = _Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>::_Just(_1335);auto _1332 = returnIO<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1333); return _1332;};auto _1322 = bindEq<_List<A>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1324)(_1325); return _1322;}} }(); return _1319;}} }(); return _1313;};auto _1296 = bindEq<_Maybe<_Sigma<_Vec<uint64_t>,_TyEq>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1298)(_1299); return _1296;}} }(); return _1290;};auto _1273 = bindEq<_Maybe<_Sigma<uint64_t,_Sigma<_Vec<uint64_t>,_Sigma<_TyEq,_TyEq>>>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1275)(_1276); return _1273;}} }(); return _1270;}} }(); return _1263;}} }(); return _1260;}} }(); return _1253;}} }(); return _1250;}} }(); return _1244;};auto _1233 = bindEq<_Maybe<_Sigma<_Vec<_Sigma<uint64_t,_Channel<A>>>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1234)(_1235); return _1233;}; return _1232;}; return _1231;}; return _1230;}; return _1229;}; return _1228;}; return _1227;}; return _1226;}; return _1225;}; return _1224;}; return _1223;}; return _1222;}; return _1221;}; return _1220;}; return _1219;}; return _1218;};

std::function<uint64_t(uint64_t)> id = [](auto a) { auto _1357 = a;auto _1356 = _1357 + 1;; return _1356;};

template <class A> std::function<_IO<_Unit>(A)> runInIO = [](auto f) { auto _1359 = _Unit::_unit();auto _1358 = returnIO<_Unit>(_1359); return _1358;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> baseRun = [](auto inList) { auto _1361 = [inList](auto func) { auto _1367 = (uint64_t)0;auto _1363 = getTime(_1367);auto _1364 = [func,inList](auto startTime1) { auto _1374 = startTime1;auto _1373 = natToString(_1374);auto _1369 = print(_1373);auto _1381 = func;auto _1382 = inList;auto _1379 = map<A,A>(_1381)(_1382);auto _1375 = runInIO<_List<A>>(_1379);auto _1389 = (uint64_t)0;auto _1385 = getTime(_1389);auto _1386 = [startTime1,func,inList](auto endTime1) { auto _1396 = endTime1;auto _1395 = natToString(_1396);auto _1391 = print(_1395);auto _1392 = end;auto _1390 = bind<_Unit,_Unit>(_1391)(_1392); return _1390;};auto _1376 = bindEq<uint64_t,_Unit>(_1385)(_1386);auto _1370 = bind<_Unit,_Unit>(_1375)(_1376);auto _1368 = bind<_Unit,_Unit>(_1369)(_1370); return _1368;};auto _1362 = bindEq<uint64_t,_Unit>(_1363)(_1364); return _1362;}; return _1361;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)>(std::function<A(A)>)>(_List<A>)> runFarm = [](auto inList) { auto _1397 = [inList](auto func) { auto _1398 = [func,inList](auto numWorkers) { auto _1399 = [numWorkers,func,inList](auto n) { auto _1400 = [numWorkers,n,func,inList](auto pidSet) { auto _1401 = [pidSet,numWorkers,n,func,inList](auto x) { auto _1402 = [pidSet,numWorkers,x,n,func,inList](auto pidsToAdd) { auto _1403 = [pidsToAdd,pidSet,numWorkers,x,n,func,inList](auto m) { auto _1404 = [pidsToAdd,pidSet,numWorkers,x,n,m,func,inList](auto chidSet) { auto _1405 = [pidsToAdd,pidSet,chidSet,numWorkers,x,n,m,func,inList](auto y) { auto _1406 = [pidsToAdd,pidSet,chidSet,numWorkers,x,y,n,m,func,inList](auto chidsToAdd) { auto _1407 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,m,func,inList]() { auto _1411 = pidsToAdd;auto _1412 = pidSet;auto _1409 = append<uint64_t>(_1411)(_1412);auto _1408 = decUniqueVec(_1409); switch (   _1408.type) {  case Yes: {auto _1417 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1408.data));auto pidsProof = _1417._1;auto _1416 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,func,inList]() { auto _1421 = chidsToAdd;auto _1422 = chidSet;auto _1419 = append<uint64_t>(_1421)(_1422);auto _1418 = decUniqueVec(_1419); switch (   _1418.type) {  case Yes: {auto _1427 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1418.data));auto chidsProof = _1427._1;auto _1426 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,func,inList]() { auto _1429 = numWorkers;auto _1430 = (uint64_t)0;auto _1428 = decEqNat(_1429)(_1430); switch (   _1428.type) {  case No: {auto _1432 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1428.data));auto numWneq0 = _1432._1;auto _1431 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,func,inList]() { auto _1434 = x;auto _1436 = numWorkers;auto _1435 = _1436 + 1;;auto _1433 = decEqNat(_1434)(_1435); switch (   _1433.type) {  case Yes: {auto _1438 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1433.data));auto xProof = _1438._1;auto _1437 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,func,inList]() { auto _1440 = y;auto _1442 = numWorkers;auto _1441 = _1442 + 1;;auto _1439 = decEqNat(_1440)(_1441); switch (   _1439.type) {  case Yes: {auto _1444 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1439.data));auto yProof = _1444._1;auto _1449 = (uint64_t)0;auto _1445 = getTime(_1449);auto _1446 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto startTime) { auto _1456 = startTime;auto _1455 = natToString(_1456);auto _1451 = print(_1455);auto _1461 = n;auto _1462 = pidSet;auto _1463 = x;auto _1464 = pidsToAdd;auto _1465 = pidsProof;auto _1466 = m;auto _1467 = chidSet;auto _1468 = y;auto _1469 = chidsToAdd;auto _1470 = chidsProof;auto _1471 = numWorkers;auto _1472 = numWneq0;auto _1473 = xProof;auto _1474 = yProof;auto _1475 = func;auto _1476 = inList;auto _1457 = createFarm<A>(_1461)(_1462)(_1463)(_1464)(_1465)(_1466)(_1467)(_1468)(_1469)(_1470)(_1471)(_1472)(_1473)(_1474)(_1475)(_1476);auto _1458 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto mresult) { auto _1478 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult]() { auto _1479 = mresult; switch (   _1479.type) {  case Just: {auto _1481 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1479.data));auto result = _1481._1;auto _1480 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result]() { auto _1482 = result; switch (   _1482.type) {  case Prod: {auto _1484 = *(std::static_pointer_cast<_Sigma_Prod<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>(_1482.data));auto output = _1484._1;auto rest1 = _1484._2;auto _1483 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result,rest1]() { auto _1485 = rest1; switch (   _1485.type) {  case Prod: {auto _1487 = *(std::static_pointer_cast<_Sigma_Prod<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1485.data));auto farmObject = _1487._1;auto toReturn = _1487._2;auto _1492 = (uint64_t)0;auto _1488 = getTime(_1492);auto _1489 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result,rest1,toReturn](auto endTime) { auto _1499 = endTime;auto _1498 = natToString(_1499);auto _1494 = print(_1498);auto _1502 = toReturn;auto _1500 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Just(_1502);auto _1495 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1500);auto _1493 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1494)(_1495); return _1493;};auto _1486 = bindEq<uint64_t,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1488)(_1489); return _1486;}} }(); return _1483;}} }(); return _1480;} case Nothing: {auto _1504 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1479.data));auto _1505 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1503 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1505); return _1503;}} }(); return _1478;};auto _1452 = bindEq<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1457)(_1458);auto _1450 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1451)(_1452); return _1450;};auto _1443 = bindEq<uint64_t,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1445)(_1446); return _1443;} case No: {auto _1508 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1439.data));auto xYProof = _1508._1;auto _1514 = 'E';auto _1516 = 'r';auto _1518 = 'r';auto _1520 = 'o';auto _1522 = 'r';auto _1523 = _List<char>::_Nil();auto _1521 = _List<char>::_Cons(_1522,_1523);auto _1519 = _List<char>::_Cons(_1520,_1521);auto _1517 = _List<char>::_Cons(_1518,_1519);auto _1515 = _List<char>::_Cons(_1516,_1517);auto _1513 = _List<char>::_Cons(_1514,_1515);auto _1509 = print(_1513);auto _1524 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1510 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1524);auto _1507 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1509)(_1510); return _1507;}} }(); return _1437;} case No: {auto _1527 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1433.data));auto cXProof = _1527._1;auto _1533 = 'E';auto _1535 = 'r';auto _1537 = 'r';auto _1539 = 'o';auto _1541 = 'r';auto _1542 = _List<char>::_Nil();auto _1540 = _List<char>::_Cons(_1541,_1542);auto _1538 = _List<char>::_Cons(_1539,_1540);auto _1536 = _List<char>::_Cons(_1537,_1538);auto _1534 = _List<char>::_Cons(_1535,_1536);auto _1532 = _List<char>::_Cons(_1533,_1534);auto _1528 = print(_1532);auto _1543 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1529 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1543);auto _1526 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1528)(_1529); return _1526;}} }(); return _1431;} case Yes: {auto _1546 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1428.data));auto numWeq0 = _1546._1;auto _1552 = 'E';auto _1554 = 'r';auto _1556 = 'r';auto _1558 = 'o';auto _1560 = 'r';auto _1561 = _List<char>::_Nil();auto _1559 = _List<char>::_Cons(_1560,_1561);auto _1557 = _List<char>::_Cons(_1558,_1559);auto _1555 = _List<char>::_Cons(_1556,_1557);auto _1553 = _List<char>::_Cons(_1554,_1555);auto _1551 = _List<char>::_Cons(_1552,_1553);auto _1547 = print(_1551);auto _1562 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1548 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1562);auto _1545 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1547)(_1548); return _1545;}} }(); return _1426;} case No: {auto _1565 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1418.data));auto cChidsProof = _1565._1;auto _1571 = 'E';auto _1573 = 'r';auto _1575 = 'r';auto _1577 = 'o';auto _1579 = 'r';auto _1580 = _List<char>::_Nil();auto _1578 = _List<char>::_Cons(_1579,_1580);auto _1576 = _List<char>::_Cons(_1577,_1578);auto _1574 = _List<char>::_Cons(_1575,_1576);auto _1572 = _List<char>::_Cons(_1573,_1574);auto _1570 = _List<char>::_Cons(_1571,_1572);auto _1566 = print(_1570);auto _1581 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1567 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1581);auto _1564 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1566)(_1567); return _1564;}} }(); return _1416;} case No: {auto _1584 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1408.data));auto cPidsProof = _1584._1;auto _1590 = 'E';auto _1592 = 'r';auto _1594 = 'r';auto _1596 = 'o';auto _1598 = 'r';auto _1599 = _List<char>::_Nil();auto _1597 = _List<char>::_Cons(_1598,_1599);auto _1595 = _List<char>::_Cons(_1596,_1597);auto _1593 = _List<char>::_Cons(_1594,_1595);auto _1591 = _List<char>::_Cons(_1592,_1593);auto _1589 = _List<char>::_Cons(_1590,_1591);auto _1585 = print(_1589);auto _1600 = _Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>::_Nothing();auto _1586 = returnIO<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1600);auto _1583 = bind<_Unit,_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1585)(_1586); return _1583;}} }(); return _1407;}; return _1406;}; return _1405;}; return _1404;}; return _1403;}; return _1402;}; return _1401;}; return _1400;}; return _1399;}; return _1398;}; return _1397;};

template <class A> std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<std::function<_IO<_Maybe<_List<A>>>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(_Vec<uint64_t>)>(uint64_t)>(uint64_t)>(std::function<A(A)>)>(_List<A>)> runFarmSimple = [](auto inList) { auto _1602 = [inList](auto func) { auto _1603 = [func,inList](auto numWorkers) { auto _1604 = [numWorkers,func,inList](auto n) { auto _1605 = [numWorkers,n,func,inList](auto pidSet) { auto _1606 = [pidSet,numWorkers,n,func,inList](auto x) { auto _1607 = [pidSet,numWorkers,x,n,func,inList](auto pidsToAdd) { auto _1608 = [pidsToAdd,pidSet,numWorkers,x,n,func,inList](auto m) { auto _1609 = [pidsToAdd,pidSet,numWorkers,x,n,m,func,inList](auto chidSet) { auto _1610 = [pidsToAdd,pidSet,chidSet,numWorkers,x,n,m,func,inList](auto y) { auto _1611 = [pidsToAdd,pidSet,chidSet,numWorkers,x,y,n,m,func,inList](auto chidsToAdd) { auto _1612 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,m,func,inList]() { auto _1616 = pidsToAdd;auto _1617 = pidSet;auto _1614 = append<uint64_t>(_1616)(_1617);auto _1613 = decUniqueVec(_1614); switch (   _1613.type) {  case Yes: {auto _1622 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1613.data));auto pidsProof = _1622._1;auto _1621 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,func,inList]() { auto _1626 = chidsToAdd;auto _1627 = chidSet;auto _1624 = append<uint64_t>(_1626)(_1627);auto _1623 = decUniqueVec(_1624); switch (   _1623.type) {  case Yes: {auto _1632 = *(std::static_pointer_cast<_Dec_Yes<_UniqueVec<uint64_t>>>(_1623.data));auto chidsProof = _1632._1;auto _1631 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,func,inList]() { auto _1634 = numWorkers;auto _1635 = (uint64_t)0;auto _1633 = decEqNat(_1634)(_1635); switch (   _1633.type) {  case No: {auto _1637 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1633.data));auto numWneq0 = _1637._1;auto _1636 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,func,inList]() { auto _1639 = x;auto _1641 = numWorkers;auto _1640 = _1641 + 1;;auto _1638 = decEqNat(_1639)(_1640); switch (   _1638.type) {  case Yes: {auto _1643 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1638.data));auto xProof = _1643._1;auto _1642 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,func,inList]() { auto _1645 = y;auto _1647 = numWorkers;auto _1646 = _1647 + 1;;auto _1644 = decEqNat(_1645)(_1646); switch (   _1644.type) {  case Yes: {auto _1649 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1644.data));auto yProof = _1649._1;auto _1654 = (uint64_t)0;auto _1650 = getTime(_1654);auto _1651 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto startTime) { auto _1661 = startTime;auto _1660 = natToString(_1661);auto _1656 = print(_1660);auto _1666 = n;auto _1667 = pidSet;auto _1668 = x;auto _1669 = pidsToAdd;auto _1670 = pidsProof;auto _1671 = m;auto _1672 = chidSet;auto _1673 = y;auto _1674 = chidsToAdd;auto _1675 = chidsProof;auto _1676 = numWorkers;auto _1677 = numWneq0;auto _1678 = xProof;auto _1679 = yProof;auto _1680 = func;auto _1681 = inList;auto _1662 = createFarm<A>(_1666)(_1667)(_1668)(_1669)(_1670)(_1671)(_1672)(_1673)(_1674)(_1675)(_1676)(_1677)(_1678)(_1679)(_1680)(_1681);auto _1663 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList](auto mresult) { auto _1683 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult]() { auto _1684 = mresult; switch (   _1684.type) {  case Just: {auto _1686 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1684.data));auto result = _1686._1;auto _1685 = [pidsToAdd,pidSet,chidsToAdd,chidSet,numWorkers,x,y,startTime,n,pidsProof,m,chidsProof,numWneq0,xProof,yProof,func,inList,mresult,result]() { auto _1687 = result; switch (   _1687.type) {  case Prod: {auto _1689 = *(std::static_pointer_cast<_Sigma_Prod<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>(_1687.data));auto output = _1689._1;auto rest1 = _1689._2;auto _1692 = output;auto _1690 = _Maybe<_List<A>>::_Just(_1692);auto _1688 = returnIO<_Maybe<_List<A>>>(_1690); return _1688;}} }(); return _1685;} case Nothing: {auto _1694 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>>(_1684.data));auto _1695 = _Maybe<_List<A>>::_Nothing();auto _1693 = returnIO<_Maybe<_List<A>>>(_1695); return _1693;}} }(); return _1683;};auto _1657 = bindEq<_Maybe<_Sigma<_List<A>,_Sigma<_Farm<A>,_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>>,_Maybe<_List<A>>>(_1662)(_1663);auto _1655 = bind<_Unit,_Maybe<_List<A>>>(_1656)(_1657); return _1655;};auto _1648 = bindEq<uint64_t,_Maybe<_List<A>>>(_1650)(_1651); return _1648;} case No: {auto _1698 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1644.data));auto xYProof = _1698._1;auto _1704 = 'E';auto _1706 = 'r';auto _1708 = 'r';auto _1710 = 'o';auto _1712 = 'r';auto _1713 = _List<char>::_Nil();auto _1711 = _List<char>::_Cons(_1712,_1713);auto _1709 = _List<char>::_Cons(_1710,_1711);auto _1707 = _List<char>::_Cons(_1708,_1709);auto _1705 = _List<char>::_Cons(_1706,_1707);auto _1703 = _List<char>::_Cons(_1704,_1705);auto _1699 = print(_1703);auto _1714 = _Maybe<_List<A>>::_Nothing();auto _1700 = returnIO<_Maybe<_List<A>>>(_1714);auto _1697 = bind<_Unit,_Maybe<_List<A>>>(_1699)(_1700); return _1697;}} }(); return _1642;} case No: {auto _1717 = *(std::static_pointer_cast<_Dec_No<_TyEq>>(_1638.data));auto cXProof = _1717._1;auto _1723 = 'E';auto _1725 = 'r';auto _1727 = 'r';auto _1729 = 'o';auto _1731 = 'r';auto _1732 = _List<char>::_Nil();auto _1730 = _List<char>::_Cons(_1731,_1732);auto _1728 = _List<char>::_Cons(_1729,_1730);auto _1726 = _List<char>::_Cons(_1727,_1728);auto _1724 = _List<char>::_Cons(_1725,_1726);auto _1722 = _List<char>::_Cons(_1723,_1724);auto _1718 = print(_1722);auto _1733 = _Maybe<_List<A>>::_Nothing();auto _1719 = returnIO<_Maybe<_List<A>>>(_1733);auto _1716 = bind<_Unit,_Maybe<_List<A>>>(_1718)(_1719); return _1716;}} }(); return _1636;} case Yes: {auto _1736 = *(std::static_pointer_cast<_Dec_Yes<_TyEq>>(_1633.data));auto numWeq0 = _1736._1;auto _1742 = 'E';auto _1744 = 'r';auto _1746 = 'r';auto _1748 = 'o';auto _1750 = 'r';auto _1751 = _List<char>::_Nil();auto _1749 = _List<char>::_Cons(_1750,_1751);auto _1747 = _List<char>::_Cons(_1748,_1749);auto _1745 = _List<char>::_Cons(_1746,_1747);auto _1743 = _List<char>::_Cons(_1744,_1745);auto _1741 = _List<char>::_Cons(_1742,_1743);auto _1737 = print(_1741);auto _1752 = _Maybe<_List<A>>::_Nothing();auto _1738 = returnIO<_Maybe<_List<A>>>(_1752);auto _1735 = bind<_Unit,_Maybe<_List<A>>>(_1737)(_1738); return _1735;}} }(); return _1631;} case No: {auto _1755 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1623.data));auto cChidsProof = _1755._1;auto _1761 = 'E';auto _1763 = 'r';auto _1765 = 'r';auto _1767 = 'o';auto _1769 = 'r';auto _1770 = _List<char>::_Nil();auto _1768 = _List<char>::_Cons(_1769,_1770);auto _1766 = _List<char>::_Cons(_1767,_1768);auto _1764 = _List<char>::_Cons(_1765,_1766);auto _1762 = _List<char>::_Cons(_1763,_1764);auto _1760 = _List<char>::_Cons(_1761,_1762);auto _1756 = print(_1760);auto _1771 = _Maybe<_List<A>>::_Nothing();auto _1757 = returnIO<_Maybe<_List<A>>>(_1771);auto _1754 = bind<_Unit,_Maybe<_List<A>>>(_1756)(_1757); return _1754;}} }(); return _1621;} case No: {auto _1774 = *(std::static_pointer_cast<_Dec_No<_UniqueVec<uint64_t>>>(_1613.data));auto cPidsProof = _1774._1;auto _1780 = 'E';auto _1782 = 'r';auto _1784 = 'r';auto _1786 = 'o';auto _1788 = 'r';auto _1789 = _List<char>::_Nil();auto _1787 = _List<char>::_Cons(_1788,_1789);auto _1785 = _List<char>::_Cons(_1786,_1787);auto _1783 = _List<char>::_Cons(_1784,_1785);auto _1781 = _List<char>::_Cons(_1782,_1783);auto _1779 = _List<char>::_Cons(_1780,_1781);auto _1775 = print(_1779);auto _1790 = _Maybe<_List<A>>::_Nothing();auto _1776 = returnIO<_Maybe<_List<A>>>(_1790);auto _1773 = bind<_Unit,_Maybe<_List<A>>>(_1775)(_1776); return _1773;}} }(); return _1612;}; return _1611;}; return _1610;}; return _1609;}; return _1608;}; return _1607;}; return _1606;}; return _1605;}; return _1604;}; return _1603;}; return _1602;};

template <class A> std::function<std::function<std::function<std::function<_IO<_Unit>(_Vec<uint64_t>)>(_Vec<uint64_t>)>(std::function<A(A)>)>(_List<A>)> sixCoreTest2 = [](auto inList) { auto _1792 = [inList](auto func) { auto _1793 = [inList,func](auto pidSet) { auto _1794 = [inList,func,pidSet](auto chidSet) { auto _1800 = inList;auto _1801 = func;auto _1802 = (uint64_t)4;auto _1803 = (uint64_t)7;auto _1804 = pidSet;auto _1805 = (uint64_t)5;auto _1812 = (uint64_t)12;auto _1815 = (uint64_t)11;auto _1818 = (uint64_t)10;auto _1821 = (uint64_t)9;auto _1824 = (uint64_t)8;auto _1825 = _Vec<uint64_t>::_NilV();auto _1822 = _Vec<uint64_t>::_ConsV(_1824,_1825);auto _1819 = _Vec<uint64_t>::_ConsV(_1821,_1822);auto _1816 = _Vec<uint64_t>::_ConsV(_1818,_1819);auto _1813 = _Vec<uint64_t>::_ConsV(_1815,_1816);auto _1806 = _Vec<uint64_t>::_ConsV(_1812,_1813);auto _1807 = (uint64_t)7;auto _1808 = chidSet;auto _1809 = (uint64_t)5;auto _1827 = (uint64_t)12;auto _1830 = (uint64_t)11;auto _1833 = (uint64_t)10;auto _1836 = (uint64_t)9;auto _1839 = (uint64_t)8;auto _1840 = _Vec<uint64_t>::_NilV();auto _1837 = _Vec<uint64_t>::_ConsV(_1839,_1840);auto _1834 = _Vec<uint64_t>::_ConsV(_1836,_1837);auto _1831 = _Vec<uint64_t>::_ConsV(_1833,_1834);auto _1828 = _Vec<uint64_t>::_ConsV(_1830,_1831);auto _1810 = _Vec<uint64_t>::_ConsV(_1827,_1828);auto _1796 = runFarm<A>(_1800)(_1801)(_1802)(_1803)(_1804)(_1805)(_1806)(_1807)(_1808)(_1809)(_1810);auto _1797 = [inList,func,pidSet,chidSet](auto mresult3) { auto _1842 = [inList,func,pidSet,chidSet,mresult3]() { auto _1843 = mresult3; switch (   _1843.type) {  case Just: {auto _1845 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1843.data));auto result3 = _1845._1;auto _1844 = [inList,func,pidSet,chidSet,mresult3,result3]() { auto _1846 = result3; switch (   _1846.type) {  case Prod: {auto _1848 = *(std::static_pointer_cast<_Sigma_Prod<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1846.data));auto pidStuff3 = _1848._1;auto chidStuff3 = _1848._2;auto _1847 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3]() { auto _1849 = pidStuff3; switch (   _1849.type) {  case Prod: {auto _1851 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1849.data));auto pidSet3 = _1851._1;auto pidSet3Pf = _1851._2;auto _1850 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3]() { auto _1852 = chidStuff3; switch (   _1852.type) {  case Prod: {auto _1854 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1852.data));auto chidSet3 = _1854._1;auto chidSet3Pf = _1854._2;auto _1859 = inList;auto _1860 = func;auto _1861 = (uint64_t)5;auto _1862 = (uint64_t)12;auto _1863 = pidSet3;auto _1864 = (uint64_t)6;auto _1871 = (uint64_t)18;auto _1874 = (uint64_t)17;auto _1877 = (uint64_t)16;auto _1880 = (uint64_t)15;auto _1883 = (uint64_t)14;auto _1886 = (uint64_t)13;auto _1887 = _Vec<uint64_t>::_NilV();auto _1884 = _Vec<uint64_t>::_ConsV(_1886,_1887);auto _1881 = _Vec<uint64_t>::_ConsV(_1883,_1884);auto _1878 = _Vec<uint64_t>::_ConsV(_1880,_1881);auto _1875 = _Vec<uint64_t>::_ConsV(_1877,_1878);auto _1872 = _Vec<uint64_t>::_ConsV(_1874,_1875);auto _1865 = _Vec<uint64_t>::_ConsV(_1871,_1872);auto _1866 = (uint64_t)12;auto _1867 = chidSet3;auto _1868 = (uint64_t)6;auto _1889 = (uint64_t)18;auto _1892 = (uint64_t)17;auto _1895 = (uint64_t)16;auto _1898 = (uint64_t)15;auto _1901 = (uint64_t)14;auto _1904 = (uint64_t)13;auto _1905 = _Vec<uint64_t>::_NilV();auto _1902 = _Vec<uint64_t>::_ConsV(_1904,_1905);auto _1899 = _Vec<uint64_t>::_ConsV(_1901,_1902);auto _1896 = _Vec<uint64_t>::_ConsV(_1898,_1899);auto _1893 = _Vec<uint64_t>::_ConsV(_1895,_1896);auto _1890 = _Vec<uint64_t>::_ConsV(_1892,_1893);auto _1869 = _Vec<uint64_t>::_ConsV(_1889,_1890);auto _1855 = runFarm<A>(_1859)(_1860)(_1861)(_1862)(_1863)(_1864)(_1865)(_1866)(_1867)(_1868)(_1869);auto _1856 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3,chidSet3](auto mresult4) { auto _1907 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3,chidSet3,mresult4]() { auto _1908 = mresult4; switch (   _1908.type) {  case Just: {auto _1910 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1908.data));auto result4 = _1910._1;auto _1909 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3,chidSet3,mresult4,result4]() { auto _1911 = result4; switch (   _1911.type) {  case Prod: {auto _1913 = *(std::static_pointer_cast<_Sigma_Prod<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_1911.data));auto pidStuff4 = _1913._1;auto chidStuff4 = _1913._2;auto _1912 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3,chidSet3,mresult4,result4,pidStuff4,chidStuff4]() { auto _1914 = pidStuff4; switch (   _1914.type) {  case Prod: {auto _1916 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1914.data));auto pidSet4 = _1916._1;auto pidSet4Pf = _1916._2;auto _1915 = [inList,func,pidSet,chidSet,mresult3,result3,pidStuff3,chidStuff3,pidSet3,chidSet3,mresult4,result4,pidStuff4,chidStuff4,pidSet4]() { auto _1917 = chidStuff4; switch (   _1917.type) {  case Prod: {auto _1919 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_1917.data));auto chidSet4 = _1919._1;auto chidSet4Pf = _1919._2;auto _1924 = inList;auto _1925 = func;auto _1926 = (uint64_t)6;auto _1927 = (uint64_t)18;auto _1928 = pidSet4;auto _1929 = (uint64_t)7;auto _1936 = (uint64_t)25;auto _1939 = (uint64_t)24;auto _1942 = (uint64_t)23;auto _1945 = (uint64_t)22;auto _1948 = (uint64_t)21;auto _1951 = (uint64_t)20;auto _1954 = (uint64_t)19;auto _1955 = _Vec<uint64_t>::_NilV();auto _1952 = _Vec<uint64_t>::_ConsV(_1954,_1955);auto _1949 = _Vec<uint64_t>::_ConsV(_1951,_1952);auto _1946 = _Vec<uint64_t>::_ConsV(_1948,_1949);auto _1943 = _Vec<uint64_t>::_ConsV(_1945,_1946);auto _1940 = _Vec<uint64_t>::_ConsV(_1942,_1943);auto _1937 = _Vec<uint64_t>::_ConsV(_1939,_1940);auto _1930 = _Vec<uint64_t>::_ConsV(_1936,_1937);auto _1931 = (uint64_t)18;auto _1932 = chidSet4;auto _1933 = (uint64_t)7;auto _1957 = (uint64_t)25;auto _1960 = (uint64_t)24;auto _1963 = (uint64_t)23;auto _1966 = (uint64_t)22;auto _1969 = (uint64_t)21;auto _1972 = (uint64_t)20;auto _1975 = (uint64_t)19;auto _1976 = _Vec<uint64_t>::_NilV();auto _1973 = _Vec<uint64_t>::_ConsV(_1975,_1976);auto _1970 = _Vec<uint64_t>::_ConsV(_1972,_1973);auto _1967 = _Vec<uint64_t>::_ConsV(_1969,_1970);auto _1964 = _Vec<uint64_t>::_ConsV(_1966,_1967);auto _1961 = _Vec<uint64_t>::_ConsV(_1963,_1964);auto _1958 = _Vec<uint64_t>::_ConsV(_1960,_1961);auto _1934 = _Vec<uint64_t>::_ConsV(_1957,_1958);auto _1920 = runFarm<A>(_1924)(_1925)(_1926)(_1927)(_1928)(_1929)(_1930)(_1931)(_1932)(_1933)(_1934);auto _1921 = end;auto _1918 = bind<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1920)(_1921); return _1918;}} }(); return _1915;}} }(); return _1912;}} }(); return _1909;} case Nothing: {auto _1979 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1908.data));auto _1978 = end; return _1978;}} }(); return _1907;};auto _1853 = bindEq<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1855)(_1856); return _1853;}} }(); return _1850;}} }(); return _1847;}} }(); return _1844;} case Nothing: {auto _1981 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_1843.data));auto _1980 = end; return _1980;}} }(); return _1842;};auto _1795 = bindEq<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1796)(_1797); return _1795;}; return _1794;}; return _1793;}; return _1792;};

template <class A> std::function<std::function<_IO<_Unit>(std::function<A(A)>)>(_List<A>)> sixCoreTest = [](auto inList) { auto _1982 = [inList](auto func) { auto _1988 = inList;auto _1989 = func;auto _1984 = baseRun<A>(_1988)(_1989);auto _1995 = inList;auto _1996 = func;auto _1997 = (uint64_t)2;auto _1998 = (uint64_t)0;auto _1999 = _Vec<uint64_t>::_NilV();auto _2000 = (uint64_t)3;auto _2007 = (uint64_t)3;auto _2010 = (uint64_t)2;auto _2013 = (uint64_t)1;auto _2014 = _Vec<uint64_t>::_NilV();auto _2011 = _Vec<uint64_t>::_ConsV(_2013,_2014);auto _2008 = _Vec<uint64_t>::_ConsV(_2010,_2011);auto _2001 = _Vec<uint64_t>::_ConsV(_2007,_2008);auto _2002 = (uint64_t)0;auto _2003 = _Vec<uint64_t>::_NilV();auto _2004 = (uint64_t)3;auto _2016 = (uint64_t)3;auto _2019 = (uint64_t)2;auto _2022 = (uint64_t)1;auto _2023 = _Vec<uint64_t>::_NilV();auto _2020 = _Vec<uint64_t>::_ConsV(_2022,_2023);auto _2017 = _Vec<uint64_t>::_ConsV(_2019,_2020);auto _2005 = _Vec<uint64_t>::_ConsV(_2016,_2017);auto _1991 = runFarm<A>(_1995)(_1996)(_1997)(_1998)(_1999)(_2000)(_2001)(_2002)(_2003)(_2004)(_2005);auto _1992 = [inList,func](auto mResult1) { auto _2025 = [inList,func,mResult1]() { auto _2026 = mResult1; switch (   _2026.type) {  case Just: {auto _2028 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_2026.data));auto result1 = _2028._1;auto _2027 = [inList,func,mResult1,result1]() { auto _2029 = result1; switch (   _2029.type) {  case Prod: {auto _2031 = *(std::static_pointer_cast<_Sigma_Prod<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_2029.data));auto pidStuff1 = _2031._1;auto chidStuff1 = _2031._2;auto _2030 = [inList,func,mResult1,result1,pidStuff1,chidStuff1]() { auto _2032 = pidStuff1; switch (   _2032.type) {  case Prod: {auto _2034 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_2032.data));auto pidSet1 = _2034._1;auto pidSet1Pf = _2034._2;auto _2033 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1]() { auto _2035 = chidStuff1; switch (   _2035.type) {  case Prod: {auto _2037 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_2035.data));auto chidSet1 = _2037._1;auto chidSet1Pf = _2037._2;auto _2042 = inList;auto _2043 = func;auto _2044 = (uint64_t)3;auto _2045 = (uint64_t)3;auto _2046 = pidSet1;auto _2047 = (uint64_t)4;auto _2054 = (uint64_t)7;auto _2057 = (uint64_t)6;auto _2060 = (uint64_t)5;auto _2063 = (uint64_t)4;auto _2064 = _Vec<uint64_t>::_NilV();auto _2061 = _Vec<uint64_t>::_ConsV(_2063,_2064);auto _2058 = _Vec<uint64_t>::_ConsV(_2060,_2061);auto _2055 = _Vec<uint64_t>::_ConsV(_2057,_2058);auto _2048 = _Vec<uint64_t>::_ConsV(_2054,_2055);auto _2049 = (uint64_t)3;auto _2050 = chidSet1;auto _2051 = (uint64_t)4;auto _2066 = (uint64_t)7;auto _2069 = (uint64_t)6;auto _2072 = (uint64_t)5;auto _2075 = (uint64_t)4;auto _2076 = _Vec<uint64_t>::_NilV();auto _2073 = _Vec<uint64_t>::_ConsV(_2075,_2076);auto _2070 = _Vec<uint64_t>::_ConsV(_2072,_2073);auto _2067 = _Vec<uint64_t>::_ConsV(_2069,_2070);auto _2052 = _Vec<uint64_t>::_ConsV(_2066,_2067);auto _2038 = runFarm<A>(_2042)(_2043)(_2044)(_2045)(_2046)(_2047)(_2048)(_2049)(_2050)(_2051)(_2052);auto _2039 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1,chidSet1](auto mResult2) { auto _2078 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1,chidSet1,mResult2]() { auto _2079 = mResult2; switch (   _2079.type) {  case Just: {auto _2081 = *(std::static_pointer_cast<_Maybe_Just<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_2079.data));auto result2 = _2081._1;auto _2080 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1,chidSet1,mResult2,result2]() { auto _2082 = result2; switch (   _2082.type) {  case Prod: {auto _2084 = *(std::static_pointer_cast<_Sigma_Prod<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>(_2082.data));auto pidStuff2 = _2084._1;auto chidStuff2 = _2084._2;auto _2083 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1,chidSet1,mResult2,result2,pidStuff2,chidStuff2]() { auto _2085 = pidStuff2; switch (   _2085.type) {  case Prod: {auto _2087 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_2085.data));auto pidSet2 = _2087._1;auto pidSet2Pf = _2087._2;auto _2086 = [inList,func,mResult1,result1,pidStuff1,chidStuff1,pidSet1,chidSet1,mResult2,result2,pidStuff2,chidStuff2,pidSet2]() { auto _2088 = chidStuff2; switch (   _2088.type) {  case Prod: {auto _2090 = *(std::static_pointer_cast<_Sigma_Prod<_Vec<uint64_t>,_TyEq>>(_2088.data));auto chidSet2 = _2090._1;auto chidSet2Pf = _2090._2;auto _2091 = inList;auto _2092 = func;auto _2093 = pidSet2;auto _2094 = chidSet2;auto _2089 = sixCoreTest2<A>(_2091)(_2092)(_2093)(_2094); return _2089;}} }(); return _2086;}} }(); return _2083;}} }(); return _2080;} case Nothing: {auto _2097 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_2079.data));auto _2096 = end; return _2096;}} }(); return _2078;};auto _2036 = bindEq<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_2038)(_2039); return _2036;}} }(); return _2033;}} }(); return _2030;}} }(); return _2027;} case Nothing: {auto _2099 = *(std::static_pointer_cast<_Maybe_Nothing<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>>(_2026.data));auto _2098 = end; return _2098;}} }(); return _2025;};auto _1985 = bindEq<_Maybe<_Sigma<_Sigma<_Vec<uint64_t>,_TyEq>,_Sigma<_Vec<uint64_t>,_TyEq>>>,_Unit>(_1991)(_1992);auto _1983 = bind<_Unit,_Unit>(_1984)(_1985); return _1983;}; return _1982;};

std::function<_Vec<uint64_t>(uint64_t)> genList = [](auto n) { auto _2100 = [n]() {auto _2101 = n; if ( !_2101 ) {auto _2103 = (uint64_t)1;auto _2104 = _Vec<uint64_t>::_NilV();auto _2102 = _Vec<uint64_t>::_ConsV(_2103,_2104);return _2102; } else {auto n2 = _2101 - 1;auto _2110 = n2;auto _2109 = _2110 + 1;;auto _2106 = _2109 + 1;;auto _2111 = n2;auto _2107 = genList(_2111);auto _2102 = _Vec<uint64_t>::_ConsV(_2106,_2107);return _2102;} }(); return _2100;};

template <class A> std::function<std::function<std::function<_IO<_Maybe<_List<A>>>(std::function<A(A)>)>(_List<A>)>(uint64_t)> callFarmSimple2 = [](auto nw) { auto _2112 = [nw](auto inList) { auto _2113 = [inList,nw](auto func) { auto _2115 = inList;auto _2116 = func;auto _2117 = nw;auto _2118 = (uint64_t)0;auto _2119 = _Vec<uint64_t>::_NilV();auto _2127 = nw;auto _2120 = _2127 + 1;;auto _2128 = nw;auto _2121 = genList(_2128);auto _2122 = (uint64_t)0;auto _2123 = _Vec<uint64_t>::_NilV();auto _2129 = nw;auto _2124 = _2129 + 1;;auto _2130 = nw;auto _2125 = genList(_2130);auto _2114 = runFarmSimple<A>(_2115)(_2116)(_2117)(_2118)(_2119)(_2120)(_2121)(_2122)(_2123)(_2124)(_2125); return _2114;}; return _2113;}; return _2112;};

std::function<std::function<_IO<_Maybe<uint64_t>>(_List<uint64_t>)>(uint64_t)> runFarmSum = [](auto nw) { auto _2131 = [nw](auto l) { auto _2137 = nw;auto _2138 = l;auto _2139 = euler;auto _2133 = callFarmSimple2<uint64_t>(_2137)(_2138)(_2139);auto _2134 = [nw,l](auto result) { auto _2141 = [nw,l,result]() { auto _2142 = result; switch (   _2142.type) {  case Just: {auto _2144 = *(std::static_pointer_cast<_Maybe_Just<_List<uint64_t>>>(_2142.data));auto res = _2144._1;auto _2148 = res;auto _2147 = sum(_2148);auto _2145 = _Maybe<uint64_t>::_Just(_2147);auto _2143 = returnIO<_Maybe<uint64_t>>(_2145); return _2143;} case Nothing: {auto _2150 = *(std::static_pointer_cast<_Maybe_Nothing<_List<uint64_t>>>(_2142.data));auto _2151 = _Maybe<uint64_t>::_Nothing();auto _2149 = returnIO<_Maybe<uint64_t>>(_2151); return _2149;}} }(); return _2141;};auto _2132 = bindEq<_Maybe<_List<uint64_t>>,_Maybe<uint64_t>>(_2133)(_2134); return _2132;}; return _2131;};

std::function<_List<uint64_t>(uint64_t)> genListI = [](auto n) { auto _2153 = [n]() {auto _2154 = n; if ( !_2154 ) {auto _2155 = _List<uint64_t>::_Nil();return _2155; } else {auto m = _2154 - 1;auto _2156 = (uint64_t)1000;auto _2158 = m;auto _2157 = genListI(_2158);auto _2155 = _List<uint64_t>::_Cons(_2156,_2157);return _2155;} }(); return _2153;};

_IO<_Unit> mainFunc = []() {auto _2164 = (uint64_t)28;auto _2166 = (uint64_t)1000;auto _2167 = (uint64_t)0;auto _2165 = mkList(_2166)(_2167);auto _2160 = runFarmSum(_2164)(_2165);auto _2161 = end;auto _2159 = bind<_Maybe<uint64_t>,_Unit>(_2160)(_2161); return _2159;}();
//////////////////////////////////////
// GLOBAL STATE AND HELPER FUNCTION //
//////////////////////////////////////



// Helper functions for pids
std::thread* getThread(uint64_t pid) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(pidMutex);

  // return the information
  return pidsMap[pid];
}

void addThread(uint64_t pid, std::thread* t) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(pidMutex);

  // Adding the thread, will never overwrite
  pidsMap[pid] = t;
}

// Helper functions for channels
void* getChannel(uint64_t chid) {
  // Aquiring the lock
  std::lock_guard<std::mutex> lock(channelMutex);

  //  returning the channel
  return channelsMap[chid];
}

template <typename A>
void addChannel(uint64_t chid, LockingCQueue<_Maybe<A>>* queue) {
  // Aquireing the lock
  std::lock_guard<std::mutex> lock(channelMutex);

  // adding the channel
  channelsMap[chid] = queue;
}


int main(){}