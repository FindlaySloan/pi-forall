module NewProofs where

data Maybe (A : Type) : Type where
  Nothing
  Just of (A)

-- data Void : Type where {}

-- data Dec (prop : Type) : Type where 
--   Yes of (prf : prop)
--   No  of (cont : prop -> Void)

-- f_equal :  [A:Type] -> [B : Type] -> [f : A -> B] -> [x:A] -> [y:A] -> x = y -> f x = f y
-- f_equal = \[A][B][f][x][y] pf . 
--   subst Refl by pf

-- ZnotS : (n : Nat) -> (Zero = Succ n) -> Void 
-- ZnotS = \n r . contra r

-- sym : [A:Type] -> [x:A] -> [y:A] -> (x = y) -> y = x
-- sym = \ [A] [x] [y] pf .
--   subst Refl by pf 

-- negEqSym : [t : Type]-> [a : t]-> [b : t] -> (a = b -> Void) -> (b = a -> Void)
-- negEqSym = \[t] [a] [b] p h . p (sym [t] [b] [a] h)

-- pred : Nat -> Nat
-- pred = \n . case n of 
--     Zero -> Zero
--     Succ m -> m

-- succInjective : [left : Nat] -> [right : Nat] -> (p : Succ left = Succ right) -> (left = right)
-- succInjective = \[left] [right] p .
--   f_equal [Nat] [Nat] [pred] [Succ left] [Succ right] p 
  

-- decEqNat : (a : Nat) -> (b : Nat) -> Dec (a = b)
-- decEqNat = \a b . case a of 
--      Zero -> case b of 
--                Zero -> Yes Refl 
--                Succ n -> No (ZnotS n)
--      Succ n -> case b of 
--                 Zero -> No (negEqSym [Nat] [Zero] [Succ n] (ZnotS n))
--                 Succ m -> case (decEqNat n m) of 
--                             Yes p -> Yes (f_equal [Nat] [Nat] [\x . Succ x] [n] [m] p)
--                             No p -> No (\h . p (succInjective [n] [m] h))

f : Maybe Bool -> Maybe Bool -> Maybe Bool
f = \ a b . case a of
  Nothing -> 
    case b of
      Nothing -> Nothing
      Just g -> Nothing
  Just g -> 
    TRUSTME