module Pattern where

import Concurrency
import IO
import Maybe
import ListLib
import ProofHelper
import ProofPrelude
import Vec

data PatternType : Type where
    --PipelineIncomplete
    --PipelineProducer
    Pipeline
    PipelineInner
    Worker
    --Stage
    Farm
    --End

data Pattern (inType : Type) (outType : Type) (type : PatternType) : Type where
    WorkerPat of [inputType : Type] [outputType : Type] (workerPid : Nat) (f : inputType -> outputType) (n : Nat) (pidSet : Vec Nat n) (ElemVec Nat n workerPid pidSet) [type = Worker] [inputType = inType] [outputType = outType]
    -- PipelineProducerPat of [inputType : Type] (producerPid : Nat) (List inputType) [type = PipelineProducer] [inputType = inType] [inputType = outType]
    PipelineInnerPat of 
        [inputType : Type] [outputType : Type] (n : Nat) (Vec ({inT : Type | {outT : Type | {headPatternType : PatternType | Pattern inT outT headPatternType}}}) (Succ n))
        (chids : Vec Nat n) (chs : Vec {id : Nat | { A : Type | Channel A id}} n) (pfChidEqChs : chids = (mapV [{id : Nat | { A : Type | Channel A id}}] [Nat] [n] (getChannelId) chs)) (pfChidUnique : UniqueVec Nat n chids) [type = PipelineInner] [inputType = inType] [outputType = outType] -- Include proof that pattern type != any pipeline
    --PipelineIncompletePat of [inputType : Type] [outputType : Type] [type = PipelineIncomplete] [inputType = inType] [outputType = outType]
    PipelinePat of [inputType : Type] [outputType : Type]  [producerPid : Nat] [consumerPid : Nat] [producerChid : Nat] [consumerChid : Nat] [inner : Pattern inputType outputType PipelineInner] [type = Pipeline] [inputType = inType] [outputType = outType]

getNFromPipelineInner : [inT : Type] -> [outT : Type] -> (Pattern inT outT PipelineInner) -> (Nat)
getNFromPipelineInner = \ [inT] [outT] p . case p of
    PipelineInnerPat [inT] [outT] m pats chids chs pfchsEqchids pfChidUnique -> m 

getChidFromPipelineInner : [inT : Type] -> [outT : Type] -> (p1: Pattern inT outT PipelineInner) -> (Vec Nat (getNFromPipelineInner [inT] [outT] p1))
getChidFromPipelineInner = \ [inT] [outT] p . case p of
    PipelineInnerPat [inT] [outT] m pats chids chs pfchsEqchids pfChidUnique -> chids

producerWrapper : [A : Type] -> (chid : Nat) -> Channel A chid -> List A -> IO Unit
producerWrapper = \ [A] id ch list . 
    case list of
        Nil         -> bind [Unit] [Unit] (send [A] id Nothing ch) (end)
        Cons x xs   -> bind [Unit] [Unit] (send [A] id (Just x) ch) (producerWrapper [A] id ch xs)

workerWrapper : [A : Type] -> [B : Type] -> (w : Pattern A B Worker) -> (receiveId : Nat) -> (sendId : Nat) -> Channel A receiveId  -> Channel B sendId -> IO Unit
workerWrapper = \ [A] [B] w receiveId sendId receiveChannel sendChannel .
    case w of
        WorkerPat [inT] [outT] workerPid f n pidSet pf ->
            bindEq [Maybe A] [Unit] (receive [A] receiveId receiveChannel) (\ mx . 
            case mx of
                Nothing -> bind [Unit] [Unit] (send [B] sendId Nothing sendChannel) (end)
                Just x  -> bind [Unit] [Unit] (send [B] sendId (Just (f x)) sendChannel) (workerWrapper [A] [B] w receiveId sendId receiveChannel sendChannel)
            )

consumerWrapper : [A : Type] -> (chid : Nat) -> Channel A chid -> IO (List A)
consumerWrapper = \ [A] chid ch .
    bindEq [Maybe A] [List A] (receive [A] chid ch) (\ mx .
        case mx of
            Nothing -> returnIO [List A] Nil
            Just x  -> bindEq [List A] [List A] 
                        (consumerWrapper [A] chid ch) (\ res . 
                            returnIO [List A] (Cons x res))
        )

runPipelineInner : [A : Type] -> [B : Type] -> (p : Pattern A B PipelineInner) -> (producerChid : Nat) -> (consumerChid : Nat) -> (pCh : Channel A producerChid) -> (cCh : Channel B consumerChid) -> IO Unit
runPipelineInner = \[A] [B] p pChid cChid pCh cCh . case p of
    PipelineInnerPat [inT] [outT] n pats chids chs pfChsEqChids pfChidUnique ->  case pats of
        -- NilV -> returnIO [Unit] ()
        ConsV [m] x xs -> 
            case xs of
                NilV ->
                    let (inputType, rest) = x in
                    let (outputType, rest1) = rest in 
                    let (patternType, pattern) = rest1 in
                    case patternType of
                        Pipeline -> returnIO [Unit] () -- Impossible
                        PipelineInner -> returnIO [Unit] () -- Impossible
                        Worker ->
                            case pattern of
                                WorkerPat [wIn] [wOut] wPid f i pidSet pf ->
                                    bindEq [Maybe ({returnedPidSet : Vec Nat i | pidSet = returnedPidSet})] [Unit] (run wPid i pidSet pf (workerWrapper [inputType] [outputType] pattern pChid cChid pCh cCh)) 
                                    (\ mres . case mres of
                                        Nothing  -> returnIO [Unit] () -- Couldn't run function
                                        Just pfs -> returnIO [Unit] () -- Function Ran, finished pipeline running
                                    )-- Lenght 1 special case                            
                        Farm -> returnIO [Unit] () -- TODO
                    
                ConsV _ _ _ ->
                    let (inputType, rest) = x in
                    let (outputType, rest1) = rest in 
                    let (patternType, pattern) = rest1 in
                    case patternType of
                        Pipeline -> returnIO [Unit] () -- Impossible
                        PipelineInner -> returnIO [Unit] () -- Impossible
                        Worker -> 
                            case pattern of
                                WorkerPat [wIn] [wOut] wPid f i pidSet pf ->
                                    case chs of
                                        ConsV [k] c cs ->
                                            let (cid, ch) = c in
                                            bindEq [Maybe ({returnedPidSet : Vec Nat i | pidSet = returnedPidSet})] [Unit] (run wPid i pidSet pf (workerWrapper [wIn] [B] pattern cid cChid ch cCh)) 
                                            (\ mres . case mres of
                                                Nothing  -> returnIO [Unit] () -- Couldn't run function
                                                Just pfs -> TRUSTME --runPipelineInnerRest [B] (pred n) xs pChid pCh  -- Function Ran, running rest of pipeline
                                            )-- Lenght 1 special case  
                        Farm -> returnIO [Unit] () -- TODO
                    
{--
runPipelineInnerRest : [finalType : Type] -> (n : Nat) -> (ps : Vec {inT : Type | {outT : Type | {headPatternType : PatternType | Pattern inT outT headPatternType}}} n) -> (consumerChid : Nat) -> (cCh : Channel finalType consumerChid) -> IO Unit 
runPipelineInnerRest = \ [fT] n ps cChid cCh . case ps of
    NilV            -> returnIO [Unit] () -- Impossible
    ConsV [m] x xs  -> 
        case xs of
            NilV        ->
                let (inputType, rest) = x in
                let (outputType, rest1) = rest in 
                let (patternType, pattern) = rest1 in
                case patternType of
                    Pipeline -> returnIO [Unit] () -- Impossible
                    PipelineInner -> returnIO [Unit] () -- Impossible
                    Worker ->
                        case pattern of
                            WorkerPat [wIn] [wOut] wPid f i pidSet pf ->
                                bindEq [Maybe ({returnedPidSet : Vec Nat i | pidSet = returnedPidSet})] [Unit] (run wPid i pidSet pf f) 
                                (\ mres . case mres of
                                    Nothing  -> returnIO [Unit] () -- Couldn't run function
                                    Just pfs -> returnIO [Unit] () -- Function Ran
                                )-- Lenght 1 special case                            
                    Farm -> returnIO [Unit] () -- TODO
            ConsV _ _ _ ->
                let (inputType, rest) = x in
                let (outputType, rest1) = rest in 
                let (patternType, pattern) = rest1 in
                case patternType of
                    Pipeline -> returnIO [Unit] () -- Impossible
                    PipelineInner -> returnIO [Unit] () -- Impossible
                    Worker ->
                        case pattern of
                            WorkerPat [wIn] [wOut] wPid f i pidSet pf ->
                                bindEq [Maybe ({returnedPidSet : Vec Nat i | pidSet = returnedPidSet})] [Unit] (run wPid i pidSet pf f) 
                                (\ mres . case mres of
                                    Nothing  -> returnIO [Unit] () -- Couldn't run function
                                    Just pfs -> returnIO [Unit] () -- Function Ran
                                )-- Lenght 1 special case                            
                    Farm -> returnIO [Unit] () -- TODO
--}



createWorker : [inputType : Type] -- Input Type for the stage
            -> [outputType : Type] -- Output type for the stage
            -> (pid : Nat) -- The pid used to create the stage
            -> (n : Nat) -- The size of the pid set
            -> (pidSet : Vec Nat n) -- The current pid set
            -> (Not (ElemVec Nat n pid pidSet)) -- Proof that the pid is not currently in the pid set
            -> (f : inputType -> outputType) -- The function that will be run by the worker TODO: Needs refined type information to ensure f doesn't spawn channels or processes
            -> IO (Maybe ((Pattern inputType outputType Worker) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] pid pidSet : Vec Nat (Succ n)) = newPidSet})) -- Returns in IO so that operations can be binded together. Returns the Pattern and also the new set
createWorker = \ [inputType] [outputType] inPid n pidSet pidNotInPidSetPf f . 
    bindEq [Maybe ({newPid : Nat | {newPidSet : Vec Nat (Succ n) | (inPid = newPid) * ((ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet) }})] [Maybe ((Pattern inputType outputType Worker) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})]
        (spawn inPid n pidSet pidNotInPidSetPf)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inputType outputType Worker) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})] Nothing -- Cound't spawn pid
            Just res    -> let (pid, rest) = res in
                           let (newPidSet, pfs) = rest in
                           let (pidEq, pfPidSetCorrect) = pfs in
                           returnIO [Maybe ((Pattern inputType outputType Worker) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})] 
                                    (Just (WorkerPat [inputType] [outputType] pid f, (ConsV [n] pid pidSet, subst (subst Refl by pfPidSetCorrect) by pidEq))))
{--
concatInitial : (inputW1 : Type) -- The input type of w1
             -> (outputW1 : Type) -- The output type of w1
             -> (inputW2 : Type) -- The input type of w2
             -> (outputw2 : Type) -- The output type of w2
             -> (typeEqPf : outputW1 = inputW2) -- Proof that the types will match up for the channel
             -> (w1 : Pattern inputW1 outputW1 Worker) -- The first worker
             -> (w2 : Pattern inputW2 outputw2 Worker) -- The second worker
             -> (chid : Nat) -- The channel id used to combine the two workers
             -> (n : Nat) -- The size of the chid set
             -> (chidSet : Vec Nat n) -- The chid set
             -> (Not (ElemVec Nat n chid chidSet)) -- A proof that the given chid is not currently in the chid set
             -> (IO (Maybe ((Pattern inputW1 outputw2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] chid chidSet : Vec Nat (Succ n)) = newChidSet})))
concatInitial = \ inW1 outW1 inW2 outW2 outW1EqinW2Pf w1 w2 inChid n chidSet chidNoInChidSetPf . 
    bindEq [Maybe ({chid : Nat | (Channel outW1 chid) * {newIdSet : Vec Nat (Succ n) | (inChid = chid) * (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newIdSet}})] [Maybe ((Pattern inW1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})]
        (link [outW1] inChid n chidSet chidNoInChidSetPf)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inW1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] Nothing
            Just res    -> let (resChid, rest) = res in
                           let (ch, rest2) = rest in
                           let (newChidSet, pfs) = rest2 in
                           let (idEqChidPf, pfChidSetCorrect) = pfs in
                           returnIO [Maybe ((Pattern inW1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] 
                                    (Just ((PipelineInnerPat [inW1] [outW2] 1 (ConsV [1] (inW1, (outW1, (Worker, w1))) (ConsV [0] (inW2, (outW2, (Worker, w2))) NilV)) (ConsV [0] resChid NilV) (UConsV 0 resChid NilV (xNotInNilV [Nat] [0] [resChid]) UNilV)), (ConsV [n] resChid chidSet, subst (subst Refl by pfChidSetCorrect) by idEqChidPf))))
--}
createInnerPipelineFromWorker : (inputType : Type) -- The input type of w
                             -> (outputType : Type) -- The output type of w
                             -> (w : Pattern inputType outputType Worker) -- The  worker
                             -> (chid : Nat) -- The channel id used to combine the two patterns
                             -> (n : Nat) -- The size of the chid set
                             -> (chidSet : Vec Nat n) -- The chid set
                             -> (Not (ElemVec Nat n chid chidSet)) -- A proof that the given chid is not currently in the chid set
                             -> (IO((Pattern inputType outputType PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] chid chidSet : Vec Nat (Succ n)) = newChidSet}))
createInnerPipelineFromWorker = \ inputType outputType w chid n chidSet pfChidNotInChidSet .
    returnIO [(Pattern inputType outputType PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] chid chidSet : Vec Nat (Succ n)) = newChidSet}]
    (PipelineInnerPat [inputType] [outputType] 0 (ConsV [0] (inputType, (outputType, (Worker, w))) NilV) NilV NilV Refl UNilV, (ConsV [n] chid chidSet, Refl))


concatWorker : (inputP1 : Type) -- The input type of p1
            -> (outputP1 : Type) -- The output type of p1
            -> (inputW2 : Type) -- The input type of w2
            -> (outputw2 : Type) -- The output type of w2
            -> (typeEqPf : outputP1 = inputW2) -- Proof that the types will match up for the channel
            -> (p1 : Pattern inputP1 outputP1 PipelineInner) -- The first pipeline inner
            -> (w2 : Pattern inputW2 outputw2 Worker) -- The second worker
            -> (chid : Nat) -- The channel id used to combine the two patterns
            -> (n : Nat) -- The size of the chid set
            -> (chidSet : Vec Nat n) -- The chid set
            -> (Not (ElemVec Nat n chid chidSet)) -- A proof that the given chid is not currently in the chid set
            -> (Not (ElemVec Nat (getNFromPipelineInner [inputP1] [outputP1] p1) chid (getChidFromPipelineInner [inputP1] [outputP1] p1))) -- A proof that the given chid is not curently in the p1ChidSet
            -> (IO (Maybe ((Pattern inputP1 outputw2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] chid chidSet : Vec Nat (Succ n)) = newChidSet})))
concatWorker = \ inP1 outP1 inW2 outW2 outP1EqInW2Pf p1 w2 inChid n chidSet chidNotInChidSetPf chidNotInP1ChidSetPf .
    bindEq [Maybe ({chid : Nat | (Channel outP1 chid) * {newIdSet : Vec Nat (Succ n) | (inChid = chid) * (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newIdSet}})] [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})]
        (link [outP1] inChid n chidSet chidNotInChidSetPf)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] Nothing
            Just res    -> let (resChid, rest) = res in
                           let (ch, rest2) = rest in
                           let (newChidSet, pfs) = rest2 in
                           let (idEqChidPf, pfChidSetCorrect) = pfs in
                           case p1 of
                            PipelineInnerPat [inT] [outT] m pats chids chs pfchsEqchids pfChidUnique ->
                                returnIO [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] 
                                         (Just ((PipelineInnerPat [inP1] [outW2] (Succ m) (ConsV [Succ m] (inW2, (outW2, (Worker, w2))) pats) (ConsV [m] inChid chids) (ConsV [m] (resChid, (outP1, ch)) chs) (lemma_chid_eq_ch m inChid chids (resChid, (outP1, ch)) chs (idEqChidPf) pfchsEqchids) (UConsV m resChid chids (subst chidNotInP1ChidSetPf by idEqChidPf) pfChidUnique)), (ConsV [n] resChid chidSet, subst (subst Refl by pfChidSetCorrect) by idEqChidPf))))
                                        

{--
concatWorker1 : (inputP1 : Type) -- The input type of p1
             -> (outputP1 : Type) -- The output type of p1
             -> (inputW2 : Type) -- The input type of w2
             -> (outputw2 : Type) -- The output type of w2
             -> (typeEqPf : outputP1 = inputW2) -- Proof that the types will match up for the channel
             -> (p1 : Pattern inputP1 outputP1 PipelineInner) -- The first pipeline inner
             -> (w2 : Pattern inputW2 outputw2 Worker) -- The second worker
             -> (chid : Nat) -- The channel id used to combine the two patterns
             -> (n : Nat) -- The size of the chid set
             -> (chidSet : Vec Nat n) -- The chid set
             -> (Not (ElemVec Nat n chid chidSet)) -- A proof that the given chid is not currently in the chid set
             -> (IO (Maybe ((Pattern inputP1 outputw2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] chid chidSet : Vec Nat (Succ n)) = newChidSet})))
concatWorker1 = \ inP1 outP1 inW2 outW2 outP1EqInW2Pf p1 w2 inChid n chidSet chidNotInChidSetPf .
    bindEq [Maybe ({chid : Nat | (Channel outP1 chid) * {newIdSet : Vec Nat (Succ n) | (inChid = chid) * (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newIdSet}})] [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})]
        (link [outP1] inChid n chidSet chidNotInChidSetPf)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] Nothing
            Just res    -> let (resChid, rest) = res in
                           let (ch, rest2) = rest in
                           let (newChidSet, pfs) = rest2 in
                           let (idEqChidPf, pfChidSetCorrect) = pfs in
                           case p1 of
                            PipelineInnerPat [inT] [outT] m pats chids pfChidUnique ->
                                returnIO [Maybe ((Pattern inP1 outW2 PipelineInner) * {newChidSet : Vec Nat (Succ n) | (ConsV [n] inChid chidSet : Vec Nat (Succ n)) = newChidSet})] 
                                         (Just ((PipelineInnerPat [inP1] [outW2] (Succ m) (ConsV [Succ m] (inW2, (outW2, (Worker, w2))) pats) (ConsV [m] resChid chids) (UConsV 0 resChid NilV (xNotInNilV [Nat] [0] [resChid]) UNilV)), (ConsV [n] resChid chidSet, subst (subst Refl by pfChidSetCorrect) by idEqChidPf)))) -- How proof type checks
--}                                         
                           
createPipeline : [inputType : Type] -- The input type for the pipeline
              -> [outputType : Type] -- The output type for the pipeline
              -> (input : List inputType) -- The input list
              -> (producerPid : Nat) -- The Producer Pid
              -> (consumerPid : Nat) -- The consumer Pid
              -> (Not (producerPid = consumerPid)) -- Proof the two pids are not the same
              -> (n : Nat) -- The length of the pidSet
              -> (pidSet : Vec Nat n) -- The pid set
              -> (Not (ElemVec Nat n producerPid pidSet)) -- Proof that the producer pid is not in the pidSet
              -> (Not (ElemVec Nat n consumerPid pidSet)) -- Proof that the consumer pid is not in the pidSet
              -> (producerChid : Nat) -- The Producer Pid
              -> (consumerChid : Nat) -- The consumer Pid
              -> (Not (producerChid = consumerChid)) -- Prood that the two chids are not equal
              -> (m : Nat) -- The length of the chid set
              -> (chidSet : Vec Nat m) -- The chid set
              -> (Not (ElemVec Nat m producerChid chidSet)) -- Proof that the producerChid is not in the chidSet
              -> (Not (ElemVec Nat m consumerChid chidSet)) -- Proof that the consumerChid is not in the pichidSetdSet
              -> (Pattern inputType outputType PipelineInner) -- The inner pipeline
              -> (IO (Maybe ((Pattern inputType outputType Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})))
createPipeline = \ [inT] [outT] inputList producerPid consumerPid pfProducerPidNeqConsumerPid n pidSet pfProducerPidNotInPidSet pfConsumerPidNotInPidSet producerChid consumerChid pfProducerChidNeqPConsumerChid m chidSet pfProducerChidNotInChidSet pfConsumerChidNotInChidSet pipeInner . 
    bindEq [Maybe ({newPid : Nat | {newPidSet : Vec Nat (Succ n) | (producerPid = newPid) * ((ConsV [n] producerPid pidSet : Vec Nat (Succ n)) = newPidSet) }})] [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})]
        (spawn producerPid n pidSet pfProducerPidNotInPidSet)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] Nothing -- Cound't spawn pid
            Just res    -> let (returnedProducerPid, rest) = res in
                           let (returnedPidSet1, pfs) = rest in
                           let (producerPidEq, pfProducerPidSetCorrect) = pfs in
                           bindEq [Maybe ({newPid : Nat | {newPidSet : Vec Nat (Succ (Succ n)) | (consumerPid = newPid) * ((ConsV [Succ n] consumerPid returnedPidSet1 : Vec Nat (Succ (Succ n))) = newPidSet) }})] [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})]
                            (spawn consumerPid (Succ n) returnedPidSet1 (subst (neitherHereNorThereVec [n] [consumerPid] [producerPid] [pidSet] (negEqSym Nat producerPid consumerPid pfProducerPidNeqConsumerPid) pfConsumerPidNotInPidSet) by pfProducerPidSetCorrect))
                            (\ mres . case mres of
                                Nothing     -> returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] Nothing -- Cound't spawn pid
                                Just res    -> let (returnedConsumerPid, rest) = res in
                                               let (newPidSet, pfs) = rest in
                                               let (consumerPidEq, pfNewPidSetCorrect) = pfs in
                                               bindEq [Maybe ({chid : Nat | (Channel inT chid) * {newIdSet : Vec Nat (Succ m) | (producerChid = chid) * (ConsV [m] producerChid chidSet : Vec Nat (Succ m)) = newIdSet}})] [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})]
                                               (link [inT] producerChid m chidSet pfProducerChidNotInChidSet)
                                               (\ mres . case mres of
                                                Nothing     -> returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] Nothing -- Cound't spawn pid
                                                Just res    -> let (resProducerChid, rest) = res in
                                                               let (producerCh, rest2) = rest in
                                                               let (returnedChidSet, pfs) = rest2 in
                                                               let (idEqProducerChidPf, pfReturnedChidSetCorrect) = pfs in
                                                               bindEq [Maybe ({chid : Nat | (Channel outT chid) * {newIdSet : Vec Nat (Succ (Succ m)) | (consumerChid = chid) * (ConsV [Succ m] consumerChid returnedChidSet : Vec Nat (Succ (Succ m))) = newIdSet}})] [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})]
                                                               (link [outT] consumerChid (Succ m) returnedChidSet ((subst (neitherHereNorThereVec [m] [consumerChid] [producerChid] [chidSet] (negEqSym Nat producerChid consumerChid pfProducerChidNeqPConsumerChid) pfConsumerChidNotInChidSet) by pfReturnedChidSetCorrect)))
                                                               (\ mres . case mres of
                                                                   Nothing     -> returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] Nothing -- Cound't spawn pid
                                                                   Just res    -> let (resConsumerChid, rest) = res in
                                                                                  let (consumerCh, rest2) = rest in
                                                                                  let (newChidSet, pfs) = rest2 in
                                                                                  let (idEqConsumerChidPf, pfNewChidSetCorrect) = pfs in
                                                                                  bindEq [Maybe ({returnedPidSet : Vec Nat (Succ (Succ n)) | newPidSet = returnedPidSet})] [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] 
                                                                                  (run producerPid (Succ (Succ n)) newPidSet (ThereV [Succ n] returnedPidSet1 consumerPid (HereV [n] pidSet)) (producerWrapper [inT] resProducerChid producerCh inputList))
                                                                                  (\ mres . case mres of 
                                                                                    Nothing     -> 
                                                                                        returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] Nothing -- Couldn't run producer
                                                                                    Just pfs    -> 
                                                                                        returnIO [Maybe ((Pattern inT outT Pipeline) * {newChidSet : Vec Nat (Succ (Succ m)) | (ConsV [Succ m] consumerChid (ConsV [m] producerChid chidSet) : Vec Nat (Succ (Succ m))) = newChidSet} * {newPidSet : Vec Nat (Succ (Succ n)) | (ConsV [Succ n] consumerPid (ConsV [n] producerPid pidSet) : Vec Nat (Succ (Succ n))) = newPidSet})] 
                                                                                        (Just ((PipelinePat [inT] [outT] [producerPid] [consumerPid] [producerChid] [consumerChid] [pipeInner]), ((newChidSet, subst (subst pfNewChidSetCorrect by pfReturnedChidSetCorrect) by idEqConsumerChidPf ), (newPidSet, subst (subst pfNewPidSetCorrect by pfProducerPidSetCorrect) by consumerPidEq )))))))))





















createPipelineProducer : [inputType : Type] -- Input Type for the pipeline
                      -> (pid : Nat) -- The pid used to the create the producer for the pipeline
                      -> (n : Nat) -- The size of the pid set
                      -> (pidSet : Vec Nat n) -- The current pid set
                      -> (Not (ElemVec Nat n pid pidSet)) -- Proof that the pid is not currently in the pid set
                      -> (List inputType) -- The input list
                      -> (IO (Maybe ((Pattern inputType inputType PipelineProducer) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] pid pidSet : Vec Nat (Succ n)) = newPidSet})))
createPipelineProducer = \ [inputType] inPid n pidSet pidNotInPidSetPf input.
    bindEq [Maybe ({newPid : Nat | {newPidSet : Vec Nat (Succ n) | (inPid = newPid) * ((ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet) }})] [Maybe ((Pattern inputType inputType PipelineProducer) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})]
        (spawn inPid n pidSet pidNotInPidSetPf)
        (\ mres . case mres of
            Nothing     -> returnIO [Maybe ((Pattern inputType inputType PipelineProducer) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})] Nothing -- Cound't spawn pid
            Just res    -> let (pid, rest) = res in
                           let (newPidSet, pfs) = rest in
                           let (pidEq, pfPidSetCorrect) = pfs in
                           returnIO [Maybe ((Pattern inputType inputType PipelineProducer) * {newPidSet : Vec Nat (Succ n) | (ConsV [n] inPid pidSet : Vec Nat (Succ n)) = newPidSet})] 
                                    (Just (PipelineProducerPat [inputType] pid (input), (ConsV [n] pid pidSet, subst (subst Refl by pfPidSetCorrect) by pidEq) )))

-- | Proofs

data PipelineInnerCorrect (Input : Type) (Output : Type) (n : Nat) (pats : Vec ({inT : Type | {outT : Type | {headPatternType : PatternType | Pattern inT outT headPatternType}}}) (Succ n)) (chs : Vec {id : Nat | { A : Type | Channel A id}} n) : Type where
    Start of (iT : Type) (outT : Type) (patType : PatternType) (p : Pattern patInT outT patType) [n = 0] [iT = Input] [outT = Output] [pats = ConsV [0] p NilV] 