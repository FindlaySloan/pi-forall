module ProofHelper where

import ProofPrelude
import Vec

data ElemVec (A:Type) (n:Nat) (x:A) (v:Vec A n) : Type where
  HereV  of [m:Nat] (xs : Vec A m) [n = Succ m] [v = ConsV [m] x xs]
  ThereV of [m:Nat] (xs : Vec A m) (y:A) (ElemVec A m x xs) [n = Succ m] [v = ConsV [m] y xs]


xNotInNilV : [A : Type] -> [n : Nat] -> [x : A] -> (p : ElemVec A n x NilV) -> Void
xNotInNilV = \ [A] [n] [x] p . case p of {} 

neitherHereNorThereVec : [n : Nat] -> [x : Nat] -> [y : Nat] -> [xs : Vec Nat n] 
                   -> Not (x = y) -> Not (ElemVec Nat n x xs) -> Not (ElemVec Nat (Succ n) x (ConsV [n] y xs))
neitherHereNorThereVec = \[n] [x] [y] [xs] xneqy xninxs p . case p of 
    HereV [m] as -> xneqy Refl
    ThereV [m] as b prf -> xninxs prf

isElemVec : (n : Nat) -> (x : Nat) -> (xs : Vec Nat n) -> Dec (ElemVec Nat n x xs)
isElemVec = \ n x xs . case xs of
  NilV          -> No (ElemVec Nat n x NilV) (xNotInNilV [Nat] [n] [x])
  ConsV [m] y ys -> 
    case (decEqNat x y) of
      Yes pf        -> Yes (subst (HereV [m] ys) by pf)
      No t xneqyPf  -> 
        case (isElemVec (pred n) x ys) of
          Yes pf          -> Yes (ThereV [m] ys x pf)
          No t2 xninysPf  -> No (ElemVec Nat n x (ConsV [m] y ys)) (neitherHereNorThereVec [m] [x] [y] [ys] xneqyPf xninysPf)


data Disjoint (A : Type) (a : List A) (b : List A) : Type where
     DNil of [a = Nil]
     DCons of (x : A) (xs : List A) (pfForx : (Elem A x b) -> Void) (Disjoint A xs b) [a = Cons x xs]

xNotInNil : (A : Type) -> (x : A) -> (p : Elem A x Nil) -> Void
xNotInNil = \ A x p . case p of {} 

lemma_y_empty_disjoint : (A : Type) -> (a : List A) -> (b : List A) -> (b = Nil) -> Disjoint A a b
lemma_y_empty_disjoint = \ A a b pf . case a of
  Nil       -> DNil
  Cons x xs -> DCons x xs (subst xNotInNil A x by pf) (lemma_y_empty_disjoint A xs b pf)

lemma_x_in_b : (A : Type) -> (x : A) -> (a : List A) -> (b : List A) -> (Elem A x (Cons x a)) -> (Elem A x b) -> ((Disjoint A (Cons x a) b) -> Void)
lemma_x_in_b = \ A x a b xInA xInB pf . case pf of 
    DCons i is pfFori others -> pfFori xInB

lemma_xs_in_b : (A : Type) -> (x : A) -> (xs : List A) -> (b : List A) -> ((Disjoint A xs b) -> Void) -> ((Disjoint A (Cons x xs) b) -> Void)
lemma_xs_in_b = \ A x xs b pf p. case p of 
  DCons i is pfFori others  -> pf others

decDisjointLists : (a : List Nat) -> (b : List Nat) -> Dec (Disjoint Nat a b)
decDisjointLists = \ a b . case a of
  Nil       -> Yes (DNil)
  Cons x xs -> 
    case b of
      Nil       -> Yes (lemma_y_empty_disjoint Nat a b (Refl))
      Cons y ys -> 
        case (decDisjointLists xs b) of
          Yes pf    -> 
            case (isElem x b) of
              Yes elemPf  -> No (Disjoint Nat a b) (lemma_x_in_b Nat x xs b (Here x xs) elemPf)
              No prop p   -> Yes (DCons x xs (p) pf)
          No prop p -> No (Disjoint Nat a b) (lemma_xs_in_b Nat x xs b p)

data DisjointVec (A : Type) (n : Nat) (a : Vec A n) (m : Nat) (b : Vec A m) : Type where
  DNilV of [n = 0] [a = NilV]
  DConsV of [n1 : Nat] (x : A) (xs : Vec A n1) (pfForx : Not (ElemVec A m x b))  (DisjointVec A n1 xs m b) [n = Succ n1] [a = ConsV [n1] x xs]

lemma_y_empty_disjoint_vec : (A : Type) -> (n : Nat) -> (a : Vec A n) -> (b : Vec A Zero) -> (b = NilV) -> DisjointVec A n a Zero b
lemma_y_empty_disjoint_vec = \ A n a b pf . case a of
  NilV       -> DNilV
  ConsV [m] x xs -> DConsV [m] x xs (subst xNotInNilV [A] [0] [x] by pf) (lemma_y_empty_disjoint_vec A (pred n) xs b pf)

lemma_x_in_b_vec : (A : Type) -> (x : A) -> (n : Nat) -> (a : Vec A n) -> (m : Nat) -> (b : Vec A m)
                -> (ElemVec A (Succ n) x (ConsV [n] x a)) -> (ElemVec A m x b) -> ((DisjointVec A (Succ n) (ConsV [n] x a) m b) -> Void)
lemma_x_in_b_vec = \ A x n a m b xInA xInB pf . case pf of 
    DConsV [n1] y ys pfFory others -> pfFory xInB

lemma_xs_in_b_vec : (A : Type) -> (x : A) -> (n : Nat) -> (xs : Vec A n) -> (m : Nat) -> (b : Vec A m) 
             -> ((DisjointVec A n xs m b) -> Void) -> ((DisjointVec A (Succ n) (ConsV [n] x xs) m b) -> Void)
lemma_xs_in_b_vec = \ A x n xs m b pf p. case p of 
  DConsV [n1] i is pfFori others  -> pf others

decDisjointVecs : (n : Nat) -> (a : Vec Nat n) -> (m : Nat) -> (b : Vec Nat m) -> Dec (DisjointVec Nat n a m b)
decDisjointVecs = \ n a m b . case a of
  NilV       -> Yes (DNilV)
  ConsV [n1] x xs -> 
    case b of
      NilV       -> Yes (lemma_y_empty_disjoint_vec Nat n a b (Refl))
      ConsV [m1] y ys -> 
        case (decDisjointVecs (pred n) xs m b) of
          Yes pf    -> 
            case (isElemVec m x b) of
              Yes elemPf  -> No (DisjointVec Nat n a m b) (lemma_x_in_b_vec Nat x (pred n) xs m b (HereV [n1] xs) elemPf)
              No prop p   -> Yes (DConsV [n1] x xs (p) pf)
          No prop p -> No (DisjointVec Nat n a m b) (lemma_xs_in_b_vec Nat x (pred n) xs m b p)


consVInjLem : [n : Nat] -> [x : Nat] -> [xs : Vec Nat n] -> [y : Nat] -> [ys : Vec Nat n] 
           -> (x = y) -> (xs = ys) -> (ConsV [n] x xs : Vec Nat (Succ n)) = (ConsV [n] y ys : Vec Nat (Succ n))
consVInjLem = \[n] [x] [xs] [y] [ys] prf1 prf2 . 
  subst (f_equal [Vec Nat n] [Vec Nat n] [\a . ConsV [n] x a] [xs] [ys] prf2) by prf1

consVInjective : [A : Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> [y : A] -> [ys : Vec A n] 
             -> (x = y) 
             -> (p : (ConsV [n] x xs : Vec A (Succ n)) = (ConsV [n] y ys : Vec A (Succ n))) 
             -> xs = ys
consVInjective = \[A] [n] [x] [xs] [y] [ys] p1 p2 . 
     subst (f_equal [Vec A (Succ n)] [Vec A (n)] [tail [A] [n]] [ConsV [n] x xs] [ConsV [n] y ys] p2) by p1

consVInjectiveTail : [A : Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> [y : A] -> [ys : Vec A n] 
                 -> (xs = ys) 
                 -> (p : (ConsV [n] x xs : Vec A (Succ n)) = (ConsV [n] y ys : Vec A (Succ n))) 
                 -> x = y
consVInjectiveTail = \[A] [n] [x] [xs] [y] [ys] p1 p2 . 
     (f_equal [Vec A (Succ n)] [A] [head [A] [n]] [ConsV [n] x xs] [ConsV [n] y ys] p2)

lemma_x_eq_xs_neq_vec : [A :Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> [y : A] -> [ys : Vec A n] 
                 -> (x = y) 
                 -> (xs = ys -> Void) 
                 -> ((ConsV [n] x xs : Vec A (Succ n)) = (ConsV [n] y ys : Vec A (Succ n))-> Void)
lemma_x_eq_xs_neq_vec = \[A] [n] [x] [xs] [y] [ys] prf1 p prf2 . p (consVInjective [A] [n] [x] [xs] [y] [ys] prf1 prf2)

lemma_x_neq_xs_eq_vec : [A :Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> [y : A] -> [ys : Vec A n] 
                 -> (x = y -> Void) 
                 -> (xs = ys) 
                 -> ((ConsV [n] x xs : Vec A (Succ n)) = (ConsV [n] y ys : Vec A (Succ n))-> Void)
lemma_x_neq_xs_eq_vec = \[A] [n] [x] [xs] [y] [ys] p p2 p3 . p (consVInjectiveTail [A] [n] [x] [xs] [y] [ys] p2 p3)

lemma_x_neq_xs_neq_vec : [A :Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> [y : A] -> [ys : Vec A n] 
                 -> (x = y -> Void)
                 -> (xs = ys -> Void)
                 -> ((ConsV [n] x xs : Vec A (Succ n)) = (ConsV [n] y ys : Vec A (Succ n)) -> Void)
lemma_x_neq_xs_neq_vec = \[A] [n] [x] [xs] [y] [ys] p p2 p3 . 
     p ((f_equal [Vec A (Succ n)] [A] [head [A] [n]] [ConsV [n] x xs] [ConsV [n] y ys] p3))

decEqVec : [n : Nat] -> (a : Vec Nat n) -> (b : Vec Nat n) -> Dec (a = b)
decEqVec = \ [n] a b . case a of
  NilV            -> 
    case b of
      NilV            -> Yes Refl
  ConsV [n1] x xs ->
    case b of
      ConsV [m1] y ys ->
        case (decEqNat x y) of
          Yes xeqy    -> 
            case (decEqVec [n1] xs ys) of
              Yes xseqys    -> Yes (consVInjLem [n1] [x] [xs] [y] [ys] xeqy xseqys)
              No t xsneqys  -> No ((ConsV [n1] x xs : Vec Nat n) = (ConsV [m1] y ys : Vec Nat n)) (lemma_x_eq_xs_neq_vec [Nat] [n1] [x] [xs] [y] [ys] xeqy xsneqys)
          No t xneqy  ->
            case (decEqVec [n1] xs ys) of
              Yes xseqys    -> No ((ConsV [n1] x xs : Vec Nat n) = (ConsV [m1] y ys : Vec Nat n)) (lemma_x_neq_xs_eq_vec [Nat] [n1] [x] [xs] [y] [ys] xneqy xseqys)
              No t2 xsneqys -> No ((ConsV [n1] x xs : Vec Nat n) = (ConsV [m1] y ys : Vec Nat n)) (lemma_x_neq_xs_neq_vec [Nat] [n1] [x] [xs] [y] [ys] xneqy xsneqys)


data UniqueVec (A : Type) (n : Nat) (v : Vec A n) : Type where
  UNilV of [v = NilV] [n = 0]-- Constructor for when V is empty
  UConsV of (m : Nat) (x : A) (xs : Vec A m) (Not (ElemVec A m x xs)) (UniqueVec A m xs) [n = Succ m] [v = ConsV [m] x xs]

lemma_x_in_xs_not_unique : [A : Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> (ElemVec A n x xs) -> ((UniqueVec A (Succ n) (ConsV [n] x xs)) -> Void)
lemma_x_in_xs_not_unique = \ [A] [n] [x] [xs] pf p . case p of
  UConsV m x xs xNInXs others -> xNInXs pf

lemma_xs_not_unique : [A : Type] -> [n : Nat] -> [x : A] -> [xs : Vec A n] -> ((UniqueVec A n xs) -> Void) -> ((UniqueVec A (Succ n) (ConsV [n] x xs)) -> Void)
lemma_xs_not_unique = \ [A] [n] [x] [xs] pf p . case p of
  UConsV m x xs xNInXs others -> pf others


decUniqueVec : (n : Nat) -> (v : Vec Nat n) -> Dec (UniqueVec Nat n v)
decUniqueVec = \ n v . case v of 
  NilV           -> Yes UNilV
  ConsV [m] x xs ->
    case (isElemVec (pred n) x xs) of
      Yes xInXs    -> No (UniqueVec Nat n v) (lemma_x_in_xs_not_unique [Nat] [m] [x] [xs] xInXs)
      No t1 xNInXs ->
        case (decUniqueVec (pred n) xs) of
          Yes xsU ->  Yes (UConsV (pred n) x xs xNInXs xsU)
          No t2 xsNU -> No (UniqueVec Nat n v) (lemma_xs_not_unique [Nat] [m] [x] [xs] xsNU)

data SubsetVec (A : Type) (n : Nat) (a : Vec A n) (m : Nat) (b : Vec A m): Type where
  SNilV1 of [n = 0] [a = NilV]
  SNilV2 of [m = 0] [b = NilV]
  SConsV of [n1 : Nat] (x : A) (xs : Vec A n1) (pfForx : (ElemVec A m x b))  (SubsetVec A n1 xs m b) [n = Succ n1] [a = ConsV [n1] x xs]

lemma_x_not_in_b_vec : [A : Type] -> (x : A) -> (n : Nat) -> (xs : Vec A n) -> (y : A) -> (m : Nat) -> (ys : Vec A m) -> ((ElemVec A (Succ m) x (ConsV [m] y ys)) -> Void) -> ((SubsetVec A (Succ n) (ConsV [n] x xs) (Succ m) (ConsV [m] y ys)) -> Void)
lemma_x_not_in_b_vec = \ [A] x n xs y m ys pfXNotInb pf .
  case pf of 
    SConsV [n1] a as pfFora others -> pfXNotInb pfFora

lemma_xs_not_subset_b_vec : [A : Type] -> (x : A) -> (n : Nat) -> (xs : Vec A n) -> (y : A) -> (m : Nat) -> (ys : Vec A m) -> ((SubsetVec A n xs (Succ m) (ConsV [m] y ys)) -> Void) -> ((SubsetVec A (Succ n) (ConsV [n] x xs) (Succ m) (ConsV [m] y ys)) -> Void)
lemma_xs_not_subset_b_vec = \ [A] x n xs y m ys xsNotSubsetPf p .
  case p of
    SConsV [n1] a as pfFora others -> xsNotSubsetPf others

decSubsetVecs : (n : Nat) -> (a : Vec Nat n) -> (m : Nat) -> (b : Vec Nat m) -> Dec (SubsetVec Nat n a m b)
decSubsetVecs = \ n a m b . case a of
  NilV       -> Yes (SNilV1)
  ConsV [n1] x xs -> 
    case b of
      NilV       -> Yes (SNilV2)
      ConsV [m1] y ys -> 
        case (decSubsetVecs (pred n) xs m b) of
          Yes pf    -> 
            case (isElemVec m x b) of
              Yes elemPf  -> Yes (SConsV [n1] x xs (elemPf) pf)
              No prop p   -> No (SubsetVec Nat n a m b) (lemma_x_not_in_b_vec [Nat] x (pred n) xs y (pred m) ys (p))
          No prop p -> No (SubsetVec Nat n a m b) (lemma_xs_not_subset_b_vec [Nat] x (pred n) xs y (pred m) ys p)

-- th_x_not_in_b_imp_x_not_in_subset_b : [A : Type] -> (x : A)