module Concurrency where

import Queue
import Maybe
import IO
import ProofHelper
------------------ MUTABLE VARIABLES ------------------

-- current_channel_id : IORef Nat
-- current_channel_id = makeIORef [Nat] 0

-- current_process_id : IORef Nat
-- current_process_id = makeIORef [Nat] 0

------------------ PID ------------------

-- | PID Structure
data PID (pid : Nat) : Type where
    MkPID of [id : Nat] [id = pid]

------------------ CHANNEL ------------------

-- Channel Structure
data Channel (A : Type) (chid : Nat) : Type where
    MkChannel of [id : Nat] [id = chid]

-- | Channel helper functions

-- | This function is an enqueue to a channel
channelEnqueue : [A : Type] -> [id : Nat] -> (x : Maybe A) -> Channel A id -> IO Unit
channelEnqueue = TRUSTME

-- | This function is an unsafe dequeue from a channel, meaning that the mutex cannot be guaranteed to be acquired
channelDequeue : [A : Type] -> [id : Nat] -> Channel A id -> IO (Maybe A)
channelDequeue = TRUSTME

------------------ PI-CALC ------------------

-- | Pi-Calculus functions

end : IO Unit
end = TRUSTME

send : [A : Type] -> [id : Nat] -> (x : Maybe A) -> Channel A id -> IO Unit
send = \ [A] [id] x ch . channelEnqueue [A] [id] x ch

receive : [A : Type] -> [id : Nat] -> Channel A id -> IO (Maybe A)
receive = \ [A] [id] ch . channelDequeue [A] [id] ch

link : [A : Type] -> [id : Nat] -> IO (Maybe (Channel A id))
link = TRUSTME

spawn : (pid : Nat) -> (pidSet : List Nat) -> ((Elem Nat pid pidSet) -> Void) -> IO (Maybe ({newPid : PID pid | List Nat}))
spawn = \ pid pidSet pf . returnIO [Maybe ({newPid : PID pid | List Nat})] (Just (MkPID [pid], Cons pid pidSet))

run : (pid : Nat) -> (pidSet : List Nat) -> ((Elem Nat pid pidSet)) -> (process : IO Unit) -> IO (Maybe ({newPid : PID pid | List Nat}))
run = \ pid pidSet pf process . returnIO [Maybe ({newPid : PID pid | List Nat})] (Just (MkPID [pid], Cons pid pidSet))


--spawn : (pid : Set pid) -> (pid | Proccess pid && set pid U new pid)

