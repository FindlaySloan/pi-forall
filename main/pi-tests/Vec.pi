-----------------------------------------------------------------------
-- PI library for finite-length vectors
--
-- Some of these are adapted from Vec.agda
--
-- Author: Stephanie Weirich
-----------------------------------------------------------------------

module Vec where

import Equality
import Nat
import Fin
import Product
import ProofHelper

data Vec (A : Type) (n : Nat) : Type where
  NilV  of                       [n = Zero] 
  ConsV of [m:Nat] (A) (Vec A m) [n = Succ m]

-- A vector with exactly three boolean values

v3 : Vec Bool 3 
v3 = ConsV [2] True (ConsV [1] False (ConsV [0] False NilV))

head : [A :Type] -> [n:Nat] -> Vec A (Succ n) -> A
head = \ [A][n] x.  case x of 
     ConsV [m] y ys -> y
	  -- NilV case is impossible

tail : [A :Type] -> [n:Nat] -> Vec A (Succ n) -> Vec A n
tail = \ [A][n] x.  case x of 
     -- NilV case impossible
     ConsV [m] y ys -> ys

append : [A :Type] ->[m:Nat] -> [n:Nat] -> Vec A m -> Vec A n -> Vec A (plus m n)
append = \[A] [m] [n] v1 ys . case v1 of 
     ConsV [m0] x xs -> ConsV [plus m0 n] x (append [A] [m0][n] xs ys)
     NilV -> ys


zap : [A:Type] -> [B: Type] -> [n:Nat] -> Vec (A -> B) n -> Vec A n -> Vec B n
zap = \[A][B] [n] vs1 vs2 . 
  case vs1 of 
    NilV -> case vs2 of 
       NilV   -> NilV 
       -- Cons case impossible
    ConsV [m1] f fs -> case vs2 of 
       -- Nil case impossible
       ConsV [m2] x xs -> 
		    ConsV [m1] (f x) (zap [A][B][m1] fs xs)

replicate : [A:Type] -> (n:Nat) -> A -> Vec A n
replicate = \[A] n x. 
   case n of 
     Zero   -> NilV 
     Succ m -> ConsV [m] x (replicate [A] m x)

mapV : [A:Type] -> [B:Type] -> [n:Nat] -> (A -> B) -> Vec A n -> Vec B n
mapV = \[A][B][n] f v.
  case v of 
    NilV -> NilV
    ConsV [m] x xs -> ConsV [m] (f x) (mapV[A][B] [m] f xs)

-- note: this version of map needs n at runtime

mapn : [A:Type] -> [B:Type] -> (n:Nat) -> (A -> B) -> Vec A n -> Vec B n
mapn = \[A][B] n f v. zap[A][B][n] (replicate [A->B] n f) v

zipWith : [A:Type]->[B:Type]->[C:Type] -> (n:Nat) -> (A -> B -> C) 
		  -> Vec A n -> Vec B n -> Vec C n
zipWith = \[A][B][C] n f v1 v2. 
  zap[B][C][n] (zap [A][B -> C][n] (replicate [A -> B -> C] n f) v1) v2

zip : [A:Type] -> [B:Type] -> (n:Nat) -> Vec A n -> Vec B n -> Vec (Times A B) n
zip = \[A][B] n . zipWith [A][B][Times A B] n (prod[A][B])

-- easiest version of foldr makes m irrelevant
foldr : [A:Type]-> [B:Nat -> Type] -> [m:Nat] -> 
        (f : [n:Nat] -> A -> B n -> B (Succ n)) ->    
        B Zero ->
        Vec A m -> B m
foldr = \[A][B] [m] f n v . 
  case v of 
    NilV -> n
    ConsV [m'] x xs -> f [m'] x (foldr [A][B][m'] f n xs)

-- we can also make m relevant
foldr' : [A:Type]-> [B:Nat -> Type] -> (m:Nat) -> 
        (f : (n:Nat) -> A -> B n -> B (Succ n)) ->    
        B Zero ->
        Vec A m -> B m
foldr' = \[A][B] m f n v . 
  case v of 
    NilV -> n
    ConsV [m'] x xs -> f (pred m) x (foldr' [A][B] (pred m) f n xs)


-- we can also define foldr' by induction on m
foldr'' : [A:Type]-> [B:Nat -> Type] -> (m:Nat) -> 
        (f : (n:Nat) -> A -> B n -> B (Succ n)) ->    
        B Zero ->
        Vec A m -> B m
foldr'' = \[A][B] m f n v . 
  case m of 
    Zero -> 
      case v of 
        NilV -> n
    Succ m1 -> 
      case v of 
        ConsV [m2] x xs -> 
          f m1 x (foldr'' [A][B] m1 f n xs)
          
data In (A:Type) (x:A) (n:Nat) (v:Vec A n) : Type where
  Here  of [m:Nat][n = Succ m][xs : Vec A m] 
           [v = ConsV [m] x xs]
  There of [m:Nat][n = Succ m][xs : Vec A m] 
           [y:A][v = ConsV [m] y xs]
           (In A x m xs)

singleton : [A:Type] -> A -> Vec A 1
singleton = \[A] x. ConsV [0] x NilV
          



foldr1 : [A:Type] -> [m:Nat] -> 
       (A -> A -> A) -> Vec A (Succ m) -> A
foldr1 = \[A] [m] f v . case v of 
  ConsV [m'] x ys -> 
      case ys of 
         NilV -> x
         ConsV [m''] y xs ->
            f x (foldr1 [A][m''] f (ConsV [m''] y xs))


concat : [A:Type] -> [m : Nat] -> [n : Nat] -> Vec (Vec A m) n -> Vec A (mult n m)
concat = \[A][m] [n] v. case v of 
   NilV -> NilV
   ConsV [n'] xs xss -> append[A][m][mult n' m] xs (concat[A][m] [n'] xss)


foldl : [A: Type] -> [m : Nat] -> [B : Nat -> Type] -> 
      ([n:Nat] -> B n -> A -> B (Succ n)) ->
      B Zero ->
      Vec A m -> B m
foldl = \[A] [m] [B] f z v . 
  case v of 
    NilV  -> z
    ConsV [m'] x xs -> 
	    let n' = f [0] z x in
       foldl [A][m'][\ n'. B (Succ n')] (\[n] b a . f [Succ n] b a) n' xs


fst : [A:Type] -> [B:A -> Type] -> { x : A | B x } -> A
fst = \[A][B] x . let (y,z) = x in y 

snd : [A:Type] -> [B:A -> Type] -> (p : { x:A | B x}) -> B (fst[A][B] p)
snd = \[A][B] x . let (y,z) = x in z
  

-- note that in pi-forall, we only have one notion of irrelevance: 
-- arguments are either erasable and ignorable, or they are relevant.


filter : [A:Type] -> [n:Nat] -> (A -> Bool) -> 
       Vec A n -> { m : Nat | Vec A m } 
filter = \ [A][n] f v . 
   case v of 
     NilV -> ( 0 , NilV )
     ConsV [n'] x xs -> 
        let p = filter [A][n'] f xs in 
        let m' = fst [Nat] [\n. Vec A n] p in
        let xs' = snd [Nat] [\n. Vec A n] p in
        if f x
           then (Succ m' , ConsV [m'] x xs')
           else (m', xs')
