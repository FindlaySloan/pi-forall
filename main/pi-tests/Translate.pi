module Translate where

data Vec (A : Type) (n : Nat) : Type where
  NilV  of                       [n = Zero] 
  ConsV of [m:Nat] (A) (Vec A m) [n = Succ m]

plus : Nat -> Nat -> Nat
plus = \ n m .
  case n of
    Zero -> m
    Succ pred -> Succ (plus pred m)

mult : Nat -> Nat -> Nat
mult = \ n m .
  case n of
    Zero -> Zero
    Succ pred -> plus m (mult pred m)


minus : Nat -> Nat -> Nat
minus = \n m .
   case n of
     Zero -> Zero
     Succ p -> case m of
                    Zero -> n
                    Succ mpred -> minus p mpred

pred : Nat -> Nat
pred = \n . case n of 
    Zero -> Zero
    Succ m -> m

mapV : [A:Type] -> [B:Type] -> [n:Nat] -> (A -> B) -> Vec A n -> Vec B n
mapV = \[A][B][n] f v.
  case v of 
    NilV -> NilV
    ConsV [m] x xs -> ConsV [m] (f x) (mapV[A][B] [m] f xs)

headV : [A :Type] -> [n:Nat] -> Vec A (Succ n) -> A
headV = \ [A][n] x.  case x of 
     ConsV [m] y ys -> y
	  -- NilV case is impossible

tailV : [A :Type] -> [n:Nat] -> Vec A (Succ n) -> Vec A n
tailV = \ [A][n] x.  case x of 
     -- NilV case impossible
     ConsV [m] y ys -> ys



transpose : [n : Nat] -> [m : Nat] -> Vec (Vec Nat m) n -> Vec (Vec Nat n) m
transpose = \ [r] [c] m . case m of
  NilV -> NilV
  ConsV [rPred] y _ -> case y of 
    NilV -> NilV
    ConsV [cPred] _ _ -> ConsV  [cPred] (mapV [Vec Nat c] [Nat] [r] (headV [Nat] [cPred]) m) (transpose [r] [cPred] (mapV [Vec Nat c] [Vec Nat cPred] [r] (tailV [Nat] [cPred]) m))





-- matMul : [n : Nat] -> [m : Nat] -> Vec (Vec Nat m) n -> Vec (Vec Nat m) n -> Vec (Vec Nat m) n
-- matMul = \ [r] [c] m1 m2 . 
