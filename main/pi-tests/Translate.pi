module Translate where

data Void : Type where {}   -- no constructors

Not : Type -> Type
Not = \a . (a -> Void)

data Dec (a : Type) : Type where
  Yes of (prf : a)
  No  of (prop : Type) (cont : Not prop) [a=prop]

sym : [A:Type] -> [x:A] -> [y:A] -> (x = y) -> y = x
sym = \ [A] [x] [y] pf .
  subst Refl by pf

lemma_eq_sym : (A : Type) -> (x : A) -> (y : A) -> x = y -> y = x
lemma_eq_sym = \ A x y pf . subst Refl by pf

lemma_n_not_Z : (x : Nat) -> x = Zero -> (y : Nat) -> Zero = (Succ y) -> Void
lemma_n_not_Z = \x pfXisZ y pf2 . contra pf2



t_Z_Eq_Sn : (x : Nat) -> (y : Nat) -> Dec (x=y)
t_Z_notEq_Sn = \x y .
    case x of
        Zero    -> case y of
                    Zero    -> Yes Refl
                    Succ n  -> No (x=y) (lemma_n_not_Z x n)
        Succ n1 -> case y of
                    Zero    -> No (x=y) (lemma_n_not_Z x n1)
                    Succ n2 -> lemma_Z_notEq_Sn n1 n2

{--
data Void : Type where {}   -- no constructors



data Maybe (A : Type) : Type where
    Nothing
    Just of (A)

nat_eq : (x : Nat) -> (y : Nat) -> Bool
nat_eq = \x y . case x of
                    Zero    -> case y of
                                  Zero      -> True
                                  Succ _    -> False
                    Succ n  -> case y of
                                  Zero      -> False
                                  Succ n1   -> nat_eq n n1
--}
{--
g : (x : Nat) -> (y : Nat) -> x=y -> Void
g = \ x y pf . contra pf
--}
{--
h : (x : Nat) -> (y : Nat) -> nat_eq x y = False -> x=y -> Void
h = \ x y pf1 pf2. case x of
                    Zero -> case y of
                                Zero -> contra pf1
                                Succ n -> contra pf2
                    Succ n -> case y of
                                 Zero -> contra pf2
                                 Succ n1 -> contra pf2

--}
{--
neg : Type -> Type
neg = \ x . (x -> Void)

notEq : [A : Type] -> [x : A] -> [y : A] -> (x = y) -> Void
notEq = TRUSTME

data Channel (id : Nat) (A : Type) : Type where
    Chan of [id : Nat]

data Process (A : Type) (B : Type) (idIn : Nat) (idOut : Nat) (Channel idIn A) (Channel idOut B) : Type where
    Proc of (A->B)

pipeline2 : [x : Nat] -> [y : Nat] -> [z : Nat] -> [(x = z) -> Void] -> Process Char Char x y (Chan [x]) (Chan [y]) -> Process Char Char y z (Chan [y]) (Chan [z]) -> Char
pipeline2 = \ [x] [y] [z] [pf] p1 p2 . 'a'

m : Char
m = pipeline2 [1] [2] [3] [notEq [Nat] [1] [3]] (Proc (\c. c : Char -> Char)) (Proc (\d . d : Char -> Char))
--}
{--
data Vec (A : Type) (n : Nat) : Type where
  Nil1  of                       [n = Zero]
  Cons1 of [m:Nat] (A) (Vec A m) [n = Succ m]

head : [A :Type] -> [n:Nat] -> Vec A (Succ n) -> A
head = \ [A][n] x.  case x of
     Cons1 [m] y ys -> y
	  -- Nil case is impossible

m : Char
m = head [Char] [0] (Cons1 [0] 'a' Nil1)
--}